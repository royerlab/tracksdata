{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TracksData","text":"<p>A common data structure and basic tools for multi-object tracking.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Graph-based representation of tracking problems</li> <li>In-memory (RustWorkX) and database-backed (SQL) graph backends</li> <li>Nodes and edges can take arbitrary attributes</li> <li>Standardize API for node operators (e.g. defining objects and their attributes)</li> <li>Standardize API for edge operators (e.g. creating edges between nodes)</li> <li>Basic tracking solvers: nearest neighbors and integer linear programming</li> <li>Compatible with Cell Tracking Challenge (CTC) format</li> <li>Efficient subgraphing based on attributes on any graph backend</li> <li>Integration with cell tracking evaluation metrics</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Until rustworkx 0.17.0 is released, you need to have rust installed to compile the latest rustworkx.</p> <pre><code>conda install -c conda-forge rust\n</code></pre> <p>Then install tracksdata with the following command:</p> <pre><code>pip install .\n</code></pre>"},{"location":"#why-tracksdata","title":"Why tracksdata?","text":"<p>TracksData provides a common data structure for multi-object tracking problems. It uses graphs to represent detections (nodes) and their connections (edges), making it easier to work with tracking data across different algorithms.</p> <p>Key benefits: - Consistent data representation for tracking problems - Modular components that can be combined as needed - Support for both small datasets (in-memory) and large datasets (database)</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Full Documentation</li> <li>Installation</li> <li>Core Concepts</li> <li>Getting Started</li> <li>API Reference</li> <li>FAQ</li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":""},{"location":"concepts/#graph-based-tracking","title":"Graph-Based Tracking","text":"<p>TracksData represents tracking data as a directed graph where:</p> <ul> <li>Nodes are detections/objects at specific time points</li> <li>Edges connect objects across consecutive time frames forward in time (t to t + delta_t)</li> <li>Tracks are paths through the graph representing object trajectories</li> </ul>"},{"location":"concepts/#graph-backends","title":"Graph Backends","text":"<p>TracksData supports multiple graph backends for different use cases:</p>"},{"location":"concepts/#rustworkxgraph","title":"RustWorkXGraph","text":"<ul> <li>Use case: In-memory graphs that fit in RAM</li> <li>Performance: Excellent for algorithms and analysis</li> <li>Recommended: For most tracking applications</li> </ul>"},{"location":"concepts/#sqlgraph","title":"SQLGraph","text":"<ul> <li>Use case: Large datasets that don't fit in memory</li> <li>Performance: Good for storage and querying</li> <li>Features: Persistent storage, complex queries</li> </ul>"},{"location":"concepts/#graphview","title":"GraphView","text":"<ul> <li>Use case: Results subgraph either backends</li> <li>Performance: Low overhead, similar to RustWorkXGraph</li> <li>Features: Maintains connection to root graph, all operations are mirrored to the root graph</li> </ul>"},{"location":"concepts/#graph-operators","title":"Graph Operators","text":"<p>Graph operators are used to manipulate the graph:</p> <ul> <li>Node operators: Create or add attributes to nodes</li> <li>Edge operators: Create or add attributes to edges</li> <li>Solver operators: Solve the tracking problem</li> </ul>"},{"location":"concepts/#attribute-system","title":"Attribute System","text":"<p>TracksData uses a flexible attribute system:</p>"},{"location":"concepts/#node-attributes","title":"Node Attributes","text":"<ul> <li>Store object properties (coordinates, features, measurements)</li> <li>Support various data types (floats, arrays, segmentation masks)</li> </ul>"},{"location":"concepts/#edge-attributes","title":"Edge Attributes","text":"<ul> <li>Store connection properties (distances, costs, confidences)</li> <li>Used by solvers for optimization</li> </ul>"},{"location":"concepts/#attribute-expressions","title":"Attribute Expressions","text":"<p>Attributes are used to filter nodes or edges, or to formulate the objective function for solvers.</p> <pre><code>import tracksdata as td\n\n# Simple attribute access\nx_coords = td.NodeAttr(\"x\")\n\n# Mathematical expressions\ndistance_cost = td.EdgeAttr(\"distance\") + 0.1 * td.EdgeAttr(\"angle_change\")\n\n# Comparison operations for filtering\nrecent_nodes = td.NodeAttr(\"t\") &gt;= 10\nlarge_objects = td.NodeAttr(\"area\") &gt; 100\n</code></pre>"},{"location":"concepts/#data-flow","title":"Data Flow","text":"<p>A typical TracksData workflow:</p> <ol> <li>Create Graph: Choose appropriate backend</li> <li>Add Nodes: Use node operators to populate detections</li> <li>Add Edges: Use edge operators to create potential connections</li> <li>Solve: Apply solver to find optimal tracks</li> <li>Analyze: Query and filter results for downstream analysis</li> </ol> <p>This modular design allows mixing and matching components for different tracking scenarios.</p>"},{"location":"contributing/","title":"Contributing to Documentation","text":""},{"location":"contributing/#documentation-versioning","title":"Documentation Versioning","text":"<p>This project uses mike for documentation versioning. Documentation is automatically built and deployed via GitHub Actions.</p>"},{"location":"contributing/#automatic-deployment","title":"Automatic Deployment","text":"<ul> <li>Development docs: Built on every push to <code>main</code> branch \u2192 available at <code>/dev/</code></li> <li>Release docs: Built on every tag push (<code>v*</code>) \u2192 available at <code>/latest/</code> and <code>/v{version}/</code></li> </ul>"},{"location":"contributing/#manual-version-management","title":"Manual Version Management","text":"<p>If you need to manually manage documentation versions:</p> <pre><code># Install dependencies\nuv sync --extra docs\n\n# Deploy a new version\nuv run mike deploy --push --update-aliases v1.0.0 latest\n\n# Set default version\nuv run mike set-default --push latest\n\n# List all versions\nuv run mike list\n\n# Delete a version\nuv run mike delete --push v0.9.0\n</code></pre>"},{"location":"contributing/#local-development","title":"Local Development","text":"<p>To build and serve documentation locally:</p> <pre><code># Serve with live reload\nuv run mkdocs serve\n\n# Build static site\nuv run mkdocs build\n</code></pre>"},{"location":"contributing/#version-structure","title":"Version Structure","text":"<ul> <li><code>latest</code> - Latest stable release</li> <li><code>dev</code> - Development version from main branch</li> <li><code>v{X.Y.Z}</code> - Specific version tags</li> </ul> <p>The documentation will be available at: - https://royerlab.github.io/tracksdata/ (latest) - https://royerlab.github.io/tracksdata/dev/ (development) - https://royerlab.github.io/tracksdata/v1.0.0/ (specific version)</p>"},{"location":"examples/","title":"Examples","text":"<p>This section provides practical examples of using TracksData for multi-object tracking tasks.</p>"},{"location":"examples/#basic-tracking-example","title":"Basic Tracking Example","text":"<p>Here's a complete basic example that demonstrates the core workflow of TracksData. This example is available as an executable Python file at <code>docs/examples/basic.py</code>.</p> <pre><code>\"\"\"\nBasic multi-object tracking example using TracksData.\n\nThis example demonstrates the complete workflow for tracking objects across time:\n1. Load segmented image data\n2. Extract object features (nodes) from each frame\n3. Create temporal connections (edges) between objects\n4. Compute additional attributes to edges (e.g. IoU)\n5. Solve the tracking optimization problem\n6. Convert results to napari format\n7. Visualize results\n\n\nRequirements:\n- Set CTC_DIR environment variable pointing to Cell Tracking Challenge data\n- Example assumes Fluo-N2DL-HeLa dataset structure\n\nUsage:\n    python basic.py                    # Run with napari visualization\n    python basic.py --profile          # Run with performance profiling\n\"\"\"\n\nimport os\nfrom pathlib import Path\n\nimport click\nimport napari\nimport numpy as np\nfrom profilehooks import profile as profile_hook\nfrom tifffile import imread\n\nimport tracksdata as td\n\n\ndef basic_tracking_example(show_napari_viewer: bool = True) -&gt; None:\n    \"\"\"\n    Perform basic multi-object tracking on segmented microscopy data.\n\n    This function demonstrates the core TracksData workflow:\n    - Node extraction from regionprops\n    - Distance-based edge creation\n    - IoU attribute computation\n    - Nearest neighbors tracking solution\n\n    Parameters\n    ----------\n    show_napari_viewer : bool\n        Whether to display results in napari viewer\n    \"\"\"\n    # Step 1: Load and prepare data\n\n    # Load example data from Cell Tracking Challenge format\n    data_dir = Path(os.environ[\"CTC_DIR\"]) / \"training/Fluo-N2DL-HeLa/01_GT/TRA\"\n    assert data_dir.exists(), f\"Data directory {data_dir} does not exist.\"\n\n    # Load all timepoints as a 3D array: (time, height, width)\n    labels = np.stack(\n        [imread(p) for p in sorted(data_dir.glob(\"*.tif\"))],\n    )\n\n    # Configure TracksData options (disable progress bars for cleaner output)\n    td.options.set_options(show_progress=False)\n\n    print(\"Starting tracking workflow...\")\n\n    # Step 2: Initialize graph and extract nodes\n    graph = td.graph.InMemoryGraph()\n\n    # Extract object features using region properties\n    # This creates one node per object per timeframe\n    nodes_operator = td.nodes.RegionPropsNodes()\n    nodes_operator.add_nodes(graph, labels=labels)\n    print(f\"\u2713 Extracted {graph.num_nodes} nodes from {labels.shape[0]} timeframes\")\n\n    # Step 3: Create temporal edges between consecutive frames\n\n    # Add distance-based edges between objects in consecutive timeframes\n    # Only connects objects within distance_threshold and limits to n_neighbors\n    dist_operator = td.edges.DistanceEdges(\n        distance_threshold=30.0,\n        n_neighbors=5,\n    )\n    dist_operator.add_edges(graph)\n    print(f\"\u2713 Created {graph.num_edges} potential temporal connections\")\n\n    # Step 4: Add IoU (Intersection over Union) attributes to edges\n\n    # Compute IoU between connected objects to measure shape similarity\n    # Higher IoU values indicate better matches for tracking\n    iou_operator = td.edges.IoUEdgeAttr(output_key=\"iou\")\n    iou_operator.add_edge_attrs(graph)\n    print(\"\u2713 Computed IoU attributes for edge weights\")\n\n    # Step 5: Solve tracking optimization problem\n\n    # Create edge weights combining distance and IoU information\n    # Lower distance + higher IoU = better connection (lower cost)\n    dist_weight = 1 / dist_operator.distance_threshold\n\n    # Use nearest neighbors solver for fast, greedy tracking\n    # Each edge weight is defined as:\n    # - IoU(e_ij) * exp(-distance(e_ij) / dist_threshold)\n    # Where e_ij is the edge between nodes i and j.\n    # Alternative: ILPSolver for globally optimal but slower solutions\n    solver = td.solvers.NearestNeighborsSolver(\n        edge_weight=-td.EdgeAttr(\"iou\") * (td.EdgeAttr(\"distance\") * dist_weight).exp(),\n        max_children=2,  # Allow cell divisions (max 2 children per parent)\n    )\n\n    # Alternative ILP solver (uncomment for optimal tracking):\n    # solver = td.solvers.ILPSolver(\n    #     edge_weight=-td.EdgeAttr(\"iou\") * (td.EdgeAttr(\"weight\") * dist_weight).exp(),\n    #     node_weight=0.0,           # Cost for keeping an object\n    #     appearance_weight=1.0,    # Cost for object appearing\n    #     disappearance_weight=1.0, # Cost for object disappearing\n    #     division_weight=1.0,       # Cost for cell division\n    # )\n\n    solver.solve(graph)\n    print(\"\u2713 Solved tracking assignments\")\n\n    # Step 6: Convert results for visualization\n\n    # Convert tracking graph to napari-compatible format\n    # Returns: tracked labels, tracks dataframe, and track graph\n    print(\"Converting results to napari format...\")\n    tracks_df, track_graph, track_labels = td.functional.to_napari_format(graph, labels.shape, mask_key=\"mask\")\n\n    print(f\"\u2713 Generated {len(tracks_df)} track points across {len(set(tracks_df['track_id']))} tracks\")\n\n    # Step 7: Visualize results (optional)\n\n    if show_napari_viewer:\n        print(\"Opening napari viewer...\")\n        viewer = napari.Viewer()\n\n        # Add original segmented labels\n        viewer.add_labels(track_labels, name=\"Tracked Labels\")\n\n        # Add tracking trajectories with lineage information\n        viewer.add_tracks(tracks_df, graph=track_graph, name=\"Tracks\")\n\n        # Start interactive viewer\n        napari.run()\n\n\n@click.command()\n@click.option(\"--profile\", is_flag=True, help=\"Enable performance profiling (disables napari viewer)\")\ndef main(profile: bool) -&gt; None:\n    \"\"\"Run the basic tracking example with optional profiling.\"\"\"\n    if profile:\n        # Run with performance profiling, no visualization\n        profile_hook(basic_tracking_example, immediate=True, sort=\"time\")(show_napari_viewer=False)\n    else:\n        # Normal run with visualization\n        basic_tracking_example(show_napari_viewer=True)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#key-components-explained","title":"Key Components Explained","text":"<ul> <li>Graph: The core data structure holding nodes (objects) and edges (connections)</li> <li>Nodes Operators: Extract object features from segmented images (RegionPropsNodes, MaskNodes, etc.)</li> <li>Edges Operators: Create temporal connections between objects (DistanceEdges, IoUEdges, etc.)</li> <li>Solvers: Optimize a minimization problem to find the best tracking assignments (NearestNeighborsSolver, ILPSolver)</li> <li>Functional: Utilities for format conversion and visualization</li> </ul>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Check the Getting Started guide for more detailed explanations</li> <li>Explore the Concepts page to understand the architecture</li> <li>See the API reference for complete documentation of all components</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-tracksdata","title":"What is TracksData?","text":"<p>TracksData is a Python library that provides a common data structure and tools for multi-object tracking. It uses a graph-based representation where objects are nodes and tracks are edges connecting objects across time.</p>"},{"location":"faq/#when-should-i-use-tracksdata","title":"When should I use TracksData?","text":"<p>TracksData is ideal for:</p> <ul> <li>Multi-object tracking in microscopy or computer vision</li> <li>Biological cell tracking and lineage analysis</li> <li>Particle tracking in physics simulations</li> <li>Any scenario requiring temporal object associations</li> </ul>"},{"location":"faq/#how-does-tracksdata-differ-from-other-tracking-libraries","title":"How does TracksData differ from other tracking libraries?","text":"<p>TracksData focuses on providing a general unified data structure and modular components that can be combined for different tracking scenarios and scale to large datasets (e.g. millions of nodes in terabytes of 3D + time imaging data).</p>"},{"location":"faq/#which-graph-backend-should-i-use","title":"Which graph backend should I use?","text":"<ul> <li>RustWorkXGraph: For most applications where data fits in memory</li> <li>SQLGraph: For large datasets or when you need persistent storage</li> <li>GraphView: You shouldn't instantiate this directly, it is used internally by the library when you use <code>graph.subgraph()</code></li> </ul>"},{"location":"faq/#can-tracksdata-handle-cell-divisions","title":"Can TracksData handle cell divisions?","text":"<p>Yes! The :class:<code>tracksdata.solvers.NearestNeighborsSolver</code> lets you defined the maximum number of children nodes and :class:<code>tracksdata.solvers.ILPSolver</code> specifically supports division events with configurable division costs.</p>"},{"location":"faq/#how-do-i-add-custom-attributes","title":"How do I add custom attributes?","text":"<pre><code># Add new attribute keys to the graph\ngraph.add_node_attr_key(\"my_feature\", 0.0)\ngraph.add_edge_attr_key(\"confidence\", 1.0)\n\n# Use them when adding nodes/edges\ngraph.add_node({\"t\": 0, \"x\": 10, \"my_feature\": 42.0})\ngraph.add_edge(source_id, target_id, {\"confidence\": 0.95})\n</code></pre>"},{"location":"faq/#how-do-i-create-custom-operators","title":"How do I create custom operators?","text":"<p>Inherit from :class:<code>tracksdata.edges.BaseEdgesOperator</code> or :class:<code>tracksdata.nodes.BaseNodesOperator</code> and implement <code>_add_edges_per_time</code> or <code>_add_nodes_per_time</code>:</p> <pre><code>import tracksdata as td\n\nclass CustomNodes(td.nodes.BaseNodesOperator):\n    def add_nodes(\n        self,\n        graph: td.graph.BaseGraph,\n        *,\n        t: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        # Your custom logic here to add nodes to the graph\n        pass\n</code></pre>"},{"location":"faq/#how-do-i-visualize-results","title":"How do I visualize results?","text":"<p>TracksData provides utilities for converting to napari format:</p> <pre><code>import tracksdata as td\n\nlabels = ...\n\ntracks_df, track_graph, track_labels = td.functional.to_napari_format(\n    solution_graph, shape=labels.shape, mask_key=\"mask\",\n)\n\nviewer = napari.Viewer()\nviewer.add_labels(track_labels)\nviewer.add_tracks(tracks_df, graph=track_graph)\nnapari.run()\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#basic-concepts","title":"Basic Concepts","text":"<p>TracksData is built around a graph-based representation of multi-object tracking data:</p> <ul> <li>Nodes represent objects at specific time points (detections)</li> <li>Edges represent connections between objects across time (connections)</li> <li>Attributes store additional data like coordinates, features, or costs</li> </ul>"},{"location":"getting_started/#quick-example","title":"Quick Example","text":"<p>Here's a simple example of creating a graph and adding tracking data:</p> <pre><code>import numpy as np\nimport tracksdata as td\n\n# Create a graph\ngraph = td.graph.InMemoryGraph()\n\n# Generate random nodes for testing\nnode_generator = td.nodes.RandomNodes(\n    n_time_points=5,\n    n_nodes_per_tp=(10, 15),\n    n_dim=2\n)\nnode_generator.add_nodes(graph)\n\n# Connect nearby nodes across time\nedge_generator = td.edges.DistanceEdges(\n    distance_threshold=0.3,\n    n_neighbors=3\n)\nedge_generator.add_edges(graph)\n\n# Solve the tracking problem\nsolver = td.solvers.NearestNeighborsSolver(edge_weight=\"distance\")\nsolution = solver.solve(graph)\n\nprint(f\"Original graph has {graph.num_nodes} nodes and {graph.num_edges} edges\")\nprint(f\"Solution has {solution.num_nodes} nodes and {solution.num_edges} edges\")\n</code></pre>"},{"location":"getting_started/#working-with-real-data","title":"Working with Real Data","text":"<p>For real tracking applications, you'll typically:</p> <ol> <li>Create nodes from detections using <code>RegionPropsNodes</code> for segmented images</li> <li>Add edges using <code>DistanceEdges</code> or custom edge operators</li> <li>Solve tracking using <code>ILPSolver</code> for optimal results or <code>NearestNeighborsSolver</code> for speed</li> <li>Analyze results using the graph's filtering and querying capabilities</li> </ol> <pre><code>import tracksdata as td\n\n# Extract nodes from labeled images\nnode_op = td.nodes.RegionPropsNodes(extra_properties=[\"area\", \"eccentricity\"])\nnode_op.add_nodes(graph, labels=labels)\n\n# Filter nodes by time\ngraph_filter = graph.filter(td.NodeAttr(\"t\") == 0)\nnode_data = graph_filter.node_attrs()\nprint(node_data)\n</code></pre>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>See the Concepts page for detailed explanations</li> <li>Check the FAQ for common questions</li> <li>Browse the API documentation for complete reference</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>TracksData requires Python 3.10 or later.</p>"},{"location":"installation/#installing-rust-required","title":"Installing Rust (Required)","text":"<p>Until rustworkx 0.17.0 is released, you need to have Rust installed to compile the latest rustworkx:</p> <pre><code>conda install -c conda-forge rust\n</code></pre>"},{"location":"installation/#install-tracksdata","title":"Install TracksData","text":""},{"location":"installation/#from-source-development","title":"From Source (Development)","text":"<p>To install the latest development version:</p> <pre><code>git clone https://github.com/royerlab/tracksdata.git\ncd tracksdata\npip install .\n</code></pre>"},{"location":"installation/#with-optional-dependencies","title":"With Optional Dependencies","text":"<p>For testing: <pre><code>pip install .[test]\n</code></pre></p> <p>For documentation: <pre><code>pip install .[docs]\n</code></pre></p>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>You can verify the installation by importing the library:</p> <pre><code>import tracksdata as td\nprint(td.__version__)\n</code></pre>"},{"location":"reference/tracksdata/","title":"tracksdata","text":""},{"location":"reference/tracksdata/#tracksdata","title":"tracksdata","text":"<p>A common data structure and basic tools for multi-object tracking.</p> <p>Modules:</p> <ul> <li> <code>array</code>           \u2013            <p>Array representation of graphical data.</p> </li> <li> <code>attrs</code>           \u2013            <p>Module to compose attribute expressions for attribute filtering or value evaluation.</p> </li> <li> <code>constants</code>           \u2013            <p>Module to define default and often global values used through <code>tracksdata</code>.</p> </li> <li> <code>edges</code>           \u2013            <p>Edge operators for creating connections between nodes of a graph.</p> </li> <li> <code>functional</code>           \u2013            <p>Functional utilities for graph operations.</p> </li> <li> <code>graph</code>           \u2013            <p>Graph backends for representing tracking data as directed graphs in memory or on disk.</p> </li> <li> <code>io</code>           \u2013            <p>Input/output utilities for loading and saving tracking data in various formats.</p> </li> <li> <code>metrics</code>           \u2013            <p>Evaluation metrics for tracking performance, including the CTC benchmark metrics.</p> </li> <li> <code>nodes</code>           \u2013            <p>Node operators for creating nodes and their respective attributes (e.g. masks) in a graph.</p> </li> <li> <code>options</code>           \u2013            <p>Global options system for TracksData.</p> </li> <li> <code>solvers</code>           \u2013            <p>Solvers for finding a valid tracking solution from a candidate graph.</p> </li> <li> <code>utils</code>           \u2013            <p>Utility functions for data processing, type conversions, and progress tracking.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>EdgeAttr</code>           \u2013            <p>Wrapper of Attr to represent an edge attribute.</p> </li> <li> <code>NodeAttr</code>           \u2013            <p>Wrapper of Attr to represent a node attribute.</p> </li> </ul>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr","title":"EdgeAttr","text":"<pre><code>EdgeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <p>Wrapper of Attr to represent an edge attribute.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(other: ExprInput, op: Callable, reverse: bool = False) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr","title":"NodeAttr","text":"<pre><code>NodeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <p>Wrapper of Attr to represent a node attribute.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(other: ExprInput, op: Callable, reverse: bool = False) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/array/","title":"tracksdata.array","text":""},{"location":"reference/tracksdata/array/#tracksdata.array","title":"tracksdata.array","text":"<p>Array representation of graphical data.</p> <p>Provides read-only array views of graph attributes, with lazy loading from original data sources.</p> <p>Classes:</p> <ul> <li> <code>GraphArrayView</code>           \u2013            <p>Class used to view the content of a graph as an array.</p> </li> </ul>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView","title":"GraphArrayView","text":"<pre><code>GraphArrayView(graph: BaseGraph, shape: tuple[int, ...], attr_key: str = DEFAULT_ATTR_KEYS.BBOX, offset: int | ndarray = 0, chunk_shape: tuple[int, ...] | int | None = None, buffer_cache_size: int | None = None, dtype: dtype | None = None)\n</code></pre> <p>               Bases: <code>BaseReadOnlyArray</code></p> <p>Class used to view the content of a graph as an array.</p> <p>The resulting graph behaves as a read-only numpy array, displaying arbitrary attributes inside their respective instance mask.</p> <p>The content is lazy loaded from the original data source as it's done with a zarr.Array</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__array__</code>             \u2013              <p>Convert the GraphArrayView to a numpy array.</p> </li> <li> <code>__getitem__</code>             \u2013              <p>Return a sliced view of the GraphArrayView.</p> </li> <li> <code>__len__</code>             \u2013              <p>Returns the length of the first dimension of the array.</p> </li> <li> <code>reindex</code>             \u2013              <p>Reindex the GraphArrayView.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>dtype</code>               (<code>dtype</code>)           \u2013            <p>Returns the dtype of the array.</p> </li> <li> <code>ndim</code>               (<code>int</code>)           \u2013            <p>Returns the number of dimensions of the array.</p> </li> <li> <code>shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>Returns the shape of the array.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def __init__(\n    self,\n    graph: BaseGraph,\n    shape: tuple[int, ...],\n    attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    offset: int | np.ndarray = 0,\n    chunk_shape: tuple[int, ...] | int | None = None,\n    buffer_cache_size: int | None = None,\n    dtype: np.dtype | None = None,\n):\n    if attr_key not in graph.node_attr_keys:\n        raise ValueError(f\"Attribute key '{attr_key}' not found in graph. Expected '{graph.node_attr_keys}'\")\n\n    self.graph = graph\n    self._attr_key = attr_key\n    self._offset = offset\n\n    if dtype is None:\n        # Infer the dtype from the graph's attribute\n        # TODO improve performance\n        df = graph.node_attrs(attr_keys=[self._attr_key])\n        if df.is_empty():\n            dtype = get_options().gav_default_dtype\n        else:\n            dtype = polars_dtype_to_numpy_dtype(df[self._attr_key].dtype)\n            # napari support for bool is limited\n            if np.issubdtype(dtype, bool):\n                dtype = np.uint8\n\n    self._dtype = dtype\n    self.original_shape = shape\n\n    chunk_shape = chunk_shape or get_options().gav_chunk_shape\n    if isinstance(chunk_shape, int):\n        chunk_shape = (chunk_shape,) * (len(shape) - 1)\n    elif len(chunk_shape) &lt; len(shape) - 1:\n        chunk_shape = (1,) * (len(shape) - 1 - len(chunk_shape)) + tuple(chunk_shape)\n\n    self.chunk_shape = chunk_shape\n    self.buffer_cache_size = buffer_cache_size or get_options().gav_buffer_cache_size\n\n    self._indices = tuple(slice(0, s) for s in shape)\n    self._cache = NDChunkCache(\n        compute_func=self._fill_array,\n        shape=self.shape[1:],\n        chunk_shape=self.chunk_shape,\n        buffer_cache_size=self.buffer_cache_size,\n        dtype=self.dtype,\n    )\n\n    self._spatial_filter = self.graph.bbox_spatial_filter(\n        frame_attr_key=DEFAULT_ATTR_KEYS.T,\n        bbox_attr_key=DEFAULT_ATTR_KEYS.BBOX,\n    )\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to view as an array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(attr_key)","title":"<code>attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key to view as an array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(offset)","title":"<code>offset</code>","text":"(<code>int | ndarray</code>, default:                   <code>0</code> )           \u2013            <p>The offset to apply to the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape for the array. If None, the default chunk size is used.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(buffer_cache_size)","title":"<code>buffer_cache_size</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of buffers to keep in the cache for the array. If None, the default buffer cache size is used.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: dtype\n</code></pre> <p>Returns the dtype of the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.ndim","title":"ndim  <code>property</code>","text":"<pre><code>ndim: int\n</code></pre> <p>Returns the number of dimensions of the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Returns the shape of the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__array__","title":"__array__","text":"<pre><code>__array__(dtype: dtype | None = None, copy: bool | None = None) -&gt; np.ndarray\n</code></pre> <p>Convert the GraphArrayView to a numpy array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>In memory numpy array of the GraphArrayView of the current indices.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def __array__(\n    self,\n    dtype: np.dtype | None = None,\n    copy: bool | None = None,\n) -&gt; np.ndarray:\n    \"\"\"Convert the GraphArrayView to a numpy array.\n\n    Parameters\n    ----------\n    dtype : np.dtype, optional\n        The desired dtype of the output array. If None, the dtype of the GraphArrayView is used.\n    copy : bool, optional\n        This parameter is ignored, as the GraphArrayView is read-only.\n\n    Returns\n    -------\n    np.ndarray\n        In memory numpy array of the GraphArrayView of the current indices.\n    \"\"\"\n\n    if sum(isinstance(i, Sequence) for i in self._indices) &gt; 1:\n        raise NotImplementedError(\"Multiple sequences in indices are not supported for __array__.\")\n\n    time = self._indices[0]\n    volume_slicing = self._indices[1:]\n\n    if np.isscalar(time):\n        try:\n            time = time.item()  # convert from numpy.int to int\n        except AttributeError:\n            pass\n        return self._cache.get(\n            time=time,\n            volume_slicing=volume_slicing,\n        ).astype(dtype or self.dtype)\n    else:\n        if isinstance(time, slice):\n            time = range(self.original_shape[0])[time]\n\n        return np.stack(\n            [\n                self._cache.get(\n                    time=t,\n                    volume_slicing=volume_slicing,\n                )\n                for t in time\n            ]\n        ).astype(dtype or self.dtype)\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__array__(dtype)","title":"<code>dtype</code>","text":"(<code>dtype</code>, default:                   <code>None</code> )           \u2013            <p>The desired dtype of the output array. If None, the dtype of the GraphArrayView is used.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__array__(copy)","title":"<code>copy</code>","text":"(<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>This parameter is ignored, as the GraphArrayView is read-only.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: ArrayIndex) -&gt; GraphArrayView\n</code></pre> <p>Return a sliced view of the GraphArrayView.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphArrayView</code>           \u2013            <p>A new GraphArrayView object with updated indices.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def __getitem__(self, index: ArrayIndex) -&gt; \"GraphArrayView\":\n    \"\"\"Return a sliced view of the GraphArrayView.\n\n    Parameters\n    ----------\n    index : ArrayIndex\n        The indices to slice the array.\n\n    Returns\n    -------\n    GraphArrayView\n        A new GraphArrayView object with updated indices.\n    \"\"\"\n    normalized_index = []\n    if not isinstance(index, tuple):\n        index = (index,)\n    if None in index:\n        raise ValueError(\"None is not allowed for GraphArrayView indexing.\")\n    jj = 0\n    for oi in self._indices:\n        if np.isscalar(oi):\n            normalized_index.append(None)\n        else:\n            if len(index) &lt;= jj:\n                normalized_index.append(slice(None))\n            else:\n                normalized_index.append(index[jj])\n            jj += 1\n\n    return self.reindex(normalized_index)\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__getitem__(index)","title":"<code>index</code>","text":"(<code>ArrayIndex</code>)           \u2013            <p>The indices to slice the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns the length of the first dimension of the array.</p> Source code in <code>src/tracksdata/array/_base_array.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns the length of the first dimension of the array.\"\"\"\n    return self.shape[0]\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView._fill_array","title":"_fill_array","text":"<pre><code>_fill_array(time: int, volume_slicing: Sequence[slice], buffer: ndarray) -&gt; np.ndarray\n</code></pre> <p>Fill the buffer with data from the graph at a specific time.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The filled buffer.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def _fill_array(self, time: int, volume_slicing: Sequence[slice], buffer: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Fill the buffer with data from the graph at a specific time.\n\n    Parameters\n    ----------\n    time : int\n        The time point to retrieve data for.\n    volume_slicing : Sequence[slice]\n        The volume slicing information (currently not fully utilized).\n    buffer : np.ndarray\n        The buffer to fill with data.\n\n    Returns\n    -------\n    np.ndarray\n        The filled buffer.\n    \"\"\"\n    subgraph = self._spatial_filter[(slice(time, time), *volume_slicing)]\n    df = subgraph.node_attrs(\n        attr_keys=[self._attr_key, DEFAULT_ATTR_KEYS.MASK],\n    )\n\n    for mask, value in zip(df[DEFAULT_ATTR_KEYS.MASK], df[self._attr_key], strict=True):\n        mask: Mask\n        mask.paint_buffer(buffer, value, offset=self._offset)\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView._fill_array(time)","title":"<code>time</code>","text":"(<code>int</code>)           \u2013            <p>The time point to retrieve data for.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView._fill_array(volume_slicing)","title":"<code>volume_slicing</code>","text":"(<code>Sequence[slice]</code>)           \u2013            <p>The volume slicing information (currently not fully utilized).</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView._fill_array(buffer)","title":"<code>buffer</code>","text":"(<code>ndarray</code>)           \u2013            <p>The buffer to fill with data.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.reindex","title":"reindex","text":"<pre><code>reindex(slicing: Sequence[ArrayIndex]) -&gt; GraphArrayView\n</code></pre> <p>Reindex the GraphArrayView. Returns a shallow copy of the GraphArrayView with the new indices.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphArrayView</code>           \u2013            <p>A new GraphArrayView object with updated indices.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def reindex(\n    self,\n    slicing: Sequence[ArrayIndex],\n) -&gt; \"GraphArrayView\":\n    \"\"\"\n    Reindex the GraphArrayView.\n    Returns a shallow copy of the GraphArrayView with the new indices.\n\n    Parameters\n    ----------\n    slicing : tuple[ArrayIndex, ...]\n        The new indices to apply to the GraphArrayView.\n\n    Returns\n    -------\n    GraphArrayView\n        A new GraphArrayView object with updated indices.\n    \"\"\"\n    obj = copy(self)\n    obj._indices = tuple(chain_indices(i1, i2) for i1, i2 in zip(self._indices, slicing, strict=False))\n    return obj\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.reindex(slicing)","title":"<code>slicing</code>","text":"(<code>tuple[ArrayIndex, ...]</code>)           \u2013            <p>The new indices to apply to the GraphArrayView.</p>"},{"location":"reference/tracksdata/attrs/","title":"tracksdata.attrs","text":""},{"location":"reference/tracksdata/attrs/#tracksdata.attrs","title":"tracksdata.attrs","text":"<p>Module to compose attribute expressions for attribute filtering or value evaluation.</p> <p>Attributes are used to query content of nodes and edges through their names as columns in a data frame.</p> <p>Users will mostly interact with NodeAttr and EdgeAttr which are thin wrappers around Attr to distinguish between node and edge attributes in ambiguous cases.</p> <p>They can be used to filter elements in the graph as: <pre><code>graph.filter(NodeAttr(\"t\") == 1).subgraph()\n</code></pre></p> <p>Or to create complex expression when solving the tracking problem: <pre><code>NearestNeighborsSolver(-Attr(\"iou\") * (-Attr(\"distance\") / 30.0).exp())\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>AttrComparison</code>           \u2013            <p>Class to store a comparison between an Attr and a value.</p> </li> <li> <code>EdgeAttr</code>           \u2013            <p>Wrapper of Attr to represent an edge attribute.</p> </li> <li> <code>NodeAttr</code>           \u2013            <p>Wrapper of Attr to represent a node attribute.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>attr_comps_to_strs</code>             \u2013              <p>Convert a list of attribute comparisons to a list of strings.</p> </li> <li> <code>polars_reduce_attr_comps</code>             \u2013              <p>Reduce a list of attribute comparisons into a single polars expression.</p> </li> <li> <code>split_attr_comps</code>             \u2013              <p>Split a list of attribute comparisons into node and edge attribute comparisons.</p> </li> </ul>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr","title":"Attr","text":"<pre><code>Attr(value: ExprInput)\n</code></pre> <p>A class to compose an attribute expression for attribute filtering or value evaluation.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr--parameters","title":"Parameters","text":"<p>value : ExprInput     The value to compose the attribute expression from.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr--examples","title":"Examples","text":"<pre><code>Attr(\"t\") == 1  # filter for time point 1\nAttr(\"iou\").log()  # log the iou\nAttr(1.0)  # constant value\nAttr((1 - Attr(\"iou\")) * Attr(\"distance\"))  # complex expression\n</code></pre> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(other: ExprInput, op: Callable, reverse: bool = False) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.AttrComparison","title":"AttrComparison","text":"<pre><code>AttrComparison(attr: Attr, op: Callable, other: ExprInput)\n</code></pre> <p>Class to store a comparison between an Attr and a value. It's mainly used for filtering. Complex expression are transformed back to Attr objects which can be used to evaluate the expression on a DataFrame.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.AttrComparison--parameters","title":"Parameters","text":"<p>attr : Attr     The attribute to compare. op : Callable     The operator to use for the comparison. other : ExprInput     The value to compare the attribute to.</p> <p>Methods:</p> <ul> <li> <code>to_attr</code>             \u2013              <p>Transform the comparison back to an Attr object.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, attr: \"Attr\", op: Callable, other: ExprInput) -&gt; None:\n    if attr.has_inf():\n        raise ValueError(\"Comparison operators are not supported for expressions with infinity.\")\n\n    if isinstance(other, Attr):\n        raise ValueError(f\"Does not support comparison between expressions. Found {other} and {attr}.\")\n\n    columns = attr.expr_columns\n\n    if len(columns) == 0:\n        raise ValueError(\"Comparison operators are not supported for empty expressions.\")\n\n    elif len(columns) &gt; 1:\n        raise ValueError(f\"Comparison operators are not supported for multiple columns. Found {columns}.\")\n\n    self.attr = attr\n    self.column = columns[0]\n    self.op = op\n\n    if isinstance(other, np.ndarray):\n        # casting numpy scalars to python scalars\n        # numpy scalars are problematic for sqlalchemy\n        other = other.item()\n    self.other = other\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.AttrComparison.to_attr","title":"to_attr","text":"<pre><code>to_attr() -&gt; Attr\n</code></pre> <p>Transform the comparison back to an Attr object. This is useful for evaluating the expression on a DataFrame.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def to_attr(self) -&gt; \"Attr\":\n    \"\"\"\n    Transform the comparison back to an [Attr][tracksdata.attrs.Attr] object.\n    This is useful for evaluating the expression on a DataFrame.\n    \"\"\"\n    return Attr(self.op(pl.col(self.column), self.other))\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr","title":"EdgeAttr","text":"<pre><code>EdgeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <p>Wrapper of Attr to represent an edge attribute.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(other: ExprInput, op: Callable, reverse: bool = False) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr","title":"NodeAttr","text":"<pre><code>NodeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <p>Wrapper of Attr to represent a node attribute.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(other: ExprInput, op: Callable, reverse: bool = False) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs._setup_ops","title":"_setup_ops","text":"<pre><code>_setup_ops() -&gt; None\n</code></pre> <p>Setup the operator methods for the AttrExpr class.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _setup_ops() -&gt; None:\n    \"\"\"\n    Setup the operator methods for the AttrExpr class.\n    \"\"\"\n    bin_ops = {\n        \"add\": operator.add,\n        \"sub\": operator.sub,\n        \"mul\": operator.mul,\n        \"truediv\": operator.truediv,\n        \"floordiv\": operator.floordiv,\n        \"mod\": operator.mod,\n        \"pow\": operator.pow,\n        \"and\": operator.and_,\n        \"or\": operator.or_,\n        \"xor\": operator.xor,\n    }\n\n    comp_ops = {\n        \"eq\": operator.eq,\n        \"ne\": operator.ne,\n        \"lt\": operator.lt,\n        \"le\": operator.le,\n        \"gt\": operator.gt,\n        \"ge\": operator.ge,\n    }\n\n    for op_name, op_func in bin_ops.items():\n        _add_operator(Attr, f\"__{op_name}__\", op_func, reverse=False)\n        _add_operator(Attr, f\"__r{op_name}__\", op_func, reverse=True)\n        _add_operator(AttrComparison, f\"__{op_name}__\", op_func, reverse=False)\n        _add_operator(AttrComparison, f\"__r{op_name}__\", op_func, reverse=True)\n\n    for op_name, op_func in comp_ops.items():\n        _add_comparison_operator(f\"__{op_name}__\", op_func, reverse=False)\n        _add_comparison_operator(f\"__r{op_name}__\", op_func, reverse=True)\n\n        # attrr_comparision uses normal delegate_operator\n        _add_operator(AttrComparison, f\"__{op_name}__\", op_func, reverse=False)\n        _add_operator(AttrComparison, f\"__r{op_name}__\", op_func, reverse=True)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.attr_comps_to_strs","title":"attr_comps_to_strs","text":"<pre><code>attr_comps_to_strs(attr_comps: Sequence[AttrComparison]) -&gt; list[str]\n</code></pre> <p>Convert a list of attribute comparisons to a list of strings.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The attribute comparisons as strings.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def attr_comps_to_strs(attr_comps: Sequence[AttrComparison]) -&gt; list[str]:\n    \"\"\"\n    Convert a list of attribute comparisons to a list of strings.\n\n    Parameters\n    ----------\n    attr_comps : Sequence[AttrComparison]\n        The attribute comparisons to convert to strings.\n\n    Returns\n    -------\n    list[str]\n        The attribute comparisons as strings.\n    \"\"\"\n    return [str(attr_comp.column) for attr_comp in attr_comps]\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.attr_comps_to_strs(attr_comps)","title":"<code>attr_comps</code>","text":"(<code>Sequence[AttrComparison]</code>)           \u2013            <p>The attribute comparisons to convert to strings.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps","title":"polars_reduce_attr_comps","text":"<pre><code>polars_reduce_attr_comps(df: DataFrame, attr_comps: Sequence[AttrComparison], reduce_op: Callable[[Expr, Expr], Expr]) -&gt; pl.Expr\n</code></pre> <p>Reduce a list of attribute comparisons into a single polars expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Expr</code>           \u2013            <p>The reduced polars expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def polars_reduce_attr_comps(\n    df: pl.DataFrame,\n    attr_comps: Sequence[AttrComparison],\n    reduce_op: Callable[[Expr, Expr], Expr],\n) -&gt; pl.Expr:\n    \"\"\"\n    Reduce a list of attribute comparisons into a single polars expression.\n\n    Parameters\n    ----------\n    df : pl.DataFrame\n        The dataframe to reduce the attribute comparisons on.\n    attr_comps : Sequence[AttrComparison]\n        The attribute comparisons to reduce.\n    reduce_op : Callable[[Expr, Expr], Expr]\n        The operation to reduce the attribute comparisons with.\n\n    Returns\n    -------\n    pl.Expr\n        The reduced polars expression.\n    \"\"\"\n    if not attr_comps:\n        # Return True for all rows by using the first column as a reference\n        raise ValueError(\"No attribute comparisons provided.\")\n\n    return pl.reduce(reduce_op, [attr_comp.op(df[str(attr_comp.column)], attr_comp.other) for attr_comp in attr_comps])\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The dataframe to reduce the attribute comparisons on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps(attr_comps)","title":"<code>attr_comps</code>","text":"(<code>Sequence[AttrComparison]</code>)           \u2013            <p>The attribute comparisons to reduce.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps(reduce_op)","title":"<code>reduce_op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operation to reduce the attribute comparisons with.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.split_attr_comps","title":"split_attr_comps","text":"<pre><code>split_attr_comps(attr_comps: Sequence[AttrComparison]) -&gt; tuple[list[AttrComparison], list[AttrComparison]]\n</code></pre> <p>Split a list of attribute comparisons into node and edge attribute comparisons.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[AttrComparison], list[AttrComparison]]</code>           \u2013            <p>A tuple of lists of node and edge attribute comparisons.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def split_attr_comps(attr_comps: Sequence[AttrComparison]) -&gt; tuple[list[AttrComparison], list[AttrComparison]]:\n    \"\"\"\n    Split a list of attribute comparisons into node and edge attribute comparisons.\n\n    Parameters\n    ----------\n    attr_comps : Sequence[AttrComparison]\n        The attribute comparisons to split.\n\n    Returns\n    -------\n    tuple[list[AttrComparison], list[AttrComparison]]\n        A tuple of lists of node and edge attribute comparisons.\n    \"\"\"\n    node_attr_comps = []\n    edge_attr_comps = []\n\n    for attr_comp in attr_comps:\n        if isinstance(attr_comp.attr, NodeAttr):\n            node_attr_comps.append(attr_comp)\n        elif isinstance(attr_comp.attr, EdgeAttr):\n            edge_attr_comps.append(attr_comp)\n        else:\n            raise ValueError(f\"Expected comparisons of 'NodeAttr' or 'EdgeAttr' objects, got {type(attr_comp.attr)}\")\n\n    return node_attr_comps, edge_attr_comps\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.split_attr_comps(attr_comps)","title":"<code>attr_comps</code>","text":"(<code>Sequence[AttrComparison]</code>)           \u2013            <p>The attribute comparisons to split.</p>"},{"location":"reference/tracksdata/constants/","title":"tracksdata.constants","text":""},{"location":"reference/tracksdata/constants/#tracksdata.constants","title":"tracksdata.constants","text":"<p>Module to define default and often global values used through <code>tracksdata</code>.</p> <p>Classes:</p> <ul> <li> <code>DefaultAttrKeys</code>           \u2013            <p>This class defines the standard attribute names for nodes and edges in graphs to ensure</p> </li> </ul>"},{"location":"reference/tracksdata/constants/#tracksdata.constants.DefaultAttrKeys","title":"DefaultAttrKeys","text":"<p>This class defines the standard attribute names for nodes and edges in graphs to ensure consistency across different graph implementations and operators.</p> <p>Using these constants instead of hardcoded strings helps prevent typos.</p> <p>Attributes:</p> <ul> <li> <code>NODE_ID</code>               (<code>str</code>)           \u2013            <p>Default key for node identifiers.</p> </li> <li> <code>T</code>               (<code>str</code>)           \u2013            <p>Default key for time information.</p> </li> <li> <code>MASK</code>               (<code>str</code>)           \u2013            <p>Default key for node masks.</p> </li> <li> <code>BBOX</code>               (<code>str</code>)           \u2013            <p>Default key for node bounding boxes. For a 2D image, the bounding box is a tuple of (x_start, y_start, x_end, y_end). For a 3D image, the bounding box is a tuple of (x_start, y_start, z_start, x_end, y_end, z_end).</p> </li> <li> <code>SOLUTION</code>               (<code>str</code>)           \u2013            <p>Default key for solution information.</p> </li> <li> <code>TRACK_ID</code>               (<code>str</code>)           \u2013            <p>Default key for track identifiers.</p> </li> <li> <code>EDGE_ID</code>               (<code>str</code>)           \u2013            <p>Default key for edge identifiers.</p> </li> <li> <code>EDGE_WEIGHT</code>               (<code>str</code>)           \u2013            <p>Default key for edge weights.</p> </li> <li> <code>EDGE_SOURCE</code>               (<code>str</code>)           \u2013            <p>Default key for edge source node identifier.</p> </li> <li> <code>EDGE_TARGET</code>               (<code>str</code>)           \u2013            <p>Default key for edge target node identifier.</p> </li> <li> <code>MATCHED_NODE_ID</code>               (<code>str</code>)           \u2013            <p>Default key to identify respective node in another graph used for matching.</p> </li> <li> <code>MATCH_SCORE</code>               (<code>str</code>)           \u2013            <p>Default key between a node and its respective node in another graph used for matching.</p> </li> <li> <code>MATCHED_EDGE_MASK</code>               (<code>str</code>)           \u2013            <p>Default key for boolean mask indicating if edge exists in the matching graph.</p> </li> </ul> <p>Examples:</p> <pre><code>from tracksdata.constants import DEFAULT_ATTR_KEYS\n\nprint(DEFAULT_ATTR_KEYS.NODE_ID)  # Output: node_id\nprint(DEFAULT_ATTR_KEYS.EDGE_WEIGHT)  # Output: weight\n</code></pre>"},{"location":"reference/tracksdata/edges/","title":"tracksdata.edges","text":""},{"location":"reference/tracksdata/edges/#tracksdata.edges","title":"tracksdata.edges","text":"<p>Edge operators for creating connections between nodes of a graph.</p> <p>Classes:</p> <ul> <li> <code>DistanceEdges</code>           \u2013            <p>Operator that adds edges to a graph based on Euclidean distance between nodes.</p> </li> <li> <code>GenericFuncEdgeAttrs</code>           \u2013            <p>Add weights to the edges of the graph based on the output of a function.</p> </li> <li> <code>IoUEdgeAttr</code>           \u2013            <p>Add weights to the edges of the graph based on the IoU</p> </li> </ul>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges","title":"DistanceEdges","text":"<pre><code>DistanceEdges(distance_threshold: float, n_neighbors: int, delta_t: int = 1, output_key: str = DEFAULT_ATTR_KEYS.EDGE_DIST, attr_keys: Sequence[str] | None = None)\n</code></pre> <p>               Bases: <code>BaseEdgesOperator</code></p> <p>Operator that adds edges to a graph based on Euclidean distance between nodes.</p> <p>Creates edges between nodes in consecutive time points by finding the closest neighbors within a specified distance threshold using efficient KDTree-based spatial indexing. Creates directed edges from nodes in the range t-1 to t-delta_t to the nodes in the current time point t, representing potential transitions.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            <p>The distance threshold for adding edges.</p> </li> <li> <code>n_neighbors</code>               (<code>int</code>)           \u2013            <p>The maximum number of neighbors to consider for adding edges. This in respect from the current to the previous frame. That means, a node in frame t will have edges to the closest n_neighbors nodes in frame t-1.</p> </li> <li> <code>output_key</code>               (<code>str</code>)           \u2013            <p>The key used to store distance values in edges.</p> </li> <li> <code>attr_keys</code>               (<code>Sequence[str] | None</code>)           \u2013            <p>The attribute keys to use for the distance calculation. When None, \"z\", \"y\", \"x\" are used.</p> </li> <li> <code>show_progress</code>               (<code>bool</code>)           \u2013            <p>Whether to print progress of the edges addition.</p> </li> </ul> <p>Examples:</p> <p>Create a distance-based edge operator:</p> <pre><code>from tracksdata.edges import DistanceEdges\n\nedge_op = DistanceEdges(distance_threshold=50.0, n_neighbors=3, attr_keys=[\"x\", \"y\"])\n</code></pre> <p>Add edges to a graph:</p> <pre><code>edge_op.add_edges(graph)\n</code></pre> <p>Add edges for a specific time point:</p> <pre><code>edge_op.add_edges(graph, t=5)\n</code></pre> <p>Use custom output key:</p> <pre><code>edge_op = DistanceEdges(distance_threshold=30.0, n_neighbors=2, output_key=\"euclidean_distance\")\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_edges</code>             \u2013              <p>Initialize the edges from nodes of given <code>time</code> to nodes in neighboring</p> </li> </ul> Source code in <code>src/tracksdata/edges/_distance_edges.py</code> <pre><code>def __init__(\n    self,\n    distance_threshold: float,\n    n_neighbors: int,\n    delta_t: int = 1,\n    output_key: str = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    attr_keys: Sequence[str] | None = None,\n):\n    if delta_t &lt; 1:\n        raise ValueError(f\"'delta_t' must be at least 1, got {delta_t}\")\n\n    super().__init__(output_key=output_key)\n    self.distance_threshold = distance_threshold\n    self.n_neighbors = n_neighbors\n    self.delta_t = delta_t\n    self.attr_keys = attr_keys\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(distance_threshold)","title":"<code>distance_threshold</code>","text":"(<code>float</code>)           \u2013            <p>Maximum Euclidean distance for adding edges between nodes. Nodes farther apart than this threshold will not be connected.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(n_neighbors)","title":"<code>n_neighbors</code>","text":"(<code>int</code>)           \u2013            <p>Maximum number of neighbors to consider for each node when adding edges. For each node at time t, edges will be created to at most n_neighbors closest nodes at time t-1 to t-delta_t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(delta_t)","title":"<code>delta_t</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of time points to consider for adding edges. For each node at time t, edges will be created to the closest n_neighbors nodes at time t-1 to t-delta_t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>DEFAULT_ATTR_KEYS.EDGE_WEIGHT</code> )           \u2013            <p>The attribute key to store the distance values in the edges.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node attribute keys to use for distance calculation. If None, defaults to [\"z\", \"y\", \"x\"] if \"z\" exists, otherwise [\"y\", \"x\"].</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._add_edges_per_time","title":"_add_edges_per_time","text":"<pre><code>_add_edges_per_time(t: int, *, graph: BaseGraph) -&gt; list[dict[str, Any]]\n</code></pre> <p>Add distance-based edges between nodes at consecutive time points.</p> <p>Finds nodes at time t-1 and t, computes pairwise distances using KDTree, and creates edges between nearby nodes within the distance threshold. Uses bulk edge insertion for efficiency.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_distance_edges.py</code> <pre><code>def _add_edges_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Add distance-based edges between nodes at consecutive time points.\n\n    Finds nodes at time t-1 and t, computes pairwise distances using KDTree,\n    and creates edges between nearby nodes within the distance threshold.\n    Uses bulk edge insertion for efficiency.\n\n    Parameters\n    ----------\n    t : int\n        The current time point. Edges will be created from nodes at\n        time t-1 to nodes at time t.\n    graph : BaseGraph\n        The current time point. Edges will be created from nodes at\n        time t-1 to nodes at time t.\n    \"\"\"\n    if self.attr_keys is None:\n        if \"z\" in graph.node_attr_keys:\n            attr_keys = [\"z\", \"y\", \"x\"]\n        else:\n            attr_keys = [\"y\", \"x\"]\n    else:\n        attr_keys = self.attr_keys\n\n    if self.delta_t == 1:\n        # faster than the range filter\n        prev_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t - 1)\n    else:\n        prev_filter = graph.filter(\n            NodeAttr(DEFAULT_ATTR_KEYS.T) &gt;= t - self.delta_t,\n            NodeAttr(DEFAULT_ATTR_KEYS.T) &lt; t,\n        )\n\n    if prev_filter.is_empty():\n        LOG.warning(\n            \"No nodes found for time point in range (%d &lt;= t &lt; %d)\",\n            t - self.delta_t,\n            t,\n        )\n        return []\n\n    current_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n\n    if current_filter.is_empty():\n        LOG.warning(\n            \"No nodes found for time point %d\",\n            t,\n        )\n        return []\n\n    prev_attrs = prev_filter.node_attrs(attr_keys=attr_keys)\n    cur_attrs = current_filter.node_attrs(attr_keys=attr_keys)\n\n    prev_kdtree = KDTree(prev_attrs.to_numpy())\n\n    distances, prev_neigh_ids = prev_kdtree.query(\n        cur_attrs.to_numpy(),\n        k=self.n_neighbors,\n        distance_upper_bound=self.distance_threshold,\n    )\n    is_valid = ~np.isinf(distances)\n\n    prev_node_ids = np.asarray(prev_filter.node_ids())\n    # kdtree return from 0 to n-1\n    # converting back to arbitrary indexing\n    prev_neigh_ids[is_valid] = prev_node_ids[prev_neigh_ids[is_valid]]\n\n    edges_data = []\n    for cur_id, neigh_ids, neigh_dist, neigh_valid in zip(\n        current_filter.node_ids(), prev_neigh_ids, distances, is_valid, strict=True\n    ):\n        for neigh_id, dist in zip(neigh_ids[neigh_valid].tolist(), neigh_dist[neigh_valid].tolist(), strict=True):\n            edges_data.append(\n                {\n                    \"source_id\": neigh_id,\n                    \"target_id\": cur_id,\n                    self.output_key: dist,\n                }\n            )\n\n    if len(edges_data) == 0:\n        LOG.warning(\"No valid edges found for the pair of time point (%d, %d)\", t, t - 1)\n\n    return edges_data\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._add_edges_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The current time point. Edges will be created from nodes at time t-1 to nodes at time t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._add_edges_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The current time point. Edges will be created from nodes at time t-1 to nodes at time t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._init_edge_attrs","title":"_init_edge_attrs","text":"<pre><code>_init_edge_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the edge attributes for the graph.</p> Source code in <code>src/tracksdata/edges/_distance_edges.py</code> <pre><code>def _init_edge_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the edge attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, default_value=-99999.0)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges","title":"add_edges","text":"<pre><code>add_edges(graph: BaseGraph, *, t: int | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the edges from nodes of given <code>time</code> to nodes in neighboring times (<code>time</code> + <code>\\delta time</code>)</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_base_edges.py</code> <pre><code>def add_edges(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    r\"\"\"\n    Initialize the edges from nodes of given `time` to nodes in neighboring\n    times (`time` + `\\delta time`)\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to initialize the edges in.\n    t: int\n        The time of the nodes to initialize the edges from.\n    **kwargs: Any\n        Additional keyword arguments to pass to the `add_edges` method.\n    \"\"\"\n    self._init_edge_attrs(graph)\n\n    if t is None:\n        time_points = graph.time_points()\n    else:\n        time_points = [t]\n\n    for edge_attrs in multiprocessing_apply(\n        curry(self._add_edges_per_time, graph=graph, **kwargs),\n        time_points,\n        desc=\"Adding edges\",\n    ):\n        graph.bulk_add_edges(edge_attrs)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to initialize the edges in.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time of the nodes to initialize the edges from.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>add_edges</code> method.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs","title":"GenericFuncEdgeAttrs","text":"<pre><code>GenericFuncEdgeAttrs(func: Callable[[dict[str, Any] | Any, dict[str, Any] | Any], Any], attr_keys: Sequence[str] | str, output_key: str)\n</code></pre> <p>               Bases: <code>BaseEdgeAttrsOperator</code></p> <p>Add weights to the edges of the graph based on the output of a function.</p> <p>When provided multiple attribute keys, the function should take a dict with the keys as values for each node.</p> <p>When provided a single attribute key, the function should take the value for each node.</p> <p>For example, if the function is <code>func(source_attr, target_attr)</code>, and the attribute keys are <code>[\"a\", \"b\"]</code>, then the function should be <code>func({\"a\": 1, \"b\": 2}, {\"a\": 3, \"b\": 4})</code>.</p> <p>For a single attribute key \"a\", the function should take a single value for each node, as <code>func(1, 3)</code>.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_edge_attrs</code>             \u2013              <p>Add attributes to the edges of the graph for a given time or all time points.</p> </li> </ul> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[[dict[str, Any] | Any, dict[str, Any] | Any], Any],\n    attr_keys: Sequence[str] | str,\n    output_key: str,\n) -&gt; None:\n    super().__init__(output_key=output_key)\n    self.attr_keys = attr_keys\n    self.func = func\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs(func)","title":"<code>func</code>","text":"(<code>Callable[[dict[str, Any] | Any, dict[str, Any] | Any], Any]</code>)           \u2013            <p>The function to apply to the source and target attributes.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str</code>)           \u2013            <p>The keys of the attributes to pass to the function.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to store the output of the function.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._edge_attrs_per_time","title":"_edge_attrs_per_time","text":"<pre><code>_edge_attrs_per_time(t: int, *, graph: BaseGraph) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add weights to the edges of the graph based on the output of a function for a specific time point.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _edge_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add weights to the edges of the graph based on the output of a function\n    for a specific time point.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add weights for.\n    graph : BaseGraph\n        The graph to add weights to.\n    \"\"\"\n    graph_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t, include_targets=True)\n    edges_df = graph_filter.edge_attrs(attr_keys=[])\n\n    if len(edges_df) == 0:\n        LOG.warning(f\"No edges found for time point {t} to successors\")\n        return [], {}\n\n    att_keys_list = self.attr_keys if isinstance(self.attr_keys, list) else [self.attr_keys]\n    nodes_df = graph_filter.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, *att_keys_list])\n\n    source_df = edges_df.rename({DEFAULT_ATTR_KEYS.EDGE_SOURCE: DEFAULT_ATTR_KEYS.NODE_ID}).join(\n        nodes_df,\n        on=DEFAULT_ATTR_KEYS.NODE_ID,\n        how=\"left\",\n    )\n\n    target_df = edges_df.rename({DEFAULT_ATTR_KEYS.EDGE_TARGET: DEFAULT_ATTR_KEYS.NODE_ID}).join(\n        nodes_df,\n        on=DEFAULT_ATTR_KEYS.NODE_ID,\n        how=\"left\",\n    )\n\n    for df in [source_df, target_df]:\n        if len(df) != len(edges_df):\n            raise ValueError(\n                f\"Number of edges ({len(edges_df)}) and nodes ({len(df)}) do not match. Something went wrong.\"\n            )\n\n    weights = np.zeros(len(edges_df), dtype=np.float32)\n\n    if isinstance(self.attr_keys, str):\n        # faster than creating a dict\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys],\n                target_df[self.attr_keys],\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n    else:\n        # a bit more expensive to create a dict but more flexible\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys].iter_rows(named=True),\n                target_df[self.attr_keys].iter_rows(named=True),\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n\n    return edges_df[DEFAULT_ATTR_KEYS.EDGE_ID].to_list(), {self.output_key: weights}\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._edge_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add weights for.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._edge_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add weights to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._init_edge_attrs","title":"_init_edge_attrs","text":"<pre><code>_init_edge_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the edge attributes for the graph.</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _init_edge_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the edge attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, default_value=-99999.0)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs","title":"add_edge_attrs","text":"<pre><code>add_edge_attrs(graph: BaseGraph, *, t: int | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Add attributes to the edges of the graph for a given time or all time points.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_base_edge_attrs.py</code> <pre><code>def add_edge_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Add attributes to the edges of the graph for a given time or all time points.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    **kwargs : Any\n        Additional keyword arguments to pass to the `_add_edge_attrs_per_time` method.\n    \"\"\"\n    self._init_edge_attrs(graph)\n\n    if t is None:\n        time_points = graph.time_points()\n    else:\n        time_points = [t]\n\n    for edge_ids, edge_attrs in multiprocessing_apply(\n        func=curry(self._edge_attrs_per_time, graph=graph, **kwargs),\n        sequence=time_points,\n        desc=\"Adding edge attributes\",\n    ):\n        graph.update_edge_attrs(edge_ids=edge_ids, attrs=edge_attrs)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>_add_edge_attrs_per_time</code> method.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr","title":"IoUEdgeAttr","text":"<pre><code>IoUEdgeAttr(output_key: str, mask_key: str = DEFAULT_ATTR_KEYS.MASK)\n</code></pre> <p>               Bases: <code>GenericFuncEdgeAttrs</code></p> <p>Add weights to the edges of the graph based on the IoU of the masks of the nodes.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_edge_attrs</code>             \u2013              <p>Add attributes to the edges of the graph for a given time or all time points.</p> </li> </ul> Source code in <code>src/tracksdata/edges/_iou_edges.py</code> <pre><code>def __init__(\n    self,\n    output_key: str,\n    mask_key: str = DEFAULT_ATTR_KEYS.MASK,\n):\n    super().__init__(\n        func=Mask.iou,\n        attr_keys=mask_key,\n        output_key=output_key,\n    )\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the output of the IoU.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr(mask_key)","title":"<code>mask_key</code>","text":"(<code>str</code>, default:                   <code>MASK</code> )           \u2013            <p>The key to use for the masks of the nodes.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._edge_attrs_per_time","title":"_edge_attrs_per_time","text":"<pre><code>_edge_attrs_per_time(t: int, *, graph: BaseGraph) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add weights to the edges of the graph based on the output of a function for a specific time point.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _edge_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add weights to the edges of the graph based on the output of a function\n    for a specific time point.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add weights for.\n    graph : BaseGraph\n        The graph to add weights to.\n    \"\"\"\n    graph_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t, include_targets=True)\n    edges_df = graph_filter.edge_attrs(attr_keys=[])\n\n    if len(edges_df) == 0:\n        LOG.warning(f\"No edges found for time point {t} to successors\")\n        return [], {}\n\n    att_keys_list = self.attr_keys if isinstance(self.attr_keys, list) else [self.attr_keys]\n    nodes_df = graph_filter.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, *att_keys_list])\n\n    source_df = edges_df.rename({DEFAULT_ATTR_KEYS.EDGE_SOURCE: DEFAULT_ATTR_KEYS.NODE_ID}).join(\n        nodes_df,\n        on=DEFAULT_ATTR_KEYS.NODE_ID,\n        how=\"left\",\n    )\n\n    target_df = edges_df.rename({DEFAULT_ATTR_KEYS.EDGE_TARGET: DEFAULT_ATTR_KEYS.NODE_ID}).join(\n        nodes_df,\n        on=DEFAULT_ATTR_KEYS.NODE_ID,\n        how=\"left\",\n    )\n\n    for df in [source_df, target_df]:\n        if len(df) != len(edges_df):\n            raise ValueError(\n                f\"Number of edges ({len(edges_df)}) and nodes ({len(df)}) do not match. Something went wrong.\"\n            )\n\n    weights = np.zeros(len(edges_df), dtype=np.float32)\n\n    if isinstance(self.attr_keys, str):\n        # faster than creating a dict\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys],\n                target_df[self.attr_keys],\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n    else:\n        # a bit more expensive to create a dict but more flexible\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys].iter_rows(named=True),\n                target_df[self.attr_keys].iter_rows(named=True),\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n\n    return edges_df[DEFAULT_ATTR_KEYS.EDGE_ID].to_list(), {self.output_key: weights}\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._edge_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add weights for.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._edge_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add weights to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._init_edge_attrs","title":"_init_edge_attrs","text":"<pre><code>_init_edge_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the edge attributes for the graph.</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _init_edge_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the edge attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, default_value=-99999.0)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs","title":"add_edge_attrs","text":"<pre><code>add_edge_attrs(graph: BaseGraph, *, t: int | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Add attributes to the edges of the graph for a given time or all time points.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_base_edge_attrs.py</code> <pre><code>def add_edge_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Add attributes to the edges of the graph for a given time or all time points.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    **kwargs : Any\n        Additional keyword arguments to pass to the `_add_edge_attrs_per_time` method.\n    \"\"\"\n    self._init_edge_attrs(graph)\n\n    if t is None:\n        time_points = graph.time_points()\n    else:\n        time_points = [t]\n\n    for edge_ids, edge_attrs in multiprocessing_apply(\n        func=curry(self._edge_attrs_per_time, graph=graph, **kwargs),\n        sequence=time_points,\n        desc=\"Adding edge attributes\",\n    ):\n        graph.update_edge_attrs(edge_ids=edge_ids, attrs=edge_attrs)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>_add_edge_attrs_per_time</code> method.</p>"},{"location":"reference/tracksdata/functional/","title":"tracksdata.functional","text":""},{"location":"reference/tracksdata/functional/#tracksdata.functional","title":"tracksdata.functional","text":"<p>Functional utilities for graph operations.</p> <p>Functions:</p> <ul> <li> <code>rx_digraph_to_napari_dict</code>             \u2013              <p>Convert a tracklet graph to a napari-ready dictionary.</p> </li> <li> <code>to_napari_format</code>             \u2013              <p>Convert the subgraph of solution nodes to a napari-ready format.</p> </li> </ul>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.rx_digraph_to_napari_dict","title":"rx_digraph_to_napari_dict","text":"<pre><code>rx_digraph_to_napari_dict(tracklet_graph: PyDiGraph) -&gt; dict[int, list[int]]\n</code></pre> <p>Convert a tracklet graph to a napari-ready dictionary. The input is a (child -&gt; parent) graph (forward in time) and it is converted to a (parent -&gt; child) dictionary (backward in time).</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.rx_digraph_to_napari_dict--parameters","title":"Parameters","text":"<p>tracklet_graph : rx.PyDiGraph     The tracklet graph to convert.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.rx_digraph_to_napari_dict--returns","title":"Returns","text":"<p>dict[int, list[int]]     A dictionary of parent -&gt; child relationships.</p> Source code in <code>src/tracksdata/functional/_napari.py</code> <pre><code>def rx_digraph_to_napari_dict(\n    tracklet_graph: rx.PyDiGraph,\n) -&gt; dict[int, list[int]]:\n    \"\"\"\n    Convert a tracklet graph to a napari-ready dictionary.\n    The input is a (child -&gt; parent) graph (forward in time) and it is converted\n    to a (parent -&gt; child) dictionary (backward in time).\n\n    Parameters\n    ----------\n    tracklet_graph : rx.PyDiGraph\n        The tracklet graph to convert.\n\n    Returns\n    -------\n    dict[int, list[int]]\n        A dictionary of parent -&gt; child relationships.\n    \"\"\"\n    dict_graph = {}\n    for parent, child in tracklet_graph.edges():\n        dict_graph.setdefault(child, []).append(parent)\n    return dict_graph\n</code></pre>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format","title":"to_napari_format","text":"<pre><code>to_napari_format(graph: BaseGraph, shape: tuple[int, ...], solution_key: str | None, output_track_id_key: str, mask_key: None) -&gt; tuple[pl.DataFrame, dict[int, int]]\n</code></pre><pre><code>to_napari_format(graph: BaseGraph, shape: tuple[int, ...], solution_key: str | None, output_track_id_key: str, mask_key: str) -&gt; tuple[pl.DataFrame, dict[int, int], GraphArrayView]\n</code></pre> <pre><code>to_napari_format(graph: BaseGraph, shape: tuple[int, ...], solution_key: str | None = DEFAULT_ATTR_KEYS.SOLUTION, output_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, mask_key: str | None = None, chunk_shape: tuple[int] | None = None, buffer_cache_size: int | None = None) -&gt; tuple[pl.DataFrame, dict[int, int], GraphArrayView] | tuple[pl.DataFrame, dict[int, int]]\n</code></pre> <p>Convert the subgraph of solution nodes to a napari-ready format.</p> <p>This includes: - a tracks layer with the solution tracks - a graph with the parent-child relationships for the solution tracks - a labels layer with the solution nodes if <code>mask_key</code> is provided.</p> <p>IMPORTANT: This function will reset the track ids if they already exist.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>labels = ...\ngraph = ...\ntracks_data, dict_graph, array_view = to_napari_format(graph, labels.shape, mask_key=\"mask\")\n</code></pre> <p>Returns:</p> <ul> <li> <code>tuple[DataFrame, dict[int, int], GraphArrayView] | tuple[DataFrame, dict[int, int]]</code>           \u2013            <ul> <li>tracks_data: The tracks data as a polars DataFrame.</li> <li>dict_graph: A dictionary of parent -&gt; child relationships.</li> <li>array_view: The array view of the solution graph if <code>mask_key</code> is provided.</li> </ul> </li> </ul> Source code in <code>src/tracksdata/functional/_napari.py</code> <pre><code>def to_napari_format(\n    graph: BaseGraph,\n    shape: tuple[int, ...],\n    solution_key: str | None = DEFAULT_ATTR_KEYS.SOLUTION,\n    output_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    mask_key: str | None = None,\n    chunk_shape: tuple[int] | None = None,\n    buffer_cache_size: int | None = None,\n) -&gt; (\n    tuple[\n        pl.DataFrame,\n        dict[int, int],\n        \"GraphArrayView\",\n    ]\n    | tuple[\n        pl.DataFrame,\n        dict[int, int],\n    ]\n):\n    \"\"\"\n    Convert the subgraph of solution nodes to a napari-ready format.\n\n    This includes:\n    - a tracks layer with the solution tracks\n    - a graph with the parent-child relationships for the solution tracks\n    - a labels layer with the solution nodes if `mask_key` is provided.\n\n    IMPORTANT: This function will reset the track ids if they already exist.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to convert.\n    shape : tuple[int, ...]\n        The shape of the labels layer.\n    solution_key : str, optional\n        The key of the solution attribute. If None, the graph is not filtered by the solution attribute.\n    output_track_id_key : str, optional\n        The key of the output track id attribute.\n    mask_key : str | None, optional\n        The key of the mask attribute.\n    chunk_shape : tuple[int] | None, optional\n        The chunk shape for the labels layer. If None, the default chunk size is used.\n    buffer_cache_size : int, optional\n        The maximum number of buffers to keep in the cache for the labels layer.\n        If None, the default buffer cache size is used.\n\n    Examples\n    --------\n\n    ```python\n    labels = ...\n    graph = ...\n    tracks_data, dict_graph, array_view = to_napari_format(graph, labels.shape, mask_key=\"mask\")\n    ```\n\n    Returns\n    -------\n    tuple[pl.DataFrame, dict[int, int], GraphArrayView] | tuple[pl.DataFrame, dict[int, int]]\n        - tracks_data: The tracks data as a polars DataFrame.\n        - dict_graph: A dictionary of parent -&gt; child relationships.\n        - array_view: The array view of the solution graph if `mask_key` is provided.\n    \"\"\"\n    if solution_key is not None:\n        solution_graph = graph.filter(\n            NodeAttr(solution_key) == True,\n            EdgeAttr(solution_key) == True,\n        ).subgraph()\n\n    else:\n        solution_graph = graph\n\n    tracks_graph = solution_graph.assign_track_ids(output_track_id_key)\n    dict_graph = {child: parent for parent, child in tracks_graph.edge_list()}\n\n    spatial_cols = [\"z\", \"y\", \"x\"][-len(shape) + 1 :]\n\n    tracks_data = solution_graph.node_attrs(\n        attr_keys=[output_track_id_key, DEFAULT_ATTR_KEYS.T, *spatial_cols],\n    )\n\n    # sorting columns\n    tracks_data = tracks_data.select([output_track_id_key, DEFAULT_ATTR_KEYS.T, *spatial_cols])\n\n    if mask_key is not None:\n        from tracksdata.array._graph_array import GraphArrayView\n\n        array_view = GraphArrayView(\n            solution_graph,\n            shape,\n            attr_key=output_track_id_key,\n            chunk_shape=chunk_shape,\n            buffer_cache_size=buffer_cache_size,\n        )\n\n        return tracks_data, dict_graph, array_view\n\n    return tracks_data, dict_graph\n</code></pre>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to convert.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the labels layer.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(solution_key)","title":"<code>solution_key</code>","text":"(<code>str</code>, default:                   <code>SOLUTION</code> )           \u2013            <p>The key of the solution attribute. If None, the graph is not filtered by the solution attribute.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(output_track_id_key)","title":"<code>output_track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the output track id attribute.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(mask_key)","title":"<code>mask_key</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key of the mask attribute.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape for the labels layer. If None, the default chunk size is used.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(buffer_cache_size)","title":"<code>buffer_cache_size</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of buffers to keep in the cache for the labels layer. If None, the default buffer cache size is used.</p>"},{"location":"reference/tracksdata/graph/","title":"tracksdata.graph","text":""},{"location":"reference/tracksdata/graph/#tracksdata.graph","title":"tracksdata.graph","text":"<p>Graph backends for representing tracking data as directed graphs in memory or on disk.</p> <p>Modules:</p> <ul> <li> <code>filters</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>Base class for a graph backend.</p> </li> <li> <code>GraphView</code>           \u2013            <p>A filtered view of a graph that maintains bidirectional mapping to the root graph.</p> </li> <li> <code>IndexedRXGraph</code>           \u2013            <p>A graph with arbitrary node indices.</p> </li> <li> <code>RustWorkXGraph</code>           \u2013            <p>High-performance in-memory graph implementation using rustworkx.</p> </li> <li> <code>SQLGraph</code>           \u2013            <p>SQL-based graph implementation using SQLAlchemy ORM.</p> </li> </ul>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph","title":"BaseGraph","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for a graph backend.</p> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Helper method to interact with a single node.</p> </li> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edge_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph at time t.</p> </li> <li> <code>add_node_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>bbox_spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>copy</code>             \u2013              <p>Create a copy of this graph.</p> </li> <li> <code>edge_attrs</code>             \u2013              <p>Get the attributes of the edges as a polars DataFrame.</p> </li> <li> <code>edge_id</code>             \u2013              <p>Return the edge id between two nodes.</p> </li> <li> <code>edge_ids</code>             \u2013              <p>Get the IDs of all edges in the graph.</p> </li> <li> <code>filter</code>             \u2013              <p>Creates a filter object that can be used to create a subgraph or query ids and attributes.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_geff</code>             \u2013              <p>Create a graph from a geff data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_edge</code>             \u2013              <p>Check if the graph has an edge between two nodes.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_attrs</code>             \u2013              <p>Get the attributes of the nodes as a pandas DataFrame.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the IDs of all nodes in the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessors of a list of nodes.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a node from the graph.</p> </li> <li> <code>spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> </li> <li> <code>successors</code>             \u2013              <p>Get the sucessors of a list of nodes.</p> </li> <li> <code>summary</code>             \u2013              <p>Print a summary of the graph.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save the graph to a CTC ground truth directory.</p> </li> <li> <code>to_geff</code>             \u2013              <p>Write the graph to a geff data directory.</p> </li> <li> <code>tracklet_graph</code>             \u2013              <p>Create a compressed tracklet graph where each node is a tracklet</p> </li> <li> <code>update_edge_attrs</code>             \u2013              <p>Update the attributes of the edges.</p> </li> <li> <code>update_node_attrs</code>             \u2013              <p>Update the attributes of the nodes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the edges.</p> </li> <li> <code>node_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the nodes.</p> </li> <li> <code>num_edges</code>               (<code>int</code>)           \u2013            <p>The number of edges in the graph.</p> </li> <li> <code>num_nodes</code>               (<code>int</code>)           \u2013            <p>The number of nodes in the graph.</p> </li> <li> <code>supports_custom_indices</code>               (<code>bool</code>)           \u2013            <p>Whether the graph backend supports custom indices.</p> </li> </ul>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attr_keys","title":"edge_attr_keys  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>edge_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attr_keys","title":"node_attr_keys  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>node_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.num_edges","title":"num_edges  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.num_nodes","title":"num_nodes  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.supports_custom_indices","title":"supports_custom_indices  <code>property</code>","text":"<pre><code>supports_custom_indices: bool\n</code></pre> <p>Whether the graph backend supports custom indices.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(node_id: int) -&gt; NodeInterface\n</code></pre> <p>Helper method to interact with a single node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NodeInterface</code>           \u2013            <p>A node interface for the given node id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def __getitem__(self, node_id: int) -&gt; \"NodeInterface\":\n    \"\"\"\n    Helper method to interact with a single node.\n\n    Parameters\n    ----------\n    node_id : int\n        The id of the node to interact with.\n\n    Returns\n    -------\n    NodeInterface\n        A node interface for the given node id.\n    \"\"\"\n\n    if not isinstance(node_id, int):\n        raise ValueError(f\"graph index must be a integer, found '{node_id}' of type {type(node_id)}\")\n    return NodeInterface(self, node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.__getitem__(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The id of the node to interact with.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(attrs: dict[str, Any], reference_keys: list[str], mode: str) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys():\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge","title":"add_edge  <code>abstractmethod</code>","text":"<pre><code>add_edge(source_id: int, target_id: int, attrs: dict[str, Any], validate_keys: bool = True) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the added edge.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n    attrs : dict[str, Any]\n        Additional attributes for the edge.\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n\n    Returns\n    -------\n    int\n        The ID of the added edge.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Additional attributes for the edge.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge_attr_key","title":"add_edge_attr_key  <code>abstractmethod</code>","text":"<pre><code>add_edge_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing edges will have the default value for the new attribute key.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_edge_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing edges will have the default value for the new attribute key.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node","title":"add_node  <code>abstractmethod</code>","text":"<pre><code>add_node(attrs: dict[str, Any], validate_keys: bool = True, index: int | None = None) -&gt; int\n</code></pre> <p>Add a node to the graph at time t.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the added node.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph at time t.\n\n    Parameters\n    ----------\n    attrs : Any\n        The attributes of the node to be added, must have a \"t\" key.\n        The keys of the attributes will be used as the attributes of the node.\n        For example:\n        ```python\n        graph.add_node(dict(t=0, label=\"A\", intensity=100))\n        ```\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n    index : int | None\n        Optional node index/ID to use. If None, the backend will assign\n        an appropriate ID. Only supported by certain backends (e.g., SQLGraph).\n\n    Returns\n    -------\n    int\n        The ID of the added node.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>Any</code>)           \u2013            <p>The attributes of the node to be added, must have a \"t\" key. The keys of the attributes will be used as the attributes of the node. For example: <pre><code>graph.add_node(dict(t=0, label=\"A\", intensity=100))\n</code></pre></p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node(index)","title":"<code>index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional node index/ID to use. If None, the backend will assign an appropriate ID. Only supported by certain backends (e.g., SQLGraph).</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node_attr_key","title":"add_node_attr_key  <code>abstractmethod</code>","text":"<pre><code>add_node_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing nodes will have the default value for the new attribute key.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_node_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing nodes will have the default value for the new attribute key.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_overlap--parameters","title":"Parameters","text":"<p>source_id : int     The ID of the source node. target_id : int     The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_overlap--returns","title":"Returns","text":"<p>int     The ID of the added overlap.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    raise NotImplementedError(f\"{self.__class__.__name__} backend does not support overlaps.\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bbox_spatial_filter","title":"bbox_spatial_filter","text":"<pre><code>bbox_spatial_filter(frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T, bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX) -&gt; BBoxSpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> <p>This method creates a spatial index of graph nodes based on their bounding box coordinates, enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for bounding boxes:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n# Query nodes intersecting with region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter()\n# Uses default [\"t\", \"bbox\"]\n# Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>BBoxSpatialFilter:     The bounding box spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bbox_spatial_filter(\n    self,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n) -&gt; \"BBoxSpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.\n\n    This method creates a spatial index of graph nodes based on their bounding box coordinates,\n    enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    frame_attr_key : str | None\n        The attribute key for the frame (time) coordinate.\n        Default is `DEFAULT_ATTR_KEYS.T`.\n        If None it will only use the bounding box coordinates.\n    bbox_attr_key : str\n        The attribute key for the bounding box coordinates.\n        Defaults to `DEFAULT_ATTR_KEYS.BBOX`.\n        The bounding box coordinates should be in the format:\n        [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]\n        where each dimension has a min and max value.\n\n    Returns\n    -------\n    BBoxSpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for bounding boxes:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n    # Query nodes intersecting with region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter()\n    # Uses default [\"t\", \"bbox\"]\n    # Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [BBoxSpatialFilter][tracksdata.graph.filters.BBoxSpatialFilter]:\n        The bounding box spatial filter query class.\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import BBoxSpatialFilter\n\n    return BBoxSpatialFilter(self, frame_attr_key=frame_attr_key, bbox_attr_key=bbox_attr_key)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bbox_spatial_filter(frame_attr_key)","title":"<code>frame_attr_key</code>","text":"(<code>str | None</code>, default:                   <code>T</code> )           \u2013            <p>The attribute key for the frame (time) coordinate. Default is <code>DEFAULT_ATTR_KEYS.T</code>. If None it will only use the bounding box coordinates.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bbox_spatial_filter(bbox_attr_key)","title":"<code>bbox_attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key for the bounding box coordinates. Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>. The bounding box coordinates should be in the format: [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...] where each dimension has a min and max value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: Literal[False]) -&gt; None\n</code></pre><pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: Literal[True]) -&gt; list[int]\n</code></pre> <pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None\n</code></pre> <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int] | None</code>           \u2013            <p>The IDs of the added edges.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_edges(\n    self,\n    edges: list[dict[str, Any]],\n    return_ids: bool = False,\n) -&gt; list[int] | None:\n    \"\"\"\n    Faster method to add multiple edges to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        The data of the edges to be added.\n        The keys of the data will be used as the attributes of the edges.\n        Must have \"source_id\" and \"target_id\" keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Returns\n    -------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    # this method benefits the SQLGraph backend\n    if return_ids:\n        edge_ids = []\n        for edge in edges:\n            edge_ids.append(\n                self.add_edge(\n                    edge.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE),\n                    edge.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET),\n                    edge,\n                    validate_keys=False,\n                )\n            )\n        return edge_ids\n\n    # avoiding many ifs and appends\n    for edge in edges:\n        self.add_edge(\n            edge.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE),\n            edge.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET),\n            edge,\n            validate_keys=False,\n        )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the edges to be added. The keys of the data will be used as the attributes of the edges. Must have \"source_id\" and \"target_id\" keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(nodes: list[dict[str, Any]], indices: list[int] | None = None) -&gt; list[int]\n</code></pre> <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the added nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_nodes(\n    self,\n    nodes: list[dict[str, Any]],\n    indices: list[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Faster method to add multiple nodes to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        The data of the nodes to be added.\n        The keys of the data will be used as the attributes of the nodes.\n        Must have \"t\" key.\n    indices : list[int] | None\n        Optional list of node indices/IDs to use. If None, the backend will assign\n        appropriate IDs. Only supported by certain backends (e.g., SQLGraph).\n        Must be the same length as nodes if provided.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the added nodes.\n    \"\"\"\n    if len(nodes) == 0:\n        return []\n\n    self._validate_indices_length(nodes, indices)\n\n    # this method benefits the SQLGraph backend\n    if indices is None:\n        return [self.add_node(node, validate_keys=False) for node in nodes]\n    else:\n        return [\n            self.add_node(node, validate_keys=False, index=idx) for node, idx in zip(nodes, indices, strict=True)\n        ]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the nodes to be added. The keys of the data will be used as the attributes of the nodes. Must have \"t\" key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_nodes(indices)","title":"<code>indices</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of node indices/IDs to use. If None, the backend will assign appropriate IDs. Only supported by certain backends (e.g., SQLGraph). Must be the same length as nodes if provided.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.BaseGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    for source_id, target_id in overlaps:\n        self.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_attrs = self.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t).node_attrs(\n            attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MASK],\n        )\n        node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        masks = node_attrs[DEFAULT_ATTR_KEYS.MASK].to_list()\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; BaseGraph\n</code></pre> <p>Create a copy of this graph.</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A new graph instance with the same nodes, edges, and attributes as this graph.</p> </li> <li> <code>**kwargs</code> (              <code>Any</code> )          \u2013            <p>Additional arguments to pass to the graph constructor.</p> </li> </ul> <p>Examples:</p> <pre><code>copied_graph = graph.copy()\n</code></pre> See Also <p>from_other:     Create a graph from another graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def copy(self, **kwargs) -&gt; \"BaseGraph\":\n    \"\"\"\n    Create a copy of this graph.\n\n    Returns\n    -------\n    BaseGraph\n        A new graph instance with the same nodes, edges, and attributes as this graph.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    copied_graph = graph.copy()\n    ```\n\n    See Also\n    --------\n    [from_other][tracksdata.graph.BaseGraph.from_other]:\n        Create a graph from another graph.\n    \"\"\"\n    return self.__class__.from_other(self, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs","title":"edge_attrs  <code>abstractmethod</code>","text":"<pre><code>edge_attrs(*, attr_keys: Sequence[str] | None = None, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the edges as a polars DataFrame.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef edge_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the edges as a polars DataFrame.\n\n    Parameters\n    ----------\n    attr_keys : Sequence[str] | None\n        The attribute keys to get.\n        If None, all attributesare used.\n    unpack : bool\n        Whether to unpack array attributesinto multiple scalar attributes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributesinto multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_id","title":"edge_id  <code>abstractmethod</code>","text":"<pre><code>edge_id(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Return the edge id between two nodes.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef edge_id(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Return the edge id between two nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_ids","title":"edge_ids  <code>abstractmethod</code>","text":"<pre><code>edge_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all edges in the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef edge_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all edges in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter","title":"filter  <code>abstractmethod</code>","text":"<pre><code>filter(*attr_filters: AttrComparison, node_ids: Sequence[int] | None = None, include_targets: bool = False, include_sources: bool = False) -&gt; BaseFilter\n</code></pre> <p>Creates a filter object that can be used to create a subgraph or query ids and attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BaseFilter</code>           \u2013            <p>A filter object that can be used to create a subgraph or query attributes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef filter(\n    self,\n    *attr_filters: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n    include_targets: bool = False,\n    include_sources: bool = False,\n) -&gt; \"BaseFilter\":\n    \"\"\"\n    Creates a filter object that can be used to create a subgraph or query ids and attributes.\n\n    Parameters\n    ----------\n    *attr_filters : AttrComparison\n        The attributes to filter the nodes by.\n    node_ids : Sequence[int] | None\n        The IDs of the nodes to include in the filter.\n        If None, all nodes are used.\n    include_targets : bool\n        Whether to include edges out-going from the given node_ids even\n        if the target node is not in the given node_ids.\n    include_sources : bool\n        Whether to include edges incoming to the given node_ids even\n        if the source node is not in the given node_ids.\n\n    Returns\n    -------\n    BaseFilter\n        A filter object that can be used to create a subgraph or query attributes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter(*attr_filters)","title":"<code>*attr_filters</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter the nodes by.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to include in the filter. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter(include_targets)","title":"<code>include_targets</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include edges out-going from the given node_ids even if the target node is not in the given node_ids.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter(include_sources)","title":"<code>include_sources</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include edges incoming to the given node_ids even if the source node is not in the given node_ids.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(positions: ArrayLike, track_ids: ArrayLike | None = None, track_id_graph: dict[int, int] | None = None, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. track_ids : np.ndarray | None     Track ids of the nodes if available. track_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    track_ids: ArrayLike | None = None,\n    track_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    track_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    track_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import from_array\n\n    graph = cls(**kwargs)\n    from_array(\n        positions=np.asarray(positions),\n        graph=graph,\n        track_ids=track_ids,\n        track_id_graph=track_id_graph,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--see-also","title":"See Also","text":"<p>from_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--see-also_1","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [from_ctc][tracksdata.io._ctc.from_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n\n    See Also\n    --------\n    [to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import from_ctc\n\n    graph = cls(**kwargs)\n    from_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_geff","title":"from_geff  <code>classmethod</code>","text":"<pre><code>from_geff(geff_store: StoreLike, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a geff data directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>The loaded graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_geff(\n    cls: type[T],\n    geff_store: StoreLike,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to read the graph from.\n    **kwargs\n        Additional keyword arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    T\n        The loaded graph.\n    \"\"\"\n    from tracksdata.graph import IndexedRXGraph\n\n    # this performs a roundtrip with the rustworkx graph\n    rx_graph, _ = read_rx(geff_store)\n\n    if not isinstance(rx_graph, rx.PyDiGraph):\n        LOG.warning(\"The graph is not a directed graph, converting to directed graph.\")\n        rx_graph = rx_graph.to_directed()\n\n    indexed_graph = IndexedRXGraph(\n        rx_graph=rx_graph,\n        node_id_map=rx_graph.attrs[\"to_rx_id_map\"],\n        **kwargs,\n    )\n\n    if cls == IndexedRXGraph:\n        return indexed_graph\n\n    return cls.from_other(indexed_graph, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to read the graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_geff(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional keyword arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_other--parameters","title":"Parameters","text":"<p>other : BaseGraph     The other graph to create a new graph from. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_other--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the other graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            graph.add_node_attr_key(col, node_attrs[col].first())\n\n    if graph.supports_custom_indices:\n        new_node_ids = graph.bulk_add_nodes(\n            list(node_attrs.rows(named=True)),\n            indices=other_node_ids.to_list(),\n        )\n    else:\n        new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n        if other.supports_custom_indices:\n            LOG.warning(\n                f\"Other graph ({type(other).__name__}) supports custom indices, but this graph \"\n                f\"({type(graph).__name__}) does not, indexing automatically.\"\n            )\n\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.has_edge","title":"has_edge  <code>abstractmethod</code>","text":"<pre><code>has_edge(source_id: int, target_id: int) -&gt; bool\n</code></pre> <p>Check if the graph has an edge between two nodes.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef has_edge(self, source_id: int, target_id: int) -&gt; bool:\n    \"\"\"\n    Check if the graph has an edge between two nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.in_degree","title":"in_degree  <code>abstractmethod</code>","text":"<pre><code>in_degree(node_ids: int) -&gt; int\n</code></pre><pre><code>in_degree(node_ids: list[int] | None = None) -&gt; list[int]\n</code></pre> <pre><code>in_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match","title":"match","text":"<pre><code>match(other: BaseGraph, matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID, match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE, matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attrs","title":"node_attrs  <code>abstractmethod</code>","text":"<pre><code>node_attrs(*, attr_keys: Sequence[str] | str | None = None, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the nodes as a pandas DataFrame.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A polars DataFrame with the attributes of the nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef node_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the nodes as a pandas DataFrame.\n\n    Parameters\n    ----------\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n    unpack : bool\n        Whether to unpack array attributes into multiple scalar attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        A polars DataFrame with the attributes of the nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributes into multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_ids","title":"node_ids  <code>abstractmethod</code>","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all nodes in the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all nodes in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.out_degree","title":"out_degree  <code>abstractmethod</code>","text":"<pre><code>out_degree(node_ids: int) -&gt; int\n</code></pre><pre><code>out_degree(node_ids: list[int] | None = None) -&gt; list[int]\n</code></pre> <pre><code>out_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(node_ids: list[int] | None = None) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>. If <code>node_ids</code> is None, all nodes are used.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps between the nodes in <code>node_ids</code>.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    If `node_ids` is None, all nodes are used.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the overlaps for.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps between the nodes in `node_ids`.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the overlaps for. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.predecessors","title":"predecessors  <code>abstractmethod</code>","text":"<pre><code>predecessors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>The predecessors of the nodes indexed by node ID if a list of nodes is provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the predecessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        The predecessors of the nodes indexed by node ID if a list of nodes is provided.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.remove_node","title":"remove_node  <code>abstractmethod</code>","text":"<pre><code>remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the graph.</p> <p>This method removes the specified node and all edges connected to it (both incoming and outgoing edges).</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the node_id does not exist in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph.\n\n    This method removes the specified node and all edges connected to it\n    (both incoming and outgoing edges).\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to remove.\n\n    Raises\n    ------\n    ValueError\n        If the node_id does not exist in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.spatial_filter","title":"spatial_filter","text":"<pre><code>spatial_filter(attr_keys: list[str] | None = None) -&gt; SpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> <p>This method creates a spatial index of graph nodes based on their spatial coordinates, enabling efficient querying of nodes within spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for image coordinates:</p> <pre><code>spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n# Query nodes in region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n# Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>SpatialFilter:     The point spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def spatial_filter(self, attr_keys: list[str] | None = None) -&gt; \"SpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes.\n\n    This method creates a spatial index of graph nodes based on their spatial coordinates,\n    enabling efficient querying of nodes within spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    attr_keys : list[str] | None, optional\n        List of attribute keys to use as spatial coordinates. If None, defaults to\n        [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.\n        Common combinations include:\n        - 2D: [\"y\", \"x\"]\n        - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"]\n        - 4D: [\"t\", \"z\", \"y\", \"x\"]\n\n    Returns\n    -------\n    SpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for image coordinates:\n\n    ```python\n    spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n    # Query nodes in region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n    # Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [SpatialFilter][tracksdata.graph.filters.SpatialFilter]:\n        The point spatial filter query class.\n\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import SpatialFilter\n\n    return SpatialFilter(self, attr_keys=attr_keys)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.spatial_filter(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute keys to use as spatial coordinates. If None, defaults to [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph. Common combinations include: - 2D: [\"y\", \"x\"] - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"] - 4D: [\"t\", \"z\", \"y\", \"x\"]</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.successors","title":"successors  <code>abstractmethod</code>","text":"<pre><code>successors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the sucessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>The sucessors of the nodes indexed by node ID if a list of nodes is provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the sucessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the sucessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        The sucessors of the nodes indexed by node ID if a list of nodes is provided.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the sucessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.summary","title":"summary","text":"<pre><code>summary(attrs_stats: bool = False, print_summary: bool = True) -&gt; str\n</code></pre> <p>Print a summary of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string with the summary of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def summary(\n    self,\n    attrs_stats: bool = False,\n    print_summary: bool = True,\n) -&gt; str:\n    \"\"\"\n    Print a summary of the graph.\n\n    Parameters\n    ----------\n    attrs_stats : bool\n        If true it will print statistics about the attributes of the nodes and edges.\n    print_summary : bool\n        If true it will print the summary of the graph.\n\n    Returns\n    -------\n    str\n        A string with the summary of the graph.\n    \"\"\"\n    summary = \"\"\n\n    summary += \"Graph summary:\\n\"\n    summary += f\"Number of nodes: {self.num_nodes}\\n\"\n    summary += f\"Number of edges: {self.num_edges}\\n\"\n    summary += f\"Number of overlaps: {len(self.overlaps())}\\n\"\n\n    time_points = self.time_points()\n    summary += f\"Number of distinct time points: {len(time_points)}\\n\"\n    if len(time_points) &gt; 0:\n        summary += f\"Start time: {min(time_points)}\\n\"\n        summary += f\"End time: {max(time_points)}\\n\"\n    else:\n        summary += \"No time points found.\\n\"\n\n    if attrs_stats:\n        nodes_attrs = self.node_attrs()\n        edges_attrs = self.edge_attrs()\n        summary += \"\\nNodes attributes:\\n\"\n        summary += str(nodes_attrs.describe())\n        summary += \"\\nEdges attributes:\\n\"\n        summary += str(edges_attrs.describe())\n\n    if print_summary:\n        print(summary)\n\n    return summary\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.summary(attrs_stats)","title":"<code>attrs_stats</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true it will print statistics about the attributes of the nodes and edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.summary(print_summary)","title":"<code>print_summary</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true it will print the summary of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.time_points","title":"time_points  <code>abstractmethod</code>","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(shape: tuple[int, ...], output_dir: str | Path, track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, overwrite: bool = False) -&gt; None\n</code></pre> <p>Save the graph to a CTC ground truth directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_ctc--parameters","title":"Parameters","text":"<p>shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X) output_dir : str | Path     The directory to save the graph to. track_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_ctc--examples","title":"Examples","text":"<pre><code># ...\nsolution_graph = solver.solve(graph)\nsolution_graph.assign_track_ids()\nsolution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_ctc--see-also","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_ctc(\n    self,\n    shape: tuple[int, ...],\n    output_dir: str | Path,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save the graph to a CTC ground truth directory.\n\n    Parameters\n    ----------\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X)\n    output_dir : str | Path\n        The directory to save the graph to.\n    track_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    Examples\n    --------\n    ```python\n    # ...\n    solution_graph = solver.solve(graph)\n    solution_graph.assign_track_ids()\n    solution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n    ```\n\n    See Also\n    --------\n    [to_ctc][tracksdata.io.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import to_ctc\n\n    to_ctc(\n        graph=self,\n        shape=shape,\n        output_dir=output_dir,\n        track_id_key=track_id_key,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_geff","title":"to_geff","text":"<pre><code>to_geff(geff_store: StoreLike, geff_metadata: GeffMetadata | None = None, zarr_format: Literal[2, 3] = 3) -&gt; None\n</code></pre> <p>Write the graph to a geff data directory.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_geff(\n    self,\n    geff_store: StoreLike,\n    geff_metadata: GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None:\n    \"\"\"\n    Write the graph to a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to write the graph to.\n    geff_metadata : GeffMetadata | None\n        The geff metadata to write to the graph.\n        It automatically generates the metadata with:\n        - axes: time (t) and spatial axes ((z), y, x)\n        - tracklet node property: track_id\n    zarr_format : Literal[2, 3]\n        The zarr format to write the graph to.\n        Defaults to 3.\n    \"\"\"\n\n    node_attrs = self.node_attrs()\n\n    if DEFAULT_ATTR_KEYS.MASK in node_attrs.columns:\n        node_attrs = column_to_bytes(node_attrs, DEFAULT_ATTR_KEYS.MASK)\n\n    if geff_metadata is None:\n        axes = [Axis(name=DEFAULT_ATTR_KEYS.T, type=\"time\")]\n        axes.extend([Axis(name=c, type=\"space\") for c in (\"z\", \"y\", \"x\") if c in node_attrs.columns])\n\n        if DEFAULT_ATTR_KEYS.TRACK_ID in node_attrs.columns:\n            track_node_props = {\n                \"tracklet\": DEFAULT_ATTR_KEYS.TRACK_ID,\n            }\n        else:\n            track_node_props = None\n\n        geff_metadata = GeffMetadata(\n            directed=True,\n            axes=axes,\n            track_node_props=track_node_props,\n        )\n\n    edge_attrs = self.edge_attrs().drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    node_dict = {\n        k: (column_to_numpy(v), None) for k, v in node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID).to_dict().items()\n    }\n\n    edge_ids = edge_attrs.select(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET).to_numpy()\n\n    edge_dict = {\n        k: (column_to_numpy(v), None)\n        for k, v in edge_attrs.drop(\n            DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n            DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        )\n        .to_dict()\n        .items()\n    }\n\n    write_arrays(\n        geff_store,\n        metadata=geff_metadata,\n        node_ids=node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy(),\n        node_props=node_dict,\n        edge_ids=edge_ids,\n        edge_props=edge_dict,\n        zarr_format=zarr_format,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to write the graph to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_geff(geff_metadata)","title":"<code>geff_metadata</code>","text":"(<code>GeffMetadata | None</code>, default:                   <code>None</code> )           \u2013            <p>The geff metadata to write to the graph. It automatically generates the metadata with: - axes: time (t) and spatial axes ((z), y, x) - tracklet node property: track_id</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_geff(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The zarr format to write the graph to. Defaults to 3.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.tracklet_graph","title":"tracklet_graph","text":"<pre><code>tracklet_graph(track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, ignore_track_id: int | None = None) -&gt; rx.PyDiGraph\n</code></pre> <p>Create a compressed tracklet graph where each node is a tracklet and each edge is a transition between tracklets.</p> <p>IMPORTANT: rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values. And edge values are the tuple of source and target tracklet ids.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed tracklet graph.</p> </li> </ul> See Also <p>rx_digraph_to_napari_dict:     Convert a tracklet graph to a napari-ready dictionary.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_graph(\n    self,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    ignore_track_id: int | None = None,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Create a compressed tracklet graph where each node is a tracklet\n    and each edge is a transition between tracklets.\n\n    IMPORTANT:\n    rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values.\n    And edge values are the tuple of source and target tracklet ids.\n\n    Parameters\n    ----------\n    track_id_key : str\n        The key of the track id attribute.\n    ignore_track_id : int | None\n        The track id to ignore. If None, all track ids are used.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed tracklet graph.\n\n    See Also\n    --------\n    [rx_digraph_to_napari_dict][tracksdata.functional.rx_digraph_to_napari_dict]:\n        Convert a tracklet graph to a napari-ready dictionary.\n    \"\"\"\n\n    if track_id_key not in self.node_attr_keys:\n        raise ValueError(f\"Track id key '{track_id_key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n    nodes_df = self.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, track_id_key])\n    edges_df = self.edge_attrs(attr_keys=[])\n\n    if ignore_track_id is not None:\n        nodes_df = nodes_df.filter(pl.col(track_id_key) != ignore_track_id)\n\n    nodes_df = nodes_df.unique(subset=[track_id_key])\n\n    graph = rx.PyDiGraph()\n    nodes_df = nodes_df.with_columns(\n        pl.Series(\n            np.asarray(graph.add_nodes_from(nodes_df[track_id_key].to_list()), dtype=int),\n        ).alias(\"rx_id\"),\n    )\n\n    edges_df = (\n        edges_df.join(\n            nodes_df.rename({track_id_key: \"source_track_id\", \"rx_id\": \"source_rx_id\"}),\n            left_on=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n            right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n            how=\"right\",\n        )\n        .join(\n            nodes_df.rename({track_id_key: \"target_track_id\", \"rx_id\": \"target_rx_id\"}),\n            left_on=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n            right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n            how=\"right\",\n        )\n        .filter(~pl.col(DEFAULT_ATTR_KEYS.EDGE_ID).is_null())\n    )\n\n    graph.add_edges_from(\n        zip(\n            edges_df[\"source_rx_id\"].to_list(),\n            edges_df[\"target_rx_id\"].to_list(),\n            zip(edges_df[\"source_track_id\"].to_list(), edges_df[\"target_track_id\"].to_list(), strict=False),\n            strict=True,\n        )\n    )\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.tracklet_graph(track_id_key)","title":"<code>track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.tracklet_graph(ignore_track_id)","title":"<code>ignore_track_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The track id to ignore. If None, all track ids are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_edge_attrs","title":"update_edge_attrs  <code>abstractmethod</code>","text":"<pre><code>update_edge_attrs(*, attrs: dict[str, Any], edge_ids: Sequence[int] | None = None) -&gt; None\n</code></pre> <p>Update the attributes of the edges.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef update_edge_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the edges.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        Attributes to be updated.\n    edge_ids : Sequence[int] | None\n        The IDs of the edges to update or None to update all edges.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_edge_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Attributes to be updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_edge_attrs(edge_ids)","title":"<code>edge_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the edges to update or None to update all edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_node_attrs","title":"update_node_attrs  <code>abstractmethod</code>","text":"<pre><code>update_node_attrs(*, attrs: dict[str, Any], node_ids: Sequence[int] | None = None) -&gt; None\n</code></pre> <p>Update the attributes of the nodes.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef update_node_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the nodes.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to update.\n    node_ids : Sequence[int] | None\n        The IDs of the nodes to update or None to update all nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_node_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to update.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_node_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to update or None to update all nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView","title":"GraphView","text":"<pre><code>GraphView(rx_graph: PyDiGraph, node_map_to_root: dict[int, int], root: BaseGraph, sync: bool = True)\n</code></pre> <p>               Bases: <code>RustWorkXGraph</code>, <code>MappedGraphMixin</code></p> <p>A filtered view of a graph that maintains bidirectional mapping to the root graph.</p> <p>GraphView provides a lightweight way to work with subsets of a larger graph while maintaining the ability to synchronize changes back to the original graph. It acts as a view layer that maps between local node/edge IDs and the root graph's IDs, enabling efficient subgraph operations with minimal data duplication.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>_local_to_external</code>               (<code>bidict[int, int]</code>)           \u2013            <p>Mapping from local node IDs to external node IDs (via MappedGraphMixin).</p> </li> <li> <code>_external_to_local</code>               (<code>bidict[int, int]</code>)           \u2013            <p>Mapping from external node IDs to local node IDs (via MappedGraphMixin).</p> </li> <li> <code>_edge_map_to_root</code>               (<code>bidict[int, int]</code>)           \u2013            <p>Mapping from view edge IDs to root graph edge IDs.</p> </li> <li> <code>_edge_map_from_root</code>               (<code>bidict[int, int]</code>)           \u2013            <p>Mapping from root graph edge IDs to view edge IDs.</p> </li> </ul> See Also <p>RustWorkXGraph:     The base graph implementation that this view extends.</p> <p>SQLGraph:     Database-backed graph implementation for larger datasets.</p> <p>Examples:</p> <p>Create a subgraph view filtered by time:</p> <pre><code>from tracksdata.attrs import NodeAttr\n\nview = graph.filter(NodeAttr(\"t\") == 5).subgraph()\n</code></pre> <p>Access nodes in the view:</p> <pre><code>node_ids = view.node_ids()\nnode_attrs = view.node_attrs(node_ids=node_ids)\n</code></pre> <p>The view automatically maps between local and root IDs when needed.</p> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Helper method to interact with a single node.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>assign_track_ids</code>             \u2013              <p>Compute and assign track ids to nodes.</p> </li> <li> <code>bbox_spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>contract_nodes</code>             \u2013              <p>Contract the graph to only include the given <code>permanent_node_ids</code>.</p> </li> <li> <code>copy</code>             \u2013              <p>Not supported for <code>GraphView</code>.</p> </li> <li> <code>detach</code>             \u2013              <p>Detach the graph view from the root graph, returning a new graph with the same nodes and edges</p> </li> <li> <code>edge_id</code>             \u2013              <p>Return the edge id between two nodes.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_geff</code>             \u2013              <p>Create a graph from a geff data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_edge</code>             \u2013              <p>Check if the graph has an edge between two nodes.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a node from the graph.</p> </li> <li> <code>spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> </li> <li> <code>summary</code>             \u2013              <p>Print a summary of the graph.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save the graph to a CTC ground truth directory.</p> </li> <li> <code>to_geff</code>             \u2013              <p>Write the graph to a geff data directory.</p> </li> <li> <code>tracklet_graph</code>             \u2013              <p>Create a compressed tracklet graph where each node is a tracklet</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def __init__(\n    self,\n    rx_graph: rx.PyDiGraph,\n    node_map_to_root: dict[int, int],\n    root: BaseGraph,\n    sync: bool = True,\n) -&gt; None:\n    # Initialize RustWorkXGraph\n    RustWorkXGraph.__init__(self, rx_graph=None)  # rx_graph is not used to avoid initialization\n    self._graph = rx_graph\n\n    # Initialize MappedGraphMixin\n    MappedGraphMixin.__init__(self, node_map_to_root)\n\n    # Setting up the time_to_nodes mapping (this was removed accidentally)\n    for idx in rx_graph.node_indices():\n        t = self.rx_graph[idx][DEFAULT_ATTR_KEYS.T]\n        self._time_to_nodes.setdefault(t, []).append(idx)\n\n    # Set up edge mapping (nodes handled by mixin)\n    self._edge_map_to_root: bidict.bidict[int, int] = bidict.bidict(\n        (idx, data[DEFAULT_ATTR_KEYS.EDGE_ID]) for idx, (_, _, data) in self.rx_graph.edge_index_map().items()\n    )\n    self._edge_map_from_root = self._edge_map_to_root.inverse\n\n    self._root = root\n    self._is_root_rx_graph = isinstance(root, RustWorkXGraph)\n    self._sync = sync\n    self._out_of_sync = False\n\n    # making sure these are not used\n    # they should be accessed through the root graph\n    self._node_attr_keys = None\n    self._edge_attr_keys = None\n\n    # use parent graph overlaps\n    self._overlaps = None\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(rx_graph)","title":"<code>rx_graph</code>","text":"(<code>PyDiGraph</code>)           \u2013            <p>The rustworkx graph object representing the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(node_map_to_root)","title":"<code>node_map_to_root</code>","text":"(<code>dict[int, int]</code>)           \u2013            <p>Mapping from local node IDs to root graph node IDs.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(root)","title":"<code>root</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>Reference to the root graph that this view is derived from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(sync)","title":"<code>sync</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to automatically synchronize changes in the view. By default only the root graph is updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.num_edges","title":"num_edges  <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(node_id: int) -&gt; NodeInterface\n</code></pre> <p>Helper method to interact with a single node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NodeInterface</code>           \u2013            <p>A node interface for the given node id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def __getitem__(self, node_id: int) -&gt; \"NodeInterface\":\n    \"\"\"\n    Helper method to interact with a single node.\n\n    Parameters\n    ----------\n    node_id : int\n        The id of the node to interact with.\n\n    Returns\n    -------\n    NodeInterface\n        A node interface for the given node id.\n    \"\"\"\n\n    if not isinstance(node_id, int):\n        raise ValueError(f\"graph index must be a integer, found '{node_id}' of type {type(node_id)}\")\n    return NodeInterface(self, node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.__getitem__(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The id of the node to interact with.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._add_id_mapping","title":"_add_id_mapping","text":"<pre><code>_add_id_mapping(local_id: int, external_id: int) -&gt; None\n</code></pre> <p>Add a new ID mapping.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _add_id_mapping(self, local_id: int, external_id: int) -&gt; None:\n    \"\"\"\n    Add a new ID mapping.\n\n    Parameters\n    ----------\n    local_id : int\n        Local node ID\n    external_id : int\n        External node ID\n    \"\"\"\n    try:\n        self._local_to_external.put(local_id, external_id)\n    except bidict.ValueDuplicationError as e:\n        # Convert ValueDuplicationError to KeyDuplicationError since from user perspective\n        # the external_id (their \"key\"/index) is what's being duplicated\n        raise bidict.KeyDuplicationError(e.args[0]) from e\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._add_id_mapping(local_id)","title":"<code>local_id</code>","text":"(<code>int</code>)           \u2013            <p>Local node ID</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._add_id_mapping(external_id)","title":"<code>external_id</code>","text":"(<code>int</code>)           \u2013            <p>External node ID</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._add_id_mappings","title":"_add_id_mappings","text":"<pre><code>_add_id_mappings(mappings: Sequence[tuple[int, int]]) -&gt; None\n</code></pre> <p>Add multiple ID mappings at once.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _add_id_mappings(self, mappings: Sequence[tuple[int, int]]) -&gt; None:\n    \"\"\"\n    Add multiple ID mappings at once.\n\n    Parameters\n    ----------\n    mappings : Sequence[tuple[int, int]]\n        Sequence of (local_id, external_id) pairs\n    \"\"\"\n    self._local_to_external.putall(mappings)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._add_id_mappings(mappings)","title":"<code>mappings</code>","text":"(<code>Sequence[tuple[int, int]]</code>)           \u2013            <p>Sequence of (local_id, external_id) pairs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._filter_nodes_by_attrs","title":"_filter_nodes_by_attrs","text":"<pre><code>_filter_nodes_by_attrs(*attrs: AttrComparison, node_ids: Sequence[int] | None = None) -&gt; list[int]\n</code></pre> <p>Filter nodes by attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the filtered nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _filter_nodes_by_attrs(\n    self,\n    *attrs: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Filter nodes by attributes.\n\n    Parameters\n    ----------\n    *attrs : AttrComparison\n        The attributes to filter by, for example:\n    node_ids : list[int] | None\n        The IDs of the nodes to include in the filter.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the filtered nodes.\n    \"\"\"\n    rx_graph = self.rx_graph\n    node_map = None\n    # entire graph\n    attrs, time = _pop_time_eq(attrs)\n    selected_nodes = None\n\n    if time is not None:\n        selected_nodes = self._time_to_nodes.get(time, [])\n\n        if node_ids is not None:\n            selected_nodes = np.intersect1d(selected_nodes, node_ids).tolist()\n\n        if len(attrs) == 0:\n            return selected_nodes\n\n    elif node_ids is not None:\n        selected_nodes = node_ids\n\n    if selected_nodes is not None:\n        # subgraph of selected nodes\n        rx_graph, node_map = rx_graph.subgraph_with_nodemap(selected_nodes)\n\n    _filter_func = _create_filter_func(attrs)\n\n    if node_map is None:\n        return list(rx_graph.filter_nodes(_filter_func))\n    else:\n        return [node_map[n] for n in rx_graph.filter_nodes(_filter_func)]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._filter_nodes_by_attrs(*attrs)","title":"<code>*attrs</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter by, for example:</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._filter_nodes_by_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to include in the filter. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._get_external_ids","title":"_get_external_ids","text":"<pre><code>_get_external_ids() -&gt; list[int]\n</code></pre> <p>Get all external IDs in the mapping.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all external node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _get_external_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get all external IDs in the mapping.\n\n    Returns\n    -------\n    list[int]\n        List of all external node IDs\n    \"\"\"\n    return list(self._local_to_external.values())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._get_local_ids","title":"_get_local_ids","text":"<pre><code>_get_local_ids() -&gt; list[int]\n</code></pre> <p>Get all local IDs in the mapping.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all local node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _get_local_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get all local IDs in the mapping.\n\n    Returns\n    -------\n    list[int]\n        List of all local node IDs\n    \"\"\"\n    return list(self._local_to_external.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_df_to_external","title":"_map_df_to_external","text":"<pre><code>_map_df_to_external(df: DataFrame, columns: Sequence[str]) -&gt; pl.DataFrame\n</code></pre> <p>Transform node IDs in DataFrame columns from local to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>DataFrame with transformed node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_df_to_external(self, df: pl.DataFrame, columns: Sequence[str]) -&gt; pl.DataFrame:\n    \"\"\"\n    Transform node IDs in DataFrame columns from local to external coordinates.\n\n    Parameters\n    ----------\n    df : pl.DataFrame\n        DataFrame containing node IDs to transform\n    columns : Sequence[str]\n        Column names containing node IDs to transform\n\n    Returns\n    -------\n    pl.DataFrame\n        DataFrame with transformed node IDs\n    \"\"\"\n    for col in columns:\n        if col in df.columns:\n            df = df.with_columns(\n                pl.col(col).map_elements(self._local_to_external.__getitem__, return_dtype=pl.Int64).alias(col)\n            )\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_df_to_external(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>DataFrame containing node IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_df_to_external(columns)","title":"<code>columns</code>","text":"(<code>Sequence[str]</code>)           \u2013            <p>Column names containing node IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_to_external","title":"_map_to_external","text":"<pre><code>_map_to_external(local_ids: None) -&gt; None\n</code></pre><pre><code>_map_to_external(local_ids: int) -&gt; int\n</code></pre><pre><code>_map_to_external(local_ids: Sequence[int]) -&gt; list[int]\n</code></pre> <pre><code>_map_to_external(local_ids: int | Sequence[int] | None) -&gt; int | list[int] | None\n</code></pre> <p>Transform local IDs to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int | list[int] | None</code>           \u2013            <p>External IDs corresponding to the local IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_to_external(self, local_ids: int | Sequence[int] | None) -&gt; int | list[int] | None:\n    \"\"\"\n    Transform local IDs to external coordinates.\n\n    Parameters\n    ----------\n    local_ids : int | Sequence[int] | None\n        Local IDs to transform\n\n    Returns\n    -------\n    int | list[int] | None\n        External IDs corresponding to the local IDs\n    \"\"\"\n    if local_ids is None:\n        return None\n    if isinstance(local_ids, int):\n        return self._local_to_external[local_ids]\n    return [self._local_to_external[lid] for lid in local_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_to_external(local_ids)","title":"<code>local_ids</code>","text":"(<code>int | Sequence[int] | None</code>)           \u2013            <p>Local IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_to_local","title":"_map_to_local","text":"<pre><code>_map_to_local(external_ids: None) -&gt; None\n</code></pre><pre><code>_map_to_local(external_ids: int) -&gt; int\n</code></pre><pre><code>_map_to_local(external_ids: Sequence[int]) -&gt; list[int]\n</code></pre> <pre><code>_map_to_local(external_ids: int | Sequence[int] | None) -&gt; int | list[int] | None\n</code></pre> <p>Transform external IDs to local coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int | list[int] | None</code>           \u2013            <p>Local IDs corresponding to the external IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_to_local(self, external_ids: int | Sequence[int] | None) -&gt; int | list[int] | None:\n    \"\"\"\n    Transform external IDs to local coordinates.\n\n    Parameters\n    ----------\n    external_ids : int | Sequence[int] | None\n        External IDs to transform\n\n    Returns\n    -------\n    int | list[int] | None\n        Local IDs corresponding to the external IDs\n    \"\"\"\n    if external_ids is None:\n        return None\n    if isinstance(external_ids, int):\n        return self._external_to_local[external_ids]\n    return [self._external_to_local[eid] for eid in external_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_to_local(external_ids)","title":"<code>external_ids</code>","text":"(<code>int | Sequence[int] | None</code>)           \u2013            <p>External IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._remove_id_mapping","title":"_remove_id_mapping","text":"<pre><code>_remove_id_mapping(*, local_id: int | None = None, external_id: int | None = None) -&gt; None\n</code></pre> <p>Remove an ID mapping.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _remove_id_mapping(\n    self,\n    *,\n    local_id: int | None = None,\n    external_id: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Remove an ID mapping.\n\n    Parameters\n    ----------\n    local_id : int\n        Local node ID to remove from mapping\n    external_id : int\n        External node ID to remove from mapping\n    \"\"\"\n    if local_id is not None:\n        del self._local_to_external[local_id]\n    elif external_id is not None:\n        del self._external_to_local[external_id]\n    else:\n        raise ValueError(\"Either local_id or external_id must be provided\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._remove_id_mapping(local_id)","title":"<code>local_id</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Local node ID to remove from mapping</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._remove_id_mapping(external_id)","title":"<code>external_id</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>External node ID to remove from mapping</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._replace_parent_graph_with_root","title":"_replace_parent_graph_with_root","text":"<pre><code>_replace_parent_graph_with_root() -&gt; None\n</code></pre> <p>Replace the parent graph with it's own parent graph (the root graph) This is internally called so every view of a graph maps to a single root, skipping intermediate views.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def _replace_parent_graph_with_root(self) -&gt; None:\n    \"\"\"\n    Replace the parent graph with it's own parent graph (the root graph)\n    This is internally called so every view of a graph maps to a single root, skipping intermediate views.\n    \"\"\"\n    parent = self._root\n\n    if not isinstance(parent, GraphView):\n        raise ValueError(\n            f\"Parent graph must be a GraphView to have its parent replaced with the root graph. Got {type(parent)}.\"\n        )\n\n    self._root = parent._root\n    self._local_to_external = bidict.bidict(\n        (k, parent._local_to_external[v]) for k, v in self._local_to_external.items()\n    )\n\n    self._edge_map_to_root = bidict.bidict(\n        (k, parent._edge_map_to_root[v]) for k, v in self._edge_map_to_root.items()\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._rx_subgraph_with_nodemap","title":"_rx_subgraph_with_nodemap","text":"<pre><code>_rx_subgraph_with_nodemap(node_ids: Sequence[int] | None = None) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]\n</code></pre> <p>Get a subgraph of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[PyDiGraph, NodeMap]</code>           \u2013            <p>The subgraph and the node map.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def _rx_subgraph_with_nodemap(\n    self,\n    node_ids: Sequence[int] | None = None,\n) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]:\n    \"\"\"\n    Get a subgraph of the graph.\n\n    Parameters\n    ----------\n    node_ids : Sequence[int] | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    tuple[rx.PyDiGraph, rx.NodeMap]\n        The subgraph and the node map.\n    \"\"\"\n    node_ids = self._map_to_local(node_ids)\n    rx_graph, node_map = super()._rx_subgraph_with_nodemap(node_ids)\n    node_map = {k: self._map_to_external(v) for k, v in node_map.items()}\n    return rx_graph, node_map\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._rx_subgraph_with_nodemap(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(attrs: dict[str, Any], reference_keys: list[str], mode: str) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys():\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._vectorized_map_to_external","title":"_vectorized_map_to_external","text":"<pre><code>_vectorized_map_to_external(local_ids: ndarray | Sequence[int]) -&gt; np.ndarray\n</code></pre> <p>Vectorized transformation of local IDs to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of external IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _vectorized_map_to_external(self, local_ids: np.ndarray | Sequence[int]) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized transformation of local IDs to external coordinates.\n\n    Parameters\n    ----------\n    local_ids : np.ndarray | Sequence[int]\n        Array or sequence of local IDs\n\n    Returns\n    -------\n    np.ndarray\n        Array of external IDs\n    \"\"\"\n    vec_map = np.vectorize(self._local_to_external.__getitem__, otypes=[int])\n    return vec_map(np.asarray(local_ids, dtype=int))\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._vectorized_map_to_external(local_ids)","title":"<code>local_ids</code>","text":"(<code>ndarray | Sequence[int]</code>)           \u2013            <p>Array or sequence of local IDs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._vectorized_map_to_local","title":"_vectorized_map_to_local","text":"<pre><code>_vectorized_map_to_local(external_ids: ndarray | Sequence[int]) -&gt; np.ndarray\n</code></pre> <p>Vectorized transformation of external IDs to local coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of local IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _vectorized_map_to_local(self, external_ids: np.ndarray | Sequence[int]) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized transformation of external IDs to local coordinates.\n\n    Parameters\n    ----------\n    external_ids : np.ndarray | Sequence[int]\n        Array or sequence of external IDs\n\n    Returns\n    -------\n    np.ndarray\n        Array of local IDs\n    \"\"\"\n    vec_map = np.vectorize(self._external_to_local.__getitem__, otypes=[int])\n    return vec_map(np.asarray(external_ids, dtype=int))\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._vectorized_map_to_local(external_ids)","title":"<code>external_ids</code>","text":"(<code>ndarray | Sequence[int]</code>)           \u2013            <p>Array or sequence of external IDs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.add_overlap--parameters","title":"Parameters","text":"<p>source_id : int     The ID of the source node. target_id : int     The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.add_overlap--returns","title":"Returns","text":"<p>int     The ID of the added overlap.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    return self._root.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.assign_track_ids","title":"assign_track_ids","text":"<pre><code>assign_track_ids(output_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, reset: bool = True, track_id_offset: int = 1) -&gt; rx.PyDiGraph\n</code></pre> <p>Compute and assign track ids to nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed graph (parent -&gt; child) with track ids lineage relationships.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def assign_track_ids(\n    self,\n    output_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    reset: bool = True,\n    track_id_offset: int = 1,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Compute and assign track ids to nodes.\n\n    Parameters\n    ----------\n    output_key : str\n        The key of the output track id attribute.\n    reset : bool\n        Whether to reset all track ids before assigning new ones.\n    track_id_offset : int\n        The starting track id, useful when assigning track ids to a subgraph.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed graph (parent -&gt; child) with track ids lineage relationships.\n    \"\"\"\n    try:\n        node_ids, track_ids, tracks_graph = _assign_track_ids(self.rx_graph, track_id_offset)\n    except RuntimeError as e:\n        raise RuntimeError(\n            \"Are you sure this graph is a valid lineage graph?\\n\"\n            \"This function expects a solved graph.\\n\"\n            \"Often used from `graph.subgraph(edge_attr_filter={'solution': True})`\"\n        ) from e\n\n    node_ids = self._map_to_external(node_ids)\n\n    if output_key not in self.node_attr_keys:\n        self.add_node_attr_key(output_key, -1)\n    elif reset:\n        self.update_node_attrs(attrs={output_key: -1})\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={output_key: track_ids},\n    )\n\n    return tracks_graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.assign_track_ids(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the output track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.assign_track_ids(reset)","title":"<code>reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset all track ids before assigning new ones.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.assign_track_ids(track_id_offset)","title":"<code>track_id_offset</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The starting track id, useful when assigning track ids to a subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bbox_spatial_filter","title":"bbox_spatial_filter","text":"<pre><code>bbox_spatial_filter(frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T, bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX) -&gt; BBoxSpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> <p>This method creates a spatial index of graph nodes based on their bounding box coordinates, enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for bounding boxes:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n# Query nodes intersecting with region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter()\n# Uses default [\"t\", \"bbox\"]\n# Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>BBoxSpatialFilter:     The bounding box spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bbox_spatial_filter(\n    self,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n) -&gt; \"BBoxSpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.\n\n    This method creates a spatial index of graph nodes based on their bounding box coordinates,\n    enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    frame_attr_key : str | None\n        The attribute key for the frame (time) coordinate.\n        Default is `DEFAULT_ATTR_KEYS.T`.\n        If None it will only use the bounding box coordinates.\n    bbox_attr_key : str\n        The attribute key for the bounding box coordinates.\n        Defaults to `DEFAULT_ATTR_KEYS.BBOX`.\n        The bounding box coordinates should be in the format:\n        [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]\n        where each dimension has a min and max value.\n\n    Returns\n    -------\n    BBoxSpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for bounding boxes:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n    # Query nodes intersecting with region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter()\n    # Uses default [\"t\", \"bbox\"]\n    # Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [BBoxSpatialFilter][tracksdata.graph.filters.BBoxSpatialFilter]:\n        The bounding box spatial filter query class.\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import BBoxSpatialFilter\n\n    return BBoxSpatialFilter(self, frame_attr_key=frame_attr_key, bbox_attr_key=bbox_attr_key)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bbox_spatial_filter(frame_attr_key)","title":"<code>frame_attr_key</code>","text":"(<code>str | None</code>, default:                   <code>T</code> )           \u2013            <p>The attribute key for the frame (time) coordinate. Default is <code>DEFAULT_ATTR_KEYS.T</code>. If None it will only use the bounding box coordinates.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bbox_spatial_filter(bbox_attr_key)","title":"<code>bbox_attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key for the bounding box coordinates. Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>. The bounding box coordinates should be in the format: [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...] where each dimension has a min and max value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.GraphView.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    self._root.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_attrs = self.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t).node_attrs(\n            attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MASK],\n        )\n        node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        masks = node_attrs[DEFAULT_ATTR_KEYS.MASK].to_list()\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.contract_nodes","title":"contract_nodes","text":"<pre><code>contract_nodes(permanent_node_ids: Sequence[int]) -&gt; GraphView\n</code></pre> <p>Contract the graph to only include the given <code>permanent_node_ids</code>. Predecessor and sucessors of removed nodes are connected during contraction.</p> <p>Example:</p> <pre><code>graph TD\n    A((t=0)) --&gt; B((t=1))\n    A --&gt; C((t=1))\n    B --&gt; D((t=2))\n    C --&gt; E((t=2))\n    C --&gt; F((t=2))</code></pre> <p>After contraction only keeping nodes in <code>t=0</code> and <code>t=2</code>: <pre><code>graph TD\n    A((t=0)) --&gt; B((t=2))\n    A --&gt; C((t=2))\n    A --&gt; D((t=2))</code></pre></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphView</code>           \u2013            <p>A view of the contracted graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def contract_nodes(\n    self,\n    permanent_node_ids: Sequence[int],\n) -&gt; \"GraphView\":\n    \"\"\"\n    Contract the graph to only include the given `permanent_node_ids`.\n    Predecessor and sucessors of removed nodes are connected during contraction.\n\n    Example:\n\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=1))\n        A --&gt; C((t=1))\n        B --&gt; D((t=2))\n        C --&gt; E((t=2))\n        C --&gt; F((t=2))\n    ```\n\n    After contraction only keeping nodes in `t=0` and `t=2`:\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=2))\n        A --&gt; C((t=2))\n        A --&gt; D((t=2))\n    ```\n\n    Parameters\n    ----------\n    permanent_node_ids : Sequence[int]\n        The node ids to keep in the contracted graph.\n\n    Returns\n    -------\n    GraphView\n        A view of the contracted graph.\n    \"\"\"\n    subgraph = super().contract_nodes(\n        permanent_node_ids=self._map_to_local(permanent_node_ids),\n    )\n    subgraph._replace_parent_graph_with_root()\n\n    return subgraph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.contract_nodes(permanent_node_ids)","title":"<code>permanent_node_ids</code>","text":"(<code>Sequence[int]</code>)           \u2013            <p>The node ids to keep in the contracted graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; GraphView\n</code></pre> <p>Not supported for <code>GraphView</code>.</p> <p>Use <code>detach</code> to create a new reference-less graph with the same nodes and edges.</p> See Also <p>detach     Create a new reference-less graph with the same nodes and edges.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def copy(self, **kwargs) -&gt; \"GraphView\":\n    \"\"\"\n    Not supported for `GraphView`.\n\n    Use `detach` to create a new reference-less graph with the same nodes and edges.\n\n    See Also\n    --------\n    [detach][tracksdata.graph.GraphView.detach]\n        Create a new reference-less graph with the same nodes and edges.\n    \"\"\"\n    raise ValueError(\n        \"`copy` is not supported for `GraphView`.\\n\"\n        \"Use `detach` to create a new reference-less graph with the same nodes and edges.\"\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.detach","title":"detach","text":"<pre><code>detach(reset_ids: Literal[False]) -&gt; IndexedRXGraph\n</code></pre><pre><code>detach(reset_ids: Literal[True]) -&gt; RustWorkXGraph\n</code></pre> <pre><code>detach(reset_ids: bool = False) -&gt; IndexedRXGraph | RustWorkXGraph\n</code></pre> <p>Detach the graph view from the root graph, returning a new graph with the same nodes and edges without the view's mapping and indenpendent ids.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.detach--parameters","title":"Parameters","text":"<p>reset_ids : bool     Whether to reset the ids of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.detach--returns","title":"Returns","text":"<p>IndexedRXGraph | RustWorkXGraph     The detached graph.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def detach(self, reset_ids: bool = False) -&gt; IndexedRXGraph | RustWorkXGraph:\n    \"\"\"\n    Detach the graph view from the root graph, returning a new graph with the same nodes and edges\n    without the view's mapping and indenpendent ids.\n\n    Parameters\n    ----------\n    reset_ids : bool\n        Whether to reset the ids of the graph.\n\n    Returns\n    -------\n    IndexedRXGraph | RustWorkXGraph\n        The detached graph.\n    \"\"\"\n    if reset_ids:\n        return RustWorkXGraph.from_other(self)\n    else:\n        return IndexedRXGraph.from_other(self)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.edge_id","title":"edge_id","text":"<pre><code>edge_id(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Return the edge id between two nodes.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def edge_id(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Return the edge id between two nodes.\n    \"\"\"\n    return self._root.edge_id(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(positions: ArrayLike, track_ids: ArrayLike | None = None, track_id_graph: dict[int, int] | None = None, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. track_ids : np.ndarray | None     Track ids of the nodes if available. track_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    track_ids: ArrayLike | None = None,\n    track_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    track_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    track_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import from_array\n\n    graph = cls(**kwargs)\n    from_array(\n        positions=np.asarray(positions),\n        graph=graph,\n        track_ids=track_ids,\n        track_id_graph=track_id_graph,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--see-also","title":"See Also","text":"<p>from_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--see-also_1","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [from_ctc][tracksdata.io._ctc.from_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n\n    See Also\n    --------\n    [to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import from_ctc\n\n    graph = cls(**kwargs)\n    from_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_geff","title":"from_geff  <code>classmethod</code>","text":"<pre><code>from_geff(geff_store: StoreLike, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a geff data directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>The loaded graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_geff(\n    cls: type[T],\n    geff_store: StoreLike,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to read the graph from.\n    **kwargs\n        Additional keyword arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    T\n        The loaded graph.\n    \"\"\"\n    from tracksdata.graph import IndexedRXGraph\n\n    # this performs a roundtrip with the rustworkx graph\n    rx_graph, _ = read_rx(geff_store)\n\n    if not isinstance(rx_graph, rx.PyDiGraph):\n        LOG.warning(\"The graph is not a directed graph, converting to directed graph.\")\n        rx_graph = rx_graph.to_directed()\n\n    indexed_graph = IndexedRXGraph(\n        rx_graph=rx_graph,\n        node_id_map=rx_graph.attrs[\"to_rx_id_map\"],\n        **kwargs,\n    )\n\n    if cls == IndexedRXGraph:\n        return indexed_graph\n\n    return cls.from_other(indexed_graph, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to read the graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_geff(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional keyword arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_other--parameters","title":"Parameters","text":"<p>other : BaseGraph     The other graph to create a new graph from. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_other--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the other graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            graph.add_node_attr_key(col, node_attrs[col].first())\n\n    if graph.supports_custom_indices:\n        new_node_ids = graph.bulk_add_nodes(\n            list(node_attrs.rows(named=True)),\n            indices=other_node_ids.to_list(),\n        )\n    else:\n        new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n        if other.supports_custom_indices:\n            LOG.warning(\n                f\"Other graph ({type(other).__name__}) supports custom indices, but this graph \"\n                f\"({type(graph).__name__}) does not, indexing automatically.\"\n            )\n\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.has_edge","title":"has_edge","text":"<pre><code>has_edge(source_id: int, target_id: int) -&gt; bool\n</code></pre> <p>Check if the graph has an edge between two nodes.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def has_edge(self, source_id: int, target_id: int) -&gt; bool:\n    \"\"\"\n    Check if the graph has an edge between two nodes.\n    \"\"\"\n\n    try:\n        source_id = self._map_to_local(source_id)\n    except KeyError:\n        LOG.warning(f\"`source_id` {source_id} not found in index map.\")\n        return False\n\n    try:\n        target_id = self._map_to_local(target_id)\n    except KeyError:\n        LOG.warning(f\"`target_id` {target_id} not found in index map.\")\n        return False\n\n    return self.rx_graph.has_edge(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return len(self.overlaps()) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.in_degree","title":"in_degree","text":"<pre><code>in_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.in_degree(self._map_to_local(node_ids))\n    return [rx_graph.in_degree(self._map_to_local(node_id)) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match","title":"match","text":"<pre><code>match(other: BaseGraph, matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID, match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE, matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.out_degree","title":"out_degree","text":"<pre><code>out_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.out_degree(self._map_to_local(node_ids))\n    return [rx_graph.out_degree(self._map_to_local(node_id)) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.overlaps","title":"overlaps","text":"<pre><code>overlaps(node_ids: list[int] | None = None) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>. If <code>node_ids</code> is None, all nodes are used.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps between the nodes in <code>node_ids</code>.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    If `node_ids` is None, all nodes are used.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the overlaps for.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps between the nodes in `node_ids`.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    return self._root.overlaps(node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the overlaps for. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.remove_node","title":"remove_node","text":"<pre><code>remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the graph.</p> <p>This method removes the node from both the view and the root graph, along with all connected edges. Also updates the node mappings.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the node_id does not exist in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph.\n\n    This method removes the node from both the view and the root graph,\n    along with all connected edges. Also updates the node mappings.\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to remove.\n\n    Raises\n    ------\n    ValueError\n        If the node_id does not exist in the graph.\n    \"\"\"\n    if node_id not in self._external_to_local:\n        raise ValueError(f\"Node {node_id} does not exist in the graph\")\n\n    # Remove from root graph first\n    self._root.remove_node(node_id)\n\n    if self.sync:\n        # Get the local node ID and remove from local graph\n        local_node_id = self._external_to_local[node_id]\n\n        super().remove_node(local_node_id)\n\n        # Remove the node mapping\n        self._remove_id_mapping(external_id=node_id)\n\n        # Update edge mappings - remove edges involving this node\n        edges_to_remove = []\n        edge_indices = self.rx_graph.edge_indices()\n        for local_edge_id, _ in list(self._edge_map_to_root.items()):\n            # Check if this edge is still in the local graph\n            if local_edge_id not in edge_indices:\n                edges_to_remove.append(local_edge_id)\n\n        for edge_id in edges_to_remove:\n            if edge_id in self._edge_map_to_root:\n                del self._edge_map_to_root[edge_id]\n    else:\n        self._out_of_sync = True\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.spatial_filter","title":"spatial_filter","text":"<pre><code>spatial_filter(attr_keys: list[str] | None = None) -&gt; SpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> <p>This method creates a spatial index of graph nodes based on their spatial coordinates, enabling efficient querying of nodes within spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for image coordinates:</p> <pre><code>spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n# Query nodes in region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n# Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>SpatialFilter:     The point spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def spatial_filter(self, attr_keys: list[str] | None = None) -&gt; \"SpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes.\n\n    This method creates a spatial index of graph nodes based on their spatial coordinates,\n    enabling efficient querying of nodes within spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    attr_keys : list[str] | None, optional\n        List of attribute keys to use as spatial coordinates. If None, defaults to\n        [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.\n        Common combinations include:\n        - 2D: [\"y\", \"x\"]\n        - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"]\n        - 4D: [\"t\", \"z\", \"y\", \"x\"]\n\n    Returns\n    -------\n    SpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for image coordinates:\n\n    ```python\n    spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n    # Query nodes in region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n    # Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [SpatialFilter][tracksdata.graph.filters.SpatialFilter]:\n        The point spatial filter query class.\n\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import SpatialFilter\n\n    return SpatialFilter(self, attr_keys=attr_keys)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.spatial_filter(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute keys to use as spatial coordinates. If None, defaults to [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph. Common combinations include: - 2D: [\"y\", \"x\"] - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"] - 4D: [\"t\", \"z\", \"y\", \"x\"]</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.summary","title":"summary","text":"<pre><code>summary(attrs_stats: bool = False, print_summary: bool = True) -&gt; str\n</code></pre> <p>Print a summary of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string with the summary of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def summary(\n    self,\n    attrs_stats: bool = False,\n    print_summary: bool = True,\n) -&gt; str:\n    \"\"\"\n    Print a summary of the graph.\n\n    Parameters\n    ----------\n    attrs_stats : bool\n        If true it will print statistics about the attributes of the nodes and edges.\n    print_summary : bool\n        If true it will print the summary of the graph.\n\n    Returns\n    -------\n    str\n        A string with the summary of the graph.\n    \"\"\"\n    summary = \"\"\n\n    summary += \"Graph summary:\\n\"\n    summary += f\"Number of nodes: {self.num_nodes}\\n\"\n    summary += f\"Number of edges: {self.num_edges}\\n\"\n    summary += f\"Number of overlaps: {len(self.overlaps())}\\n\"\n\n    time_points = self.time_points()\n    summary += f\"Number of distinct time points: {len(time_points)}\\n\"\n    if len(time_points) &gt; 0:\n        summary += f\"Start time: {min(time_points)}\\n\"\n        summary += f\"End time: {max(time_points)}\\n\"\n    else:\n        summary += \"No time points found.\\n\"\n\n    if attrs_stats:\n        nodes_attrs = self.node_attrs()\n        edges_attrs = self.edge_attrs()\n        summary += \"\\nNodes attributes:\\n\"\n        summary += str(nodes_attrs.describe())\n        summary += \"\\nEdges attributes:\\n\"\n        summary += str(edges_attrs.describe())\n\n    if print_summary:\n        print(summary)\n\n    return summary\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.summary(attrs_stats)","title":"<code>attrs_stats</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true it will print statistics about the attributes of the nodes and edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.summary(print_summary)","title":"<code>print_summary</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true it will print the summary of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.time_points","title":"time_points","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n    return list(self._time_to_nodes.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(shape: tuple[int, ...], output_dir: str | Path, track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, overwrite: bool = False) -&gt; None\n</code></pre> <p>Save the graph to a CTC ground truth directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_ctc--parameters","title":"Parameters","text":"<p>shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X) output_dir : str | Path     The directory to save the graph to. track_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_ctc--examples","title":"Examples","text":"<pre><code># ...\nsolution_graph = solver.solve(graph)\nsolution_graph.assign_track_ids()\nsolution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_ctc--see-also","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_ctc(\n    self,\n    shape: tuple[int, ...],\n    output_dir: str | Path,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save the graph to a CTC ground truth directory.\n\n    Parameters\n    ----------\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X)\n    output_dir : str | Path\n        The directory to save the graph to.\n    track_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    Examples\n    --------\n    ```python\n    # ...\n    solution_graph = solver.solve(graph)\n    solution_graph.assign_track_ids()\n    solution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n    ```\n\n    See Also\n    --------\n    [to_ctc][tracksdata.io.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import to_ctc\n\n    to_ctc(\n        graph=self,\n        shape=shape,\n        output_dir=output_dir,\n        track_id_key=track_id_key,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_geff","title":"to_geff","text":"<pre><code>to_geff(geff_store: StoreLike, geff_metadata: GeffMetadata | None = None, zarr_format: Literal[2, 3] = 3) -&gt; None\n</code></pre> <p>Write the graph to a geff data directory.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_geff(\n    self,\n    geff_store: StoreLike,\n    geff_metadata: GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None:\n    \"\"\"\n    Write the graph to a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to write the graph to.\n    geff_metadata : GeffMetadata | None\n        The geff metadata to write to the graph.\n        It automatically generates the metadata with:\n        - axes: time (t) and spatial axes ((z), y, x)\n        - tracklet node property: track_id\n    zarr_format : Literal[2, 3]\n        The zarr format to write the graph to.\n        Defaults to 3.\n    \"\"\"\n\n    node_attrs = self.node_attrs()\n\n    if DEFAULT_ATTR_KEYS.MASK in node_attrs.columns:\n        node_attrs = column_to_bytes(node_attrs, DEFAULT_ATTR_KEYS.MASK)\n\n    if geff_metadata is None:\n        axes = [Axis(name=DEFAULT_ATTR_KEYS.T, type=\"time\")]\n        axes.extend([Axis(name=c, type=\"space\") for c in (\"z\", \"y\", \"x\") if c in node_attrs.columns])\n\n        if DEFAULT_ATTR_KEYS.TRACK_ID in node_attrs.columns:\n            track_node_props = {\n                \"tracklet\": DEFAULT_ATTR_KEYS.TRACK_ID,\n            }\n        else:\n            track_node_props = None\n\n        geff_metadata = GeffMetadata(\n            directed=True,\n            axes=axes,\n            track_node_props=track_node_props,\n        )\n\n    edge_attrs = self.edge_attrs().drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    node_dict = {\n        k: (column_to_numpy(v), None) for k, v in node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID).to_dict().items()\n    }\n\n    edge_ids = edge_attrs.select(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET).to_numpy()\n\n    edge_dict = {\n        k: (column_to_numpy(v), None)\n        for k, v in edge_attrs.drop(\n            DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n            DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        )\n        .to_dict()\n        .items()\n    }\n\n    write_arrays(\n        geff_store,\n        metadata=geff_metadata,\n        node_ids=node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy(),\n        node_props=node_dict,\n        edge_ids=edge_ids,\n        edge_props=edge_dict,\n        zarr_format=zarr_format,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to write the graph to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_geff(geff_metadata)","title":"<code>geff_metadata</code>","text":"(<code>GeffMetadata | None</code>, default:                   <code>None</code> )           \u2013            <p>The geff metadata to write to the graph. It automatically generates the metadata with: - axes: time (t) and spatial axes ((z), y, x) - tracklet node property: track_id</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_geff(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The zarr format to write the graph to. Defaults to 3.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.tracklet_graph","title":"tracklet_graph","text":"<pre><code>tracklet_graph(track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, ignore_track_id: int | None = None) -&gt; rx.PyDiGraph\n</code></pre> <p>Create a compressed tracklet graph where each node is a tracklet and each edge is a transition between tracklets.</p> <p>IMPORTANT: rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values. And edge values are the tuple of source and target tracklet ids.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed tracklet graph.</p> </li> </ul> See Also <p>rx_digraph_to_napari_dict:     Convert a tracklet graph to a napari-ready dictionary.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_graph(\n    self,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    ignore_track_id: int | None = None,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Create a compressed tracklet graph where each node is a tracklet\n    and each edge is a transition between tracklets.\n\n    IMPORTANT:\n    rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values.\n    And edge values are the tuple of source and target tracklet ids.\n\n    Parameters\n    ----------\n    track_id_key : str\n        The key of the track id attribute.\n    ignore_track_id : int | None\n        The track id to ignore. If None, all track ids are used.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed tracklet graph.\n\n    See Also\n    --------\n    [rx_digraph_to_napari_dict][tracksdata.functional.rx_digraph_to_napari_dict]:\n        Convert a tracklet graph to a napari-ready dictionary.\n    \"\"\"\n\n    if track_id_key not in self.node_attr_keys:\n        raise ValueError(f\"Track id key '{track_id_key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n    nodes_df = self.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, track_id_key])\n    edges_df = self.edge_attrs(attr_keys=[])\n\n    if ignore_track_id is not None:\n        nodes_df = nodes_df.filter(pl.col(track_id_key) != ignore_track_id)\n\n    nodes_df = nodes_df.unique(subset=[track_id_key])\n\n    graph = rx.PyDiGraph()\n    nodes_df = nodes_df.with_columns(\n        pl.Series(\n            np.asarray(graph.add_nodes_from(nodes_df[track_id_key].to_list()), dtype=int),\n        ).alias(\"rx_id\"),\n    )\n\n    edges_df = (\n        edges_df.join(\n            nodes_df.rename({track_id_key: \"source_track_id\", \"rx_id\": \"source_rx_id\"}),\n            left_on=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n            right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n            how=\"right\",\n        )\n        .join(\n            nodes_df.rename({track_id_key: \"target_track_id\", \"rx_id\": \"target_rx_id\"}),\n            left_on=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n            right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n            how=\"right\",\n        )\n        .filter(~pl.col(DEFAULT_ATTR_KEYS.EDGE_ID).is_null())\n    )\n\n    graph.add_edges_from(\n        zip(\n            edges_df[\"source_rx_id\"].to_list(),\n            edges_df[\"target_rx_id\"].to_list(),\n            zip(edges_df[\"source_track_id\"].to_list(), edges_df[\"target_track_id\"].to_list(), strict=False),\n            strict=True,\n        )\n    )\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.tracklet_graph(track_id_key)","title":"<code>track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.tracklet_graph(ignore_track_id)","title":"<code>ignore_track_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The track id to ignore. If None, all track ids are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph","title":"IndexedRXGraph","text":"<pre><code>IndexedRXGraph(rx_graph: PyDiGraph | None = None, node_id_map: dict[int, int] | None = None)\n</code></pre> <p>               Bases: <code>RustWorkXGraph</code>, <code>MappedGraphMixin</code></p> <p>A graph with arbitrary node indices.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph = IndexedRXGraph(rx_graph=rx_graph, node_id_map=node_id_map)\n...\ngraph = IndexedRXGraph()\ngraph.add_node({\"t\": 0}, index=1355)\n</code></pre> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Helper method to interact with a single node.</p> </li> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edge_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph.</p> </li> <li> <code>add_node_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add an overlap to the graph.</p> </li> <li> <code>assign_track_ids</code>             \u2013              <p>Compute and assign track ids to nodes.</p> </li> <li> <code>bbox_spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Add multiple nodes to the graph.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>contract_nodes</code>             \u2013              <p>Contract the graph to only include the given <code>permanent_node_ids</code>.</p> </li> <li> <code>copy</code>             \u2013              <p>Create a copy of this graph.</p> </li> <li> <code>edge_attrs</code>             \u2013              <p>Get the edge attributes of the graph.</p> </li> <li> <code>edge_id</code>             \u2013              <p>Return the edge id between two nodes.</p> </li> <li> <code>edge_ids</code>             \u2013              <p>Get the IDs of all edges in the graph.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_geff</code>             \u2013              <p>Create a graph from a geff data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_edge</code>             \u2013              <p>Check if the graph has an edge between two nodes.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in degree of the graph.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_attrs</code>             \u2013              <p>Get the node attributes of the graph.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the node ids of the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out degree of the graph.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps of the graph.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessors of a list of nodes.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a node from the graph.</p> </li> <li> <code>spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> </li> <li> <code>successors</code>             \u2013              <p>Get the sucessors of a list of nodes.</p> </li> <li> <code>summary</code>             \u2013              <p>Print a summary of the graph.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save the graph to a CTC ground truth directory.</p> </li> <li> <code>to_geff</code>             \u2013              <p>Write the graph to a geff data directory.</p> </li> <li> <code>tracklet_graph</code>             \u2013              <p>Create a compressed tracklet graph where each node is a tracklet</p> </li> <li> <code>update_edge_attrs</code>             \u2013              <p>Update the attributes of the edges.</p> </li> <li> <code>update_node_attrs</code>             \u2013              <p>Update the node attributes of the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the edges.</p> </li> <li> <code>node_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the nodes.</p> </li> <li> <code>num_edges</code>               (<code>int</code>)           \u2013            <p>The number of edges in the graph.</p> </li> <li> <code>num_nodes</code>               (<code>int</code>)           \u2013            <p>The number of nodes in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def __init__(\n    self,\n    rx_graph: rx.PyDiGraph | None = None,\n    node_id_map: dict[int, int] | None = None,\n) -&gt; None:\n    if rx_graph is not None and node_id_map is None:\n        raise ValueError(\"`node_id_map` must be provided when `rx_graph` is provided\")\n\n    if rx_graph is None and node_id_map is not None:\n        raise ValueError(\"`rx_graph` must be provided when `node_id_map` is provided\")\n\n    # Initialize RustWorkXGraph\n    RustWorkXGraph.__init__(self, rx_graph)\n\n    # Initialize MappedGraphMixin with inverted mapping (local -&gt; external)\n    inverted_map = None\n    if node_id_map is not None:\n        # Validate for duplicate values before inverting\n        # This will raise bidict.ValueDuplicationError if there are duplicates\n        inverted_map = bidict.bidict(node_id_map).inverse\n        self._next_external_id = max(node_id_map.keys(), default=0) + 1\n    else:\n        self._next_external_id = 0\n\n    MappedGraphMixin.__init__(self, inverted_map)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph(rx_graph)","title":"<code>rx_graph</code>","text":"(<code>PyDiGraph | None</code>, default:                   <code>None</code> )           \u2013            <p>The rustworkx graph to index.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph(node_id_map)","title":"<code>node_id_map</code>","text":"(<code>dict[int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>A map of external ids (arbitrary) to rx graph ids (0 to N-1), must be provided if <code>rx_graph</code> is provided.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_attr_keys","title":"edge_attr_keys  <code>property</code>","text":"<pre><code>edge_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.node_attr_keys","title":"node_attr_keys  <code>property</code>","text":"<pre><code>node_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.num_edges","title":"num_edges  <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(node_id: int) -&gt; NodeInterface\n</code></pre> <p>Helper method to interact with a single node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NodeInterface</code>           \u2013            <p>A node interface for the given node id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def __getitem__(self, node_id: int) -&gt; \"NodeInterface\":\n    \"\"\"\n    Helper method to interact with a single node.\n\n    Parameters\n    ----------\n    node_id : int\n        The id of the node to interact with.\n\n    Returns\n    -------\n    NodeInterface\n        A node interface for the given node id.\n    \"\"\"\n\n    if not isinstance(node_id, int):\n        raise ValueError(f\"graph index must be a integer, found '{node_id}' of type {type(node_id)}\")\n    return NodeInterface(self, node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.__getitem__(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The id of the node to interact with.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._add_id_mapping","title":"_add_id_mapping","text":"<pre><code>_add_id_mapping(local_id: int, external_id: int) -&gt; None\n</code></pre> <p>Add a new ID mapping.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _add_id_mapping(self, local_id: int, external_id: int) -&gt; None:\n    \"\"\"\n    Add a new ID mapping.\n\n    Parameters\n    ----------\n    local_id : int\n        Local node ID\n    external_id : int\n        External node ID\n    \"\"\"\n    try:\n        self._local_to_external.put(local_id, external_id)\n    except bidict.ValueDuplicationError as e:\n        # Convert ValueDuplicationError to KeyDuplicationError since from user perspective\n        # the external_id (their \"key\"/index) is what's being duplicated\n        raise bidict.KeyDuplicationError(e.args[0]) from e\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._add_id_mapping(local_id)","title":"<code>local_id</code>","text":"(<code>int</code>)           \u2013            <p>Local node ID</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._add_id_mapping(external_id)","title":"<code>external_id</code>","text":"(<code>int</code>)           \u2013            <p>External node ID</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._add_id_mappings","title":"_add_id_mappings","text":"<pre><code>_add_id_mappings(mappings: Sequence[tuple[int, int]]) -&gt; None\n</code></pre> <p>Add multiple ID mappings at once.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _add_id_mappings(self, mappings: Sequence[tuple[int, int]]) -&gt; None:\n    \"\"\"\n    Add multiple ID mappings at once.\n\n    Parameters\n    ----------\n    mappings : Sequence[tuple[int, int]]\n        Sequence of (local_id, external_id) pairs\n    \"\"\"\n    self._local_to_external.putall(mappings)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._add_id_mappings(mappings)","title":"<code>mappings</code>","text":"(<code>Sequence[tuple[int, int]]</code>)           \u2013            <p>Sequence of (local_id, external_id) pairs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._filter_nodes_by_attrs","title":"_filter_nodes_by_attrs","text":"<pre><code>_filter_nodes_by_attrs(*attrs: AttrComparison, node_ids: Sequence[int] | None = None) -&gt; list[int]\n</code></pre> <p>Filter nodes by attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the filtered nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _filter_nodes_by_attrs(\n    self,\n    *attrs: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Filter nodes by attributes.\n\n    Parameters\n    ----------\n    *attrs : AttrComparison\n        The attributes to filter by, for example:\n    node_ids : list[int] | None\n        The IDs of the nodes to include in the filter.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the filtered nodes.\n    \"\"\"\n    rx_graph = self.rx_graph\n    node_map = None\n    # entire graph\n    attrs, time = _pop_time_eq(attrs)\n    selected_nodes = None\n\n    if time is not None:\n        selected_nodes = self._time_to_nodes.get(time, [])\n\n        if node_ids is not None:\n            selected_nodes = np.intersect1d(selected_nodes, node_ids).tolist()\n\n        if len(attrs) == 0:\n            return selected_nodes\n\n    elif node_ids is not None:\n        selected_nodes = node_ids\n\n    if selected_nodes is not None:\n        # subgraph of selected nodes\n        rx_graph, node_map = rx_graph.subgraph_with_nodemap(selected_nodes)\n\n    _filter_func = _create_filter_func(attrs)\n\n    if node_map is None:\n        return list(rx_graph.filter_nodes(_filter_func))\n    else:\n        return [node_map[n] for n in rx_graph.filter_nodes(_filter_func)]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._filter_nodes_by_attrs(*attrs)","title":"<code>*attrs</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter by, for example:</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._filter_nodes_by_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to include in the filter. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._get_external_ids","title":"_get_external_ids","text":"<pre><code>_get_external_ids() -&gt; list[int]\n</code></pre> <p>Get all external IDs in the mapping.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all external node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _get_external_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get all external IDs in the mapping.\n\n    Returns\n    -------\n    list[int]\n        List of all external node IDs\n    \"\"\"\n    return list(self._local_to_external.values())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._get_local_ids","title":"_get_local_ids","text":"<pre><code>_get_local_ids() -&gt; list[int]\n</code></pre> <p>Get all local IDs in the mapping.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all local node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _get_local_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get all local IDs in the mapping.\n\n    Returns\n    -------\n    list[int]\n        List of all local node IDs\n    \"\"\"\n    return list(self._local_to_external.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._get_next_available_external_id","title":"_get_next_available_external_id","text":"<pre><code>_get_next_available_external_id() -&gt; int\n</code></pre> <p>Get the next available external ID in O(1) time using an internal counter.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The next available external ID.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _get_next_available_external_id(self) -&gt; int:\n    \"\"\"\n    Get the next available external ID in O(1) time using an internal counter.\n\n    Returns\n    -------\n    int\n        The next available external ID.\n    \"\"\"\n    next_id = self._next_external_id\n    self._next_external_id += 1\n    return next_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_df_to_external","title":"_map_df_to_external","text":"<pre><code>_map_df_to_external(df: DataFrame, columns: Sequence[str]) -&gt; pl.DataFrame\n</code></pre> <p>Transform node IDs in DataFrame columns from local to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>DataFrame with transformed node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_df_to_external(self, df: pl.DataFrame, columns: Sequence[str]) -&gt; pl.DataFrame:\n    \"\"\"\n    Transform node IDs in DataFrame columns from local to external coordinates.\n\n    Parameters\n    ----------\n    df : pl.DataFrame\n        DataFrame containing node IDs to transform\n    columns : Sequence[str]\n        Column names containing node IDs to transform\n\n    Returns\n    -------\n    pl.DataFrame\n        DataFrame with transformed node IDs\n    \"\"\"\n    for col in columns:\n        if col in df.columns:\n            df = df.with_columns(\n                pl.col(col).map_elements(self._local_to_external.__getitem__, return_dtype=pl.Int64).alias(col)\n            )\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_df_to_external(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>DataFrame containing node IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_df_to_external(columns)","title":"<code>columns</code>","text":"(<code>Sequence[str]</code>)           \u2013            <p>Column names containing node IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_to_external","title":"_map_to_external","text":"<pre><code>_map_to_external(local_ids: None) -&gt; None\n</code></pre><pre><code>_map_to_external(local_ids: int) -&gt; int\n</code></pre><pre><code>_map_to_external(local_ids: Sequence[int]) -&gt; list[int]\n</code></pre> <pre><code>_map_to_external(local_ids: int | Sequence[int] | None) -&gt; int | list[int] | None\n</code></pre> <p>Transform local IDs to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int | list[int] | None</code>           \u2013            <p>External IDs corresponding to the local IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_to_external(self, local_ids: int | Sequence[int] | None) -&gt; int | list[int] | None:\n    \"\"\"\n    Transform local IDs to external coordinates.\n\n    Parameters\n    ----------\n    local_ids : int | Sequence[int] | None\n        Local IDs to transform\n\n    Returns\n    -------\n    int | list[int] | None\n        External IDs corresponding to the local IDs\n    \"\"\"\n    if local_ids is None:\n        return None\n    if isinstance(local_ids, int):\n        return self._local_to_external[local_ids]\n    return [self._local_to_external[lid] for lid in local_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_to_external(local_ids)","title":"<code>local_ids</code>","text":"(<code>int | Sequence[int] | None</code>)           \u2013            <p>Local IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_to_local","title":"_map_to_local","text":"<pre><code>_map_to_local(external_ids: None) -&gt; None\n</code></pre><pre><code>_map_to_local(external_ids: int) -&gt; int\n</code></pre><pre><code>_map_to_local(external_ids: Sequence[int]) -&gt; list[int]\n</code></pre> <pre><code>_map_to_local(external_ids: int | Sequence[int] | None) -&gt; int | list[int] | None\n</code></pre> <p>Transform external IDs to local coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int | list[int] | None</code>           \u2013            <p>Local IDs corresponding to the external IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_to_local(self, external_ids: int | Sequence[int] | None) -&gt; int | list[int] | None:\n    \"\"\"\n    Transform external IDs to local coordinates.\n\n    Parameters\n    ----------\n    external_ids : int | Sequence[int] | None\n        External IDs to transform\n\n    Returns\n    -------\n    int | list[int] | None\n        Local IDs corresponding to the external IDs\n    \"\"\"\n    if external_ids is None:\n        return None\n    if isinstance(external_ids, int):\n        return self._external_to_local[external_ids]\n    return [self._external_to_local[eid] for eid in external_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_to_local(external_ids)","title":"<code>external_ids</code>","text":"(<code>int | Sequence[int] | None</code>)           \u2013            <p>External IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._remove_id_mapping","title":"_remove_id_mapping","text":"<pre><code>_remove_id_mapping(*, local_id: int | None = None, external_id: int | None = None) -&gt; None\n</code></pre> <p>Remove an ID mapping.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _remove_id_mapping(\n    self,\n    *,\n    local_id: int | None = None,\n    external_id: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Remove an ID mapping.\n\n    Parameters\n    ----------\n    local_id : int\n        Local node ID to remove from mapping\n    external_id : int\n        External node ID to remove from mapping\n    \"\"\"\n    if local_id is not None:\n        del self._local_to_external[local_id]\n    elif external_id is not None:\n        del self._external_to_local[external_id]\n    else:\n        raise ValueError(\"Either local_id or external_id must be provided\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._remove_id_mapping(local_id)","title":"<code>local_id</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Local node ID to remove from mapping</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._remove_id_mapping(external_id)","title":"<code>external_id</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>External node ID to remove from mapping</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._rx_subgraph_with_nodemap","title":"_rx_subgraph_with_nodemap","text":"<pre><code>_rx_subgraph_with_nodemap(node_ids: Sequence[int] | None = None) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]\n</code></pre> <p>Get a subgraph of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[PyDiGraph, NodeMap]</code>           \u2013            <p>The subgraph and the node map.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _rx_subgraph_with_nodemap(\n    self,\n    node_ids: Sequence[int] | None = None,\n) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]:\n    \"\"\"\n    Get a subgraph of the graph.\n\n    Parameters\n    ----------\n    node_ids : Sequence[int] | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    tuple[rx.PyDiGraph, rx.NodeMap]\n        The subgraph and the node map.\n    \"\"\"\n    # TODO: fix this, too many back and forth between world and graph ids within FilterRX\n    node_ids = self._get_local_ids() if node_ids is None else self._map_to_local(node_ids)\n    rx_graph, node_map = super()._rx_subgraph_with_nodemap(node_ids)\n    node_map = {k: self._map_to_external(v) for k, v in node_map.items()}\n    return rx_graph, node_map\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._rx_subgraph_with_nodemap(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(attrs: dict[str, Any], reference_keys: list[str], mode: str) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys():\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._vectorized_map_to_external","title":"_vectorized_map_to_external","text":"<pre><code>_vectorized_map_to_external(local_ids: ndarray | Sequence[int]) -&gt; np.ndarray\n</code></pre> <p>Vectorized transformation of local IDs to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of external IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _vectorized_map_to_external(self, local_ids: np.ndarray | Sequence[int]) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized transformation of local IDs to external coordinates.\n\n    Parameters\n    ----------\n    local_ids : np.ndarray | Sequence[int]\n        Array or sequence of local IDs\n\n    Returns\n    -------\n    np.ndarray\n        Array of external IDs\n    \"\"\"\n    vec_map = np.vectorize(self._local_to_external.__getitem__, otypes=[int])\n    return vec_map(np.asarray(local_ids, dtype=int))\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._vectorized_map_to_external(local_ids)","title":"<code>local_ids</code>","text":"(<code>ndarray | Sequence[int]</code>)           \u2013            <p>Array or sequence of local IDs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._vectorized_map_to_local","title":"_vectorized_map_to_local","text":"<pre><code>_vectorized_map_to_local(external_ids: ndarray | Sequence[int]) -&gt; np.ndarray\n</code></pre> <p>Vectorized transformation of external IDs to local coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of local IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _vectorized_map_to_local(self, external_ids: np.ndarray | Sequence[int]) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized transformation of external IDs to local coordinates.\n\n    Parameters\n    ----------\n    external_ids : np.ndarray | Sequence[int]\n        Array or sequence of external IDs\n\n    Returns\n    -------\n    np.ndarray\n        Array of local IDs\n    \"\"\"\n    vec_map = np.vectorize(self._external_to_local.__getitem__, otypes=[int])\n    return vec_map(np.asarray(external_ids, dtype=int))\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._vectorized_map_to_local(external_ids)","title":"<code>external_ids</code>","text":"(<code>ndarray | Sequence[int]</code>)           \u2013            <p>Array or sequence of external IDs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(source_id: int, target_id: int, attrs: dict[str, Any], validate_keys: bool = True) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The edge id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The source node id.\n    target_id : int\n        The target node id.\n    attrs : dict[str, Any]\n        The attributes of the edge.\n    validate_keys : bool\n        Whether to validate the keys of the attributes.\n\n    Returns\n    -------\n    int\n        The edge id.\n    \"\"\"\n    source_id = self._map_to_local(source_id)\n    target_id = self._map_to_local(target_id)\n    return super().add_edge(source_id, target_id, attrs, validate_keys)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The source node id.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The target node id.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the edge.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to validate the keys of the attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge_attr_key","title":"add_edge_attr_key","text":"<pre><code>add_edge_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing edges will have the default value for the new attribute key.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_edge_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing edges will have the default value for the new attribute key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the new attribute.\n    default_value : Any\n        The default value for existing edges for the new attribute key.\n    \"\"\"\n    if key in self.edge_attr_keys:\n        raise ValueError(f\"Attribute key {key} already exists\")\n\n    self._edge_attr_keys.append(key)\n    for _, _, edge_attr in self.rx_graph.weighted_edge_list():\n        edge_attr[key] = default_value\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge_attr_key(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the new attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge_attr_key(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>)           \u2013            <p>The default value for existing edges for the new attribute key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node","title":"add_node","text":"<pre><code>add_node(attrs: dict[str, Any], validate_keys: bool = True, index: int | None = None) -&gt; int\n</code></pre> <p>Add a node to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The index of the node.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes of the node.\n    validate_keys : bool\n        Whether to validate the keys of the attributes.\n    index : int | None\n        The index of the node. If None, the next available index will be used\n        to avoid conflicts with existing node indices.\n\n    Returns\n    -------\n    int\n        The index of the node.\n    \"\"\"\n    node_id = super().add_node(attrs, validate_keys)\n    if index is None:\n        index = self._get_next_available_external_id()\n    else:\n        # Update counter if explicit index is higher to avoid future collisions\n        self._next_external_id = max(self._next_external_id, index + 1)\n    # Add mapping using mixin\n    self._add_id_mapping(node_id, index)\n    return index\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to validate the keys of the attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node(index)","title":"<code>index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The index of the node. If None, the next available index will be used to avoid conflicts with existing node indices.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node_attr_key","title":"add_node_attr_key","text":"<pre><code>add_node_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing nodes will have the default value for the new attribute key.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_node_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing nodes will have the default value for the new attribute key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the new attribute.\n    default_value : Any\n        The default value for existing nodes for the new attribute key.\n    \"\"\"\n    if key in self.node_attr_keys:\n        raise ValueError(f\"Attribute key {key} already exists\")\n\n    self._node_attr_keys.append(key)\n    rx_graph = self.rx_graph\n    for node_id in rx_graph.node_indices():\n        rx_graph[node_id][key] = default_value\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node_attr_key(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the new attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node_attr_key(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>)           \u2013            <p>The default value for existing nodes for the new attribute key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add an overlap to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The overlap id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_overlap(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Add an overlap to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The source node id.\n    target_id : int\n        The target node id.\n\n    Returns\n    -------\n    int\n        The overlap id.\n    \"\"\"\n    source_id = self._map_to_local(source_id)\n    target_id = self._map_to_local(target_id)\n    return super().add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_overlap(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The source node id.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_overlap(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The target node id.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.assign_track_ids","title":"assign_track_ids","text":"<pre><code>assign_track_ids(output_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, reset: bool = True, track_id_offset: int = 1) -&gt; rx.PyDiGraph\n</code></pre> <p>Compute and assign track ids to nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed graph (parent -&gt; child) with track ids lineage relationships.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def assign_track_ids(\n    self,\n    output_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    reset: bool = True,\n    track_id_offset: int = 1,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Compute and assign track ids to nodes.\n\n    Parameters\n    ----------\n    output_key : str\n        The key of the output track id attribute.\n    reset : bool\n        Whether to reset the track ids of the graph. If True, the track ids will be reset to -1.\n    track_id_offset : int\n        The starting track id, useful when assigning track ids to a subgraph.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed graph (parent -&gt; child) with track ids lineage relationships.\n    \"\"\"\n    try:\n        node_ids, track_ids, tracks_graph = _assign_track_ids(self.rx_graph, track_id_offset)\n    except RuntimeError as e:\n        raise RuntimeError(\n            \"Are you sure this graph is a valid lineage graph?\\n\"\n            \"This function expects a solved graph.\\n\"\n            \"Often used from `graph.subgraph(edge_attr_filter={'solution': True})`\"\n        ) from e\n\n    if output_key not in self.node_attr_keys:\n        self.add_node_attr_key(output_key, -1)\n    elif reset:\n        self.update_node_attrs(node_ids=self.node_ids(), attrs={output_key: -1})\n\n    # node_ids are rustworkx graph ids, therefore we don't need node_id mapping\n    # and we must use RustWorkXGraph for IndexedRXGraph\n    RustWorkXGraph.update_node_attrs(\n        self,\n        node_ids=node_ids,\n        attrs={output_key: track_ids},\n    )\n\n    return tracks_graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.assign_track_ids(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the output track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.assign_track_ids(reset)","title":"<code>reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset the track ids of the graph. If True, the track ids will be reset to -1.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.assign_track_ids(track_id_offset)","title":"<code>track_id_offset</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The starting track id, useful when assigning track ids to a subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bbox_spatial_filter","title":"bbox_spatial_filter","text":"<pre><code>bbox_spatial_filter(frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T, bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX) -&gt; BBoxSpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> <p>This method creates a spatial index of graph nodes based on their bounding box coordinates, enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for bounding boxes:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n# Query nodes intersecting with region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter()\n# Uses default [\"t\", \"bbox\"]\n# Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>BBoxSpatialFilter:     The bounding box spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bbox_spatial_filter(\n    self,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n) -&gt; \"BBoxSpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.\n\n    This method creates a spatial index of graph nodes based on their bounding box coordinates,\n    enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    frame_attr_key : str | None\n        The attribute key for the frame (time) coordinate.\n        Default is `DEFAULT_ATTR_KEYS.T`.\n        If None it will only use the bounding box coordinates.\n    bbox_attr_key : str\n        The attribute key for the bounding box coordinates.\n        Defaults to `DEFAULT_ATTR_KEYS.BBOX`.\n        The bounding box coordinates should be in the format:\n        [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]\n        where each dimension has a min and max value.\n\n    Returns\n    -------\n    BBoxSpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for bounding boxes:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n    # Query nodes intersecting with region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter()\n    # Uses default [\"t\", \"bbox\"]\n    # Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [BBoxSpatialFilter][tracksdata.graph.filters.BBoxSpatialFilter]:\n        The bounding box spatial filter query class.\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import BBoxSpatialFilter\n\n    return BBoxSpatialFilter(self, frame_attr_key=frame_attr_key, bbox_attr_key=bbox_attr_key)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bbox_spatial_filter(frame_attr_key)","title":"<code>frame_attr_key</code>","text":"(<code>str | None</code>, default:                   <code>T</code> )           \u2013            <p>The attribute key for the frame (time) coordinate. Default is <code>DEFAULT_ATTR_KEYS.T</code>. If None it will only use the bounding box coordinates.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bbox_spatial_filter(bbox_attr_key)","title":"<code>bbox_attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key for the bounding box coordinates. Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>. The bounding box coordinates should be in the format: [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...] where each dimension has a min and max value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None\n</code></pre> <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int] | None</code>           \u2013            <p>The IDs of the added edges.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def bulk_add_edges(self, edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None:\n    \"\"\"\n    Faster method to add multiple edges to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        The data of the edges to be added.\n        The keys of the data will be used as the attributes of the edges.\n        Must have \"source_id\" and \"target_id\" keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Returns\n    -------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    # saving for historical reasons, iterating over edges is faster than using rx.add_edges_from\n    # edges_data = [(d.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE), d.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET), d) for d in edges]\n    # indices = self.rx_graph.add_edges_from(edges_data)\n    # for i, d in zip(indices, edges, strict=True):\n    #     d[DEFAULT_ATTR_KEYS.EDGE_ID] = i\n    # return indices\n    return super().bulk_add_edges(edges, return_ids=return_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the edges to be added. The keys of the data will be used as the attributes of the edges. Must have \"source_id\" and \"target_id\" keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(nodes: list[dict[str, Any]], indices: list[int] | None = None) -&gt; list[int]\n</code></pre> <p>Add multiple nodes to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The indices of the nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def bulk_add_nodes(\n    self,\n    nodes: list[dict[str, Any]],\n    indices: list[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Add multiple nodes to the graph.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        The attributes of the nodes.\n    indices : list[int] | None\n        The indices of the nodes. If None, all nodes will get auto-generated indices.\n        If provided, must have same length as nodes and all indices must be specified.\n\n    Returns\n    -------\n    list[int]\n        The indices of the nodes.\n    \"\"\"\n    if len(nodes) == 0:\n        return []\n\n    self._validate_indices_length(nodes, indices)\n\n    graph_ids = super().bulk_add_nodes(nodes)\n\n    if indices is None:\n        # All nodes get auto-generated indices\n        indices = [self._get_next_available_external_id() for _ in nodes]\n    else:\n        # All indices are explicitly provided\n        if len(indices) != len(nodes):\n            raise ValueError(f\"Length of indices ({len(indices)}) must match nodes ({len(nodes)})\")\n\n        # Update counter to be after the highest explicit index\n        self._next_external_id = max(self._next_external_id, max(indices) + 1)\n\n    self._add_id_mappings(list(zip(graph_ids, indices, strict=True)))\n\n    return indices\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The attributes of the nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_nodes(indices)","title":"<code>indices</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The indices of the nodes. If None, all nodes will get auto-generated indices. If provided, must have same length as nodes and all indices must be specified.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.BaseGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    for source_id, target_id in overlaps:\n        self.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_attrs = self.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t).node_attrs(\n            attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MASK],\n        )\n        node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        masks = node_attrs[DEFAULT_ATTR_KEYS.MASK].to_list()\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.contract_nodes","title":"contract_nodes","text":"<pre><code>contract_nodes(permanent_node_ids: Sequence[int]) -&gt; GraphView\n</code></pre> <p>Contract the graph to only include the given <code>permanent_node_ids</code>. Predecessor and sucessors of removed nodes are connected during contraction.</p> <p>Example:</p> <pre><code>graph TD\n    A((t=0)) --&gt; B((t=1))\n    A --&gt; C((t=1))\n    B --&gt; D((t=2))\n    C --&gt; E((t=2))\n    C --&gt; F((t=2))</code></pre> <p>After contraction only keeping nodes in <code>t=0</code> and <code>t=2</code>: <pre><code>graph TD\n    A((t=0)) --&gt; B((t=2))\n    A --&gt; C((t=2))\n    A --&gt; D((t=2))</code></pre></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphView</code>           \u2013            <p>A view of the contracted graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def contract_nodes(\n    self,\n    permanent_node_ids: Sequence[int],\n) -&gt; \"GraphView\":\n    \"\"\"\n    Contract the graph to only include the given `permanent_node_ids`.\n    Predecessor and sucessors of removed nodes are connected during contraction.\n\n    Example:\n\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=1))\n        A --&gt; C((t=1))\n        B --&gt; D((t=2))\n        C --&gt; E((t=2))\n        C --&gt; F((t=2))\n    ```\n\n    After contraction only keeping nodes in `t=0` and `t=2`:\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=2))\n        A --&gt; C((t=2))\n        A --&gt; D((t=2))\n    ```\n\n    Parameters\n    ----------\n    permanent_node_ids : Sequence[int]\n        The node ids to keep in the contracted graph.\n\n    Returns\n    -------\n    GraphView\n        A view of the contracted graph.\n    \"\"\"\n    from tracksdata.graph._graph_view import GraphView\n\n    all_node_ids = np.asarray(self.node_ids())\n    selected_nodes_mask = np.isin(all_node_ids, permanent_node_ids)\n    missing_node_ids = all_node_ids[~selected_nodes_mask]\n\n    # must block multigraphs to avoid edge duplication\n    rx_graph = rx.PyDiGraph(multigraph=False)\n    new_indices = rx_graph.add_nodes_from(self.rx_graph.nodes())\n    rx_graph.add_edges_from(self.rx_graph.weighted_edge_list())\n\n    for node_id in missing_node_ids:\n        rx_graph.remove_node_retain_edges(\n            node_id,\n            use_outgoing=True,\n            condition=lambda *args: True,\n        )\n\n    node_map_to_root = dict(\n        zip(\n            np.asarray(new_indices)[selected_nodes_mask].tolist(),\n            permanent_node_ids,\n            strict=True,\n        )\n    )\n\n    # I'm a bit concerned with the internal booking of indices of rustworkx\n    # so I'm adding this sanity check\n    assert len(node_map_to_root) == rx_graph.num_nodes()\n\n    graph_view = GraphView(rx_graph, node_map_to_root=node_map_to_root, root=self)\n\n    return graph_view\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.contract_nodes(permanent_node_ids)","title":"<code>permanent_node_ids</code>","text":"(<code>Sequence[int]</code>)           \u2013            <p>The node ids to keep in the contracted graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; BaseGraph\n</code></pre> <p>Create a copy of this graph.</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A new graph instance with the same nodes, edges, and attributes as this graph.</p> </li> <li> <code>**kwargs</code> (              <code>Any</code> )          \u2013            <p>Additional arguments to pass to the graph constructor.</p> </li> </ul> <p>Examples:</p> <pre><code>copied_graph = graph.copy()\n</code></pre> See Also <p>from_other:     Create a graph from another graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def copy(self, **kwargs) -&gt; \"BaseGraph\":\n    \"\"\"\n    Create a copy of this graph.\n\n    Returns\n    -------\n    BaseGraph\n        A new graph instance with the same nodes, edges, and attributes as this graph.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    copied_graph = graph.copy()\n    ```\n\n    See Also\n    --------\n    [from_other][tracksdata.graph.BaseGraph.from_other]:\n        Create a graph from another graph.\n    \"\"\"\n    return self.__class__.from_other(self, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_attrs","title":"edge_attrs","text":"<pre><code>edge_attrs(*, attr_keys: Sequence[str] | str | None = None, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the edge attributes of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The edge attributes of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the edge attributes of the graph.\n\n    Parameters\n    ----------\n    attr_keys : Sequence[str] | str | None\n        The attributes to include in the subgraph.\n    unpack : bool\n        Whether to unpack the attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        The edge attributes of the graph.\n    \"\"\"\n    node_ids = self._get_local_ids()\n    df = super().filter(node_ids=node_ids).edge_attrs(attr_keys=attr_keys, unpack=unpack)\n    df = self._map_df_to_external(df, [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET])\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attributes to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack the attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_id","title":"edge_id","text":"<pre><code>edge_id(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Return the edge id between two nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_id(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Return the edge id between two nodes.\n    \"\"\"\n    source_id = self._map_to_local(source_id)\n    target_id = self._map_to_local(target_id)\n    return super().edge_id(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_ids","title":"edge_ids","text":"<pre><code>edge_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all edges in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all edges in the graph.\n    \"\"\"\n    return [int(i) for i in self.rx_graph.edge_indices()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(positions: ArrayLike, track_ids: ArrayLike | None = None, track_id_graph: dict[int, int] | None = None, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. track_ids : np.ndarray | None     Track ids of the nodes if available. track_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    track_ids: ArrayLike | None = None,\n    track_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    track_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    track_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import from_array\n\n    graph = cls(**kwargs)\n    from_array(\n        positions=np.asarray(positions),\n        graph=graph,\n        track_ids=track_ids,\n        track_id_graph=track_id_graph,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc--see-also","title":"See Also","text":"<p>from_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc--see-also_1","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [from_ctc][tracksdata.io._ctc.from_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n\n    See Also\n    --------\n    [to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import from_ctc\n\n    graph = cls(**kwargs)\n    from_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_geff","title":"from_geff  <code>classmethod</code>","text":"<pre><code>from_geff(geff_store: StoreLike, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a geff data directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>The loaded graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_geff(\n    cls: type[T],\n    geff_store: StoreLike,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to read the graph from.\n    **kwargs\n        Additional keyword arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    T\n        The loaded graph.\n    \"\"\"\n    from tracksdata.graph import IndexedRXGraph\n\n    # this performs a roundtrip with the rustworkx graph\n    rx_graph, _ = read_rx(geff_store)\n\n    if not isinstance(rx_graph, rx.PyDiGraph):\n        LOG.warning(\"The graph is not a directed graph, converting to directed graph.\")\n        rx_graph = rx_graph.to_directed()\n\n    indexed_graph = IndexedRXGraph(\n        rx_graph=rx_graph,\n        node_id_map=rx_graph.attrs[\"to_rx_id_map\"],\n        **kwargs,\n    )\n\n    if cls == IndexedRXGraph:\n        return indexed_graph\n\n    return cls.from_other(indexed_graph, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to read the graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_geff(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional keyword arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_other--parameters","title":"Parameters","text":"<p>other : BaseGraph     The other graph to create a new graph from. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_other--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the other graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            graph.add_node_attr_key(col, node_attrs[col].first())\n\n    if graph.supports_custom_indices:\n        new_node_ids = graph.bulk_add_nodes(\n            list(node_attrs.rows(named=True)),\n            indices=other_node_ids.to_list(),\n        )\n    else:\n        new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n        if other.supports_custom_indices:\n            LOG.warning(\n                f\"Other graph ({type(other).__name__}) supports custom indices, but this graph \"\n                f\"({type(graph).__name__}) does not, indexing automatically.\"\n            )\n\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.has_edge","title":"has_edge","text":"<pre><code>has_edge(source_id: int, target_id: int) -&gt; bool\n</code></pre> <p>Check if the graph has an edge between two nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_edge(self, source_id: int, target_id: int) -&gt; bool:\n    \"\"\"\n    Check if the graph has an edge between two nodes.\n    \"\"\"\n    try:\n        source_id = self._map_to_local(source_id)\n    except KeyError:\n        LOG.warning(f\"`source_id` {source_id} not found in index map.\")\n        return False\n\n    try:\n        target_id = self._map_to_local(target_id)\n    except KeyError:\n        LOG.warning(f\"`target_id` {target_id} not found in index map.\")\n        return False\n\n    return self.rx_graph.has_edge(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return len(self.overlaps()) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.in_degree","title":"in_degree","text":"<pre><code>in_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the in degree of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int] | int</code>           \u2013            <p>The in degree of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in degree of the graph.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    list[int] | int\n        The in degree of the graph.\n    \"\"\"\n    node_ids = self._get_local_ids() if node_ids is None else self._map_to_local(node_ids)\n    return super().in_degree(node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.in_degree(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.match","title":"match","text":"<pre><code>match(other: BaseGraph, matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID, match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE, matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.node_attrs","title":"node_attrs","text":"<pre><code>node_attrs(*, attr_keys: Sequence[str] | str | None = None, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the node attributes of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The node attributes of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def node_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the node attributes of the graph.\n\n    Parameters\n    ----------\n    attr_keys : Sequence[str] | str | None\n        The attributes to include in the subgraph.\n    unpack : bool\n        Whether to unpack the attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        The node attributes of the graph.\n    \"\"\"\n    node_ids = self._get_local_ids()\n    df = super()._node_attrs_from_node_ids(node_ids=node_ids, attr_keys=attr_keys, unpack=unpack)\n    df = self._map_df_to_external(df, [DEFAULT_ATTR_KEYS.NODE_ID])\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.node_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attributes to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.node_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack the attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.node_ids","title":"node_ids","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the node ids of the graph.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The node ids of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the node ids of the graph.\n\n    Returns\n    -------\n    list[int]\n        The node ids of the graph.\n    \"\"\"\n    return self._get_external_ids()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.out_degree","title":"out_degree","text":"<pre><code>out_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the out degree of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int] | int</code>           \u2013            <p>The out degree of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out degree of the graph.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    list[int] | int\n        The out degree of the graph.\n    \"\"\"\n    node_ids = self._get_local_ids() if node_ids is None else self._map_to_local(node_ids)\n    return super().out_degree(node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.out_degree(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(node_ids: list[int] | int | None = None) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def overlaps(self, node_ids: list[int] | int | None = None) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps of the graph.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps of the graph.\n    \"\"\"\n    try:\n        node_ids = self._get_local_ids() if node_ids is None else self._map_to_local(node_ids)\n    except KeyError:\n        LOG.warning(f\"`node_ids` {node_ids} not found in index map.\")\n        return []\n    overlaps = super().overlaps(node_ids)\n    # Convert each pair of node IDs in the overlaps list\n    if len(overlaps) &gt; 0:\n        overlaps = self._vectorized_map_to_external(np.asarray(overlaps)).tolist()\n    return overlaps\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.predecessors","title":"predecessors","text":"<pre><code>predecessors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>The predecessors of the nodes indexed by node ID if a list of nodes is provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the predecessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        The predecessors of the nodes indexed by node ID if a list of nodes is provided.\n    \"\"\"\n    return self._get_neighbors(\n        rx.PyDiGraph.predecessor_indices,\n        node_ids,\n        attr_keys,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the graph.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the node_id does not exist in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph.\n\n    Parameters\n    ----------\n    node_id : int\n        The external ID of the node to remove.\n\n    Raises\n    ------\n    ValueError\n        If the node_id does not exist in the graph.\n    \"\"\"\n    if node_id not in self._external_to_local:\n        raise ValueError(f\"Node {node_id} does not exist in the graph\")\n\n    local_node_id = self._map_to_local(node_id)\n    super().remove_node(local_node_id)\n    self._remove_id_mapping(external_id=node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The external ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.spatial_filter","title":"spatial_filter","text":"<pre><code>spatial_filter(attr_keys: list[str] | None = None) -&gt; SpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> <p>This method creates a spatial index of graph nodes based on their spatial coordinates, enabling efficient querying of nodes within spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for image coordinates:</p> <pre><code>spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n# Query nodes in region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n# Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>SpatialFilter:     The point spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def spatial_filter(self, attr_keys: list[str] | None = None) -&gt; \"SpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes.\n\n    This method creates a spatial index of graph nodes based on their spatial coordinates,\n    enabling efficient querying of nodes within spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    attr_keys : list[str] | None, optional\n        List of attribute keys to use as spatial coordinates. If None, defaults to\n        [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.\n        Common combinations include:\n        - 2D: [\"y\", \"x\"]\n        - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"]\n        - 4D: [\"t\", \"z\", \"y\", \"x\"]\n\n    Returns\n    -------\n    SpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for image coordinates:\n\n    ```python\n    spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n    # Query nodes in region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n    # Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [SpatialFilter][tracksdata.graph.filters.SpatialFilter]:\n        The point spatial filter query class.\n\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import SpatialFilter\n\n    return SpatialFilter(self, attr_keys=attr_keys)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.spatial_filter(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute keys to use as spatial coordinates. If None, defaults to [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph. Common combinations include: - 2D: [\"y\", \"x\"] - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"] - 4D: [\"t\", \"z\", \"y\", \"x\"]</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.successors","title":"successors","text":"<pre><code>successors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the sucessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>The sucessors of the nodes indexed by node ID if a list of nodes is provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the sucessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the sucessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        The sucessors of the nodes indexed by node ID if a list of nodes is provided.\n    \"\"\"\n    return self._get_neighbors(\n        rx.PyDiGraph.successor_indices,\n        node_ids,\n        attr_keys,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the sucessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.summary","title":"summary","text":"<pre><code>summary(attrs_stats: bool = False, print_summary: bool = True) -&gt; str\n</code></pre> <p>Print a summary of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string with the summary of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def summary(\n    self,\n    attrs_stats: bool = False,\n    print_summary: bool = True,\n) -&gt; str:\n    \"\"\"\n    Print a summary of the graph.\n\n    Parameters\n    ----------\n    attrs_stats : bool\n        If true it will print statistics about the attributes of the nodes and edges.\n    print_summary : bool\n        If true it will print the summary of the graph.\n\n    Returns\n    -------\n    str\n        A string with the summary of the graph.\n    \"\"\"\n    summary = \"\"\n\n    summary += \"Graph summary:\\n\"\n    summary += f\"Number of nodes: {self.num_nodes}\\n\"\n    summary += f\"Number of edges: {self.num_edges}\\n\"\n    summary += f\"Number of overlaps: {len(self.overlaps())}\\n\"\n\n    time_points = self.time_points()\n    summary += f\"Number of distinct time points: {len(time_points)}\\n\"\n    if len(time_points) &gt; 0:\n        summary += f\"Start time: {min(time_points)}\\n\"\n        summary += f\"End time: {max(time_points)}\\n\"\n    else:\n        summary += \"No time points found.\\n\"\n\n    if attrs_stats:\n        nodes_attrs = self.node_attrs()\n        edges_attrs = self.edge_attrs()\n        summary += \"\\nNodes attributes:\\n\"\n        summary += str(nodes_attrs.describe())\n        summary += \"\\nEdges attributes:\\n\"\n        summary += str(edges_attrs.describe())\n\n    if print_summary:\n        print(summary)\n\n    return summary\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.summary(attrs_stats)","title":"<code>attrs_stats</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true it will print statistics about the attributes of the nodes and edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.summary(print_summary)","title":"<code>print_summary</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true it will print the summary of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.time_points","title":"time_points","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n    return list(self._time_to_nodes.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(shape: tuple[int, ...], output_dir: str | Path, track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, overwrite: bool = False) -&gt; None\n</code></pre> <p>Save the graph to a CTC ground truth directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_ctc--parameters","title":"Parameters","text":"<p>shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X) output_dir : str | Path     The directory to save the graph to. track_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_ctc--examples","title":"Examples","text":"<pre><code># ...\nsolution_graph = solver.solve(graph)\nsolution_graph.assign_track_ids()\nsolution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_ctc--see-also","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_ctc(\n    self,\n    shape: tuple[int, ...],\n    output_dir: str | Path,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save the graph to a CTC ground truth directory.\n\n    Parameters\n    ----------\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X)\n    output_dir : str | Path\n        The directory to save the graph to.\n    track_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    Examples\n    --------\n    ```python\n    # ...\n    solution_graph = solver.solve(graph)\n    solution_graph.assign_track_ids()\n    solution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n    ```\n\n    See Also\n    --------\n    [to_ctc][tracksdata.io.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import to_ctc\n\n    to_ctc(\n        graph=self,\n        shape=shape,\n        output_dir=output_dir,\n        track_id_key=track_id_key,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_geff","title":"to_geff","text":"<pre><code>to_geff(geff_store: StoreLike, geff_metadata: GeffMetadata | None = None, zarr_format: Literal[2, 3] = 3) -&gt; None\n</code></pre> <p>Write the graph to a geff data directory.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_geff(\n    self,\n    geff_store: StoreLike,\n    geff_metadata: GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None:\n    \"\"\"\n    Write the graph to a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to write the graph to.\n    geff_metadata : GeffMetadata | None\n        The geff metadata to write to the graph.\n        It automatically generates the metadata with:\n        - axes: time (t) and spatial axes ((z), y, x)\n        - tracklet node property: track_id\n    zarr_format : Literal[2, 3]\n        The zarr format to write the graph to.\n        Defaults to 3.\n    \"\"\"\n\n    node_attrs = self.node_attrs()\n\n    if DEFAULT_ATTR_KEYS.MASK in node_attrs.columns:\n        node_attrs = column_to_bytes(node_attrs, DEFAULT_ATTR_KEYS.MASK)\n\n    if geff_metadata is None:\n        axes = [Axis(name=DEFAULT_ATTR_KEYS.T, type=\"time\")]\n        axes.extend([Axis(name=c, type=\"space\") for c in (\"z\", \"y\", \"x\") if c in node_attrs.columns])\n\n        if DEFAULT_ATTR_KEYS.TRACK_ID in node_attrs.columns:\n            track_node_props = {\n                \"tracklet\": DEFAULT_ATTR_KEYS.TRACK_ID,\n            }\n        else:\n            track_node_props = None\n\n        geff_metadata = GeffMetadata(\n            directed=True,\n            axes=axes,\n            track_node_props=track_node_props,\n        )\n\n    edge_attrs = self.edge_attrs().drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    node_dict = {\n        k: (column_to_numpy(v), None) for k, v in node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID).to_dict().items()\n    }\n\n    edge_ids = edge_attrs.select(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET).to_numpy()\n\n    edge_dict = {\n        k: (column_to_numpy(v), None)\n        for k, v in edge_attrs.drop(\n            DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n            DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        )\n        .to_dict()\n        .items()\n    }\n\n    write_arrays(\n        geff_store,\n        metadata=geff_metadata,\n        node_ids=node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy(),\n        node_props=node_dict,\n        edge_ids=edge_ids,\n        edge_props=edge_dict,\n        zarr_format=zarr_format,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to write the graph to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_geff(geff_metadata)","title":"<code>geff_metadata</code>","text":"(<code>GeffMetadata | None</code>, default:                   <code>None</code> )           \u2013            <p>The geff metadata to write to the graph. It automatically generates the metadata with: - axes: time (t) and spatial axes ((z), y, x) - tracklet node property: track_id</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_geff(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The zarr format to write the graph to. Defaults to 3.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.tracklet_graph","title":"tracklet_graph","text":"<pre><code>tracklet_graph(track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, ignore_track_id: int | None = None) -&gt; rx.PyDiGraph\n</code></pre> <p>Create a compressed tracklet graph where each node is a tracklet and each edge is a transition between tracklets.</p> <p>IMPORTANT: rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values. And edge values are the tuple of source and target tracklet ids.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed tracklet graph.</p> </li> </ul> See Also <p>rx_digraph_to_napari_dict:     Convert a tracklet graph to a napari-ready dictionary.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_graph(\n    self,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    ignore_track_id: int | None = None,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Create a compressed tracklet graph where each node is a tracklet\n    and each edge is a transition between tracklets.\n\n    IMPORTANT:\n    rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values.\n    And edge values are the tuple of source and target tracklet ids.\n\n    Parameters\n    ----------\n    track_id_key : str\n        The key of the track id attribute.\n    ignore_track_id : int | None\n        The track id to ignore. If None, all track ids are used.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed tracklet graph.\n\n    See Also\n    --------\n    [rx_digraph_to_napari_dict][tracksdata.functional.rx_digraph_to_napari_dict]:\n        Convert a tracklet graph to a napari-ready dictionary.\n    \"\"\"\n\n    if track_id_key not in self.node_attr_keys:\n        raise ValueError(f\"Track id key '{track_id_key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n    nodes_df = self.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, track_id_key])\n    edges_df = self.edge_attrs(attr_keys=[])\n\n    if ignore_track_id is not None:\n        nodes_df = nodes_df.filter(pl.col(track_id_key) != ignore_track_id)\n\n    nodes_df = nodes_df.unique(subset=[track_id_key])\n\n    graph = rx.PyDiGraph()\n    nodes_df = nodes_df.with_columns(\n        pl.Series(\n            np.asarray(graph.add_nodes_from(nodes_df[track_id_key].to_list()), dtype=int),\n        ).alias(\"rx_id\"),\n    )\n\n    edges_df = (\n        edges_df.join(\n            nodes_df.rename({track_id_key: \"source_track_id\", \"rx_id\": \"source_rx_id\"}),\n            left_on=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n            right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n            how=\"right\",\n        )\n        .join(\n            nodes_df.rename({track_id_key: \"target_track_id\", \"rx_id\": \"target_rx_id\"}),\n            left_on=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n            right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n            how=\"right\",\n        )\n        .filter(~pl.col(DEFAULT_ATTR_KEYS.EDGE_ID).is_null())\n    )\n\n    graph.add_edges_from(\n        zip(\n            edges_df[\"source_rx_id\"].to_list(),\n            edges_df[\"target_rx_id\"].to_list(),\n            zip(edges_df[\"source_track_id\"].to_list(), edges_df[\"target_track_id\"].to_list(), strict=False),\n            strict=True,\n        )\n    )\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.tracklet_graph(track_id_key)","title":"<code>track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.tracklet_graph(ignore_track_id)","title":"<code>ignore_track_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The track id to ignore. If None, all track ids are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_edge_attrs","title":"update_edge_attrs","text":"<pre><code>update_edge_attrs(*, attrs: dict[str, Any], edge_ids: Sequence[int] | None = None) -&gt; None\n</code></pre> <p>Update the attributes of the edges.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def update_edge_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the edges.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        Attributes to be updated.\n    edge_ids : Sequence[int] | None\n        The IDs of the edges to update or None to update all edges.\n    \"\"\"\n    if edge_ids is None:\n        edge_ids = self.edge_ids()\n\n    size = len(edge_ids)\n    for key, value in attrs.items():\n        if key not in self.edge_attr_keys:\n            raise ValueError(f\"Edge attribute key '{key}' not found in graph. Expected '{self.edge_attr_keys}'\")\n\n        if np.isscalar(value):\n            attrs[key] = [value] * size\n\n        elif len(attrs[key]) != size:\n            raise ValueError(f\"Attribute '{key}' has wrong size. Expected {size}, got {len(attrs[key])}\")\n\n    edge_map = self._graph.edge_index_map()\n\n    for i, edge_id in enumerate(edge_ids):\n        edge_attr = edge_map[edge_id][2]  # 0=source, 1=target, 2=attributes\n        for key, value in attrs.items():\n            edge_attr[key] = value[i]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_edge_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Attributes to be updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_edge_attrs(edge_ids)","title":"<code>edge_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the edges to update or None to update all edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_node_attrs","title":"update_node_attrs","text":"<pre><code>update_node_attrs(*, attrs: dict[str, Any], node_ids: Sequence[int] | None = None) -&gt; None\n</code></pre> <p>Update the node attributes of the graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def update_node_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the node attributes of the graph.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to update.\n    node_ids : Sequence[int] | None\n        The node ids to update.\n    \"\"\"\n    node_ids = self._get_local_ids() if node_ids is None else self._map_to_local(node_ids)\n    super().update_node_attrs(attrs=attrs, node_ids=node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_node_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to update.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_node_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to update.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph","title":"RustWorkXGraph","text":"<pre><code>RustWorkXGraph(rx_graph: PyDiGraph | None = None)\n</code></pre> <p>               Bases: <code>BaseGraph</code></p> <p>High-performance in-memory graph implementation using rustworkx.</p> <p>RustWorkXGraph provides a fast, memory-efficient graph backend built on rustworkx (a Rust-based graph library). It stores nodes and edges in memory with their attributes, making it suitable for moderate-sized graphs that fit in RAM. This implementation offers excellent performance for graph algorithms and is the recommended choice for most tracking applications.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--parameters","title":"Parameters","text":"<p>rx_graph : rx.PyDiGraph | None, optional     An existing rustworkx directed graph to wrap. If None, creates a new     empty graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--attributes","title":"Attributes","text":"<p>rx_graph : rx.PyDiGraph     The underlying rustworkx directed graph object. _time_to_nodes : dict[int, list[int]]     Mapping from time points to lists of node IDs at that time. _node_attr_keys : list[str]     List of available node attribute keys. _edge_attr_keys : list[str]     List of available edge attribute keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--see-also","title":"See Also","text":"<p>SQLGraph:     Database-backed graph implementation for larger datasets.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--examples","title":"Examples","text":"<p>Create an empty graph:</p> <pre><code>from tracksdata.graph import RustWorkXGraph\n\ngraph = RustWorkXGraph()\n</code></pre> <p>Add nodes and edges:</p> <pre><code>node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\nedge_id = graph.add_edge(source_id, target_id, {\"weight\": 0.8})\n</code></pre> <p>Filter nodes by attributes:</p> <pre><code>from tracksdata.attrs import NodeAttr\n\nnode_ids = graph.filter(NodeAttr(\"t\") == 0).node_ids()\n</code></pre> <p>Create subgraphs:</p> <pre><code>subgraph = graph.filter(NodeAttr(\"t\") == 0).subgraph()\n</code></pre> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Helper method to interact with a single node.</p> </li> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edge_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph at time t.</p> </li> <li> <code>add_node_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>assign_track_ids</code>             \u2013              <p>Compute and assign track ids to nodes.</p> </li> <li> <code>bbox_spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>contract_nodes</code>             \u2013              <p>Contract the graph to only include the given <code>permanent_node_ids</code>.</p> </li> <li> <code>copy</code>             \u2013              <p>Create a copy of this graph.</p> </li> <li> <code>edge_attrs</code>             \u2013              <p>Get the attributes of the edges as a polars DataFrame.</p> </li> <li> <code>edge_id</code>             \u2013              <p>Return the edge id between two nodes.</p> </li> <li> <code>edge_ids</code>             \u2013              <p>Get the IDs of all edges in the graph.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_geff</code>             \u2013              <p>Create a graph from a geff data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_edge</code>             \u2013              <p>Check if the graph has an edge between two nodes.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_attrs</code>             \u2013              <p>Get the attributes of the nodes as a polars DataFrame.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the IDs of all nodes in the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessors of a list of nodes.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a node from the graph.</p> </li> <li> <code>spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> </li> <li> <code>successors</code>             \u2013              <p>Get the sucessors of a list of nodes.</p> </li> <li> <code>summary</code>             \u2013              <p>Print a summary of the graph.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save the graph to a CTC ground truth directory.</p> </li> <li> <code>to_geff</code>             \u2013              <p>Write the graph to a geff data directory.</p> </li> <li> <code>tracklet_graph</code>             \u2013              <p>Create a compressed tracklet graph where each node is a tracklet</p> </li> <li> <code>update_edge_attrs</code>             \u2013              <p>Update the attributes of the edges.</p> </li> <li> <code>update_node_attrs</code>             \u2013              <p>Update the attributes of the nodes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the edges.</p> </li> <li> <code>node_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the nodes.</p> </li> <li> <code>num_edges</code>               (<code>int</code>)           \u2013            <p>The number of edges in the graph.</p> </li> <li> <code>num_nodes</code>               (<code>int</code>)           \u2013            <p>The number of nodes in the graph.</p> </li> <li> <code>supports_custom_indices</code>               (<code>bool</code>)           \u2013            <p>Whether the graph backend supports custom indices.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def __init__(self, rx_graph: rx.PyDiGraph | None = None) -&gt; None:\n    super().__init__()\n\n    self._time_to_nodes: dict[int, list[int]] = {}\n    self._node_attr_keys: list[str] = []\n    self._edge_attr_keys: list[str] = []\n    self._overlaps: list[list[int, 2]] = []\n\n    if rx_graph is None:\n        self._graph = rx.PyDiGraph()\n        self._node_attr_keys.append(DEFAULT_ATTR_KEYS.T)\n\n    else:\n        self._graph = rx_graph\n\n        unique_node_attr_keys = set()\n        unique_edge_attr_keys = set()\n\n        for node_id in self._graph.node_indices():\n            node_attrs = self._graph[node_id]\n            try:\n                t = node_attrs[DEFAULT_ATTR_KEYS.T]\n            except KeyError as e:\n                raise ValueError(\n                    f\"Node attributes must have a '{DEFAULT_ATTR_KEYS.T}' key. Got {node_attrs.keys()}\"\n                ) from e\n\n            self._time_to_nodes.setdefault(int(t), []).append(node_id)\n\n            unique_node_attr_keys.update(node_attrs.keys())\n\n        edge_idx_map = self._graph.edge_index_map()\n        for edge_idx, (_, _, attr) in edge_idx_map.items():\n            unique_edge_attr_keys.update(attr.keys())\n            attr[DEFAULT_ATTR_KEYS.EDGE_ID] = edge_idx\n\n        self._node_attr_keys = list(unique_node_attr_keys)\n        self._edge_attr_keys = list(unique_edge_attr_keys)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attr_keys","title":"edge_attr_keys  <code>property</code>","text":"<pre><code>edge_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_attr_keys","title":"node_attr_keys  <code>property</code>","text":"<pre><code>node_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.num_edges","title":"num_edges  <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.supports_custom_indices","title":"supports_custom_indices  <code>property</code>","text":"<pre><code>supports_custom_indices: bool\n</code></pre> <p>Whether the graph backend supports custom indices.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(node_id: int) -&gt; NodeInterface\n</code></pre> <p>Helper method to interact with a single node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NodeInterface</code>           \u2013            <p>A node interface for the given node id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def __getitem__(self, node_id: int) -&gt; \"NodeInterface\":\n    \"\"\"\n    Helper method to interact with a single node.\n\n    Parameters\n    ----------\n    node_id : int\n        The id of the node to interact with.\n\n    Returns\n    -------\n    NodeInterface\n        A node interface for the given node id.\n    \"\"\"\n\n    if not isinstance(node_id, int):\n        raise ValueError(f\"graph index must be a integer, found '{node_id}' of type {type(node_id)}\")\n    return NodeInterface(self, node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.__getitem__(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The id of the node to interact with.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._filter_nodes_by_attrs","title":"_filter_nodes_by_attrs","text":"<pre><code>_filter_nodes_by_attrs(*attrs: AttrComparison, node_ids: Sequence[int] | None = None) -&gt; list[int]\n</code></pre> <p>Filter nodes by attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the filtered nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _filter_nodes_by_attrs(\n    self,\n    *attrs: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Filter nodes by attributes.\n\n    Parameters\n    ----------\n    *attrs : AttrComparison\n        The attributes to filter by, for example:\n    node_ids : list[int] | None\n        The IDs of the nodes to include in the filter.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the filtered nodes.\n    \"\"\"\n    rx_graph = self.rx_graph\n    node_map = None\n    # entire graph\n    attrs, time = _pop_time_eq(attrs)\n    selected_nodes = None\n\n    if time is not None:\n        selected_nodes = self._time_to_nodes.get(time, [])\n\n        if node_ids is not None:\n            selected_nodes = np.intersect1d(selected_nodes, node_ids).tolist()\n\n        if len(attrs) == 0:\n            return selected_nodes\n\n    elif node_ids is not None:\n        selected_nodes = node_ids\n\n    if selected_nodes is not None:\n        # subgraph of selected nodes\n        rx_graph, node_map = rx_graph.subgraph_with_nodemap(selected_nodes)\n\n    _filter_func = _create_filter_func(attrs)\n\n    if node_map is None:\n        return list(rx_graph.filter_nodes(_filter_func))\n    else:\n        return [node_map[n] for n in rx_graph.filter_nodes(_filter_func)]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._filter_nodes_by_attrs(*attrs)","title":"<code>*attrs</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter by, for example:</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._filter_nodes_by_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to include in the filter. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._get_neighbors","title":"_get_neighbors","text":"<pre><code>_get_neighbors(neighbors_func: Callable[[PyDiGraph, int], NodeIndices], node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessors or sucessors of a list of nodes. See more information below.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _get_neighbors(\n    self,\n    neighbors_func: Callable[[rx.PyDiGraph, int], rx.NodeIndices],\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessors or sucessors of a list of nodes.\n    See more information below.\n    \"\"\"\n    single_node = False\n    if isinstance(node_ids, int):\n        node_ids = [node_ids]\n        single_node = True\n\n    if isinstance(attr_keys, str):\n        attr_keys = [attr_keys]\n\n    rx_graph = self.rx_graph\n    valid_schema = None\n\n    neighbors = {}\n    for node_id in node_ids:\n        neighbors_indices = neighbors_func(rx_graph, node_id)\n        neighbors_data: list[dict[str, Any]] = [rx_graph[i] for i in neighbors_indices]\n\n        if attr_keys is not None:\n            neighbors_data = [\n                {k: edge_data[k] for k in attr_keys if k != DEFAULT_ATTR_KEYS.NODE_ID}\n                for edge_data in neighbors_data\n            ]\n\n        if len(neighbors_data) &gt; 0:\n            df = pl.DataFrame(neighbors_data)\n            if attr_keys is None or DEFAULT_ATTR_KEYS.NODE_ID in attr_keys:\n                df = df.with_columns(\n                    pl.Series(DEFAULT_ATTR_KEYS.NODE_ID, np.asarray(neighbors_indices, dtype=int)),\n                )\n            neighbors[node_id] = df\n            valid_schema = neighbors[node_id].schema\n\n    if single_node:\n        try:\n            # could not find sucessors for this node\n            return neighbors[node_ids[0]]\n        except KeyError:\n            return pl.DataFrame()\n\n    for node_id in node_ids:\n        if node_id not in neighbors:\n            if valid_schema is None:\n                neighbors[node_id] = pl.DataFrame()\n            else:\n                neighbors[node_id] = pl.DataFrame(schema=valid_schema)\n\n    return neighbors\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._node_attrs_from_node_ids","title":"_node_attrs_from_node_ids","text":"<pre><code>_node_attrs_from_node_ids(*, node_ids: list[int] | None = None, attr_keys: Sequence[str] | str | None = None, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the nodes as a polars DataFrame.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A polars DataFrame with the attributes of the nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _node_attrs_from_node_ids(\n    self,\n    *,\n    node_ids: list[int] | None = None,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the nodes as a polars DataFrame.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the attributesfor.\n        If None, all nodes are used.\n    attr_keys : Sequence[str] | None\n        The attribute keys to get.\n        If None, all the attributes of the first node are used.\n    unpack : bool\n        Whether to unpack array attributesinto multiple scalar attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        A polars DataFrame with the attributes of the nodes.\n    \"\"\"\n    rx_graph = self.rx_graph\n    # If no node_ids provided, use all nodes\n    if node_ids is None:\n        node_ids = list(rx_graph.node_indices())\n\n    if attr_keys is None:\n        attr_keys = [DEFAULT_ATTR_KEYS.NODE_ID, *self.node_attr_keys]\n\n    if isinstance(attr_keys, str):\n        attr_keys = [attr_keys]\n\n    if len(node_ids) == 0:\n        return pl.DataFrame({key: [] for key in attr_keys})\n\n    # making them unique\n    attr_keys = list(dict.fromkeys(attr_keys))\n\n    # Create columns directly instead of building intermediate dictionaries\n    columns = {key: [] for key in attr_keys}\n\n    if DEFAULT_ATTR_KEYS.NODE_ID in attr_keys:\n        columns[DEFAULT_ATTR_KEYS.NODE_ID] = np.asarray(node_ids, dtype=int)\n        attr_keys.remove(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    # Build columns in a vectorized way\n    for node_id in node_ids:\n        node_data = rx_graph[node_id]\n        for key in attr_keys:\n            columns[key].append(node_data[key])\n\n    for key in attr_keys:\n        columns[key] = np.asarray(columns[key])\n\n    # Create DataFrame and set node_id as index in one shot\n    df = pl.DataFrame(columns)\n\n    if unpack:\n        df = unpack_array_attrs(df)\n\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._node_attrs_from_node_ids(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the attributesfor. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._node_attrs_from_node_ids(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all the attributes of the first node are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._node_attrs_from_node_ids(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributesinto multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._rx_subgraph_with_nodemap","title":"_rx_subgraph_with_nodemap","text":"<pre><code>_rx_subgraph_with_nodemap(node_ids: Sequence[int] | None = None) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]\n</code></pre> <p>Get a subgraph of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[PyDiGraph, NodeMap]</code>           \u2013            <p>The subgraph and the node map.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _rx_subgraph_with_nodemap(\n    self,\n    node_ids: Sequence[int] | None = None,\n) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]:\n    \"\"\"\n    Get a subgraph of the graph.\n\n    Parameters\n    ----------\n    node_ids : Sequence[int] | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    tuple[rx.PyDiGraph, rx.NodeMap]\n        The subgraph and the node map.\n    \"\"\"\n    rx_graph, node_map = self.rx_graph.subgraph_with_nodemap(node_ids)\n    return rx_graph, node_map\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._rx_subgraph_with_nodemap(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(attrs: dict[str, Any], reference_keys: list[str], mode: str) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys():\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(source_id: int, target_id: int, attrs: dict[str, Any], validate_keys: bool = True) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n    attrs : dict[str, Any]\n        The attributes of the edge to be added.\n        The keys of the attributes will be used as the attributes of the edge.\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n    \"\"\"\n    if validate_keys:\n        self._validate_attributes(attrs, self.edge_attr_keys, \"edge\")\n    edge_id = self.rx_graph.add_edge(source_id, target_id, attrs)\n    attrs[DEFAULT_ATTR_KEYS.EDGE_ID] = edge_id\n    return edge_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the edge to be added. The keys of the attributes will be used as the attributes of the edge.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge_attr_key","title":"add_edge_attr_key","text":"<pre><code>add_edge_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing edges will have the default value for the new attribute key.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_edge_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing edges will have the default value for the new attribute key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the new attribute.\n    default_value : Any\n        The default value for existing edges for the new attribute key.\n    \"\"\"\n    if key in self.edge_attr_keys:\n        raise ValueError(f\"Attribute key {key} already exists\")\n\n    self._edge_attr_keys.append(key)\n    for _, _, edge_attr in self.rx_graph.weighted_edge_list():\n        edge_attr[key] = default_value\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge_attr_key(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the new attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge_attr_key(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>)           \u2013            <p>The default value for existing edges for the new attribute key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node","title":"add_node","text":"<pre><code>add_node(attrs: dict[str, Any], validate_keys: bool = True, index: int | None = None) -&gt; int\n</code></pre> <p>Add a node to the graph at time t.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph at time t.\n\n    Parameters\n    ----------\n    attrs : Any\n        The attributes of the node to be added, must have a \"t\" key.\n        The keys of the attributes will be used as the attributes of the node.\n        For example:\n        ```python\n        graph.add_node(dict(t=0, label=\"A\", intensity=100))\n        ```\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n    index : int | None\n        Optional node index. RustWorkXGraph does not support custom indices\n        and will raise an error if this parameter is provided.\n    \"\"\"\n    if index is not None:\n        raise ValueError(\"RustWorkXGraph does not support custom node indices. Use IndexedRXGraph instead.\")\n\n    # avoiding copying attributes on purpose, it could be a problem in the future\n    if validate_keys:\n        self._validate_attributes(attrs, self.node_attr_keys, \"node\")\n\n        if \"t\" not in attrs:\n            raise ValueError(f\"Node attributes must have a 't' key. Got {attrs.keys()}\")\n\n    node_id = self.rx_graph.add_node(attrs)\n    self._time_to_nodes.setdefault(attrs[\"t\"], []).append(node_id)\n    return node_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>Any</code>)           \u2013            <p>The attributes of the node to be added, must have a \"t\" key. The keys of the attributes will be used as the attributes of the node. For example: <pre><code>graph.add_node(dict(t=0, label=\"A\", intensity=100))\n</code></pre></p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node(index)","title":"<code>index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional node index. RustWorkXGraph does not support custom indices and will raise an error if this parameter is provided.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node_attr_key","title":"add_node_attr_key","text":"<pre><code>add_node_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing nodes will have the default value for the new attribute key.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_node_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing nodes will have the default value for the new attribute key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the new attribute.\n    default_value : Any\n        The default value for existing nodes for the new attribute key.\n    \"\"\"\n    if key in self.node_attr_keys:\n        raise ValueError(f\"Attribute key {key} already exists\")\n\n    self._node_attr_keys.append(key)\n    rx_graph = self.rx_graph\n    for node_id in rx_graph.node_indices():\n        rx_graph[node_id][key] = default_value\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node_attr_key(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the new attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node_attr_key(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>)           \u2013            <p>The default value for existing nodes for the new attribute key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the added overlap.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    self._overlaps.append([source_id, target_id])\n    return len(self._overlaps) - 1\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_overlap(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_overlap(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.assign_track_ids","title":"assign_track_ids","text":"<pre><code>assign_track_ids(output_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, reset: bool = True, track_id_offset: int = 1) -&gt; rx.PyDiGraph\n</code></pre> <p>Compute and assign track ids to nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed graph (parent -&gt; child) with track ids lineage relationships.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def assign_track_ids(\n    self,\n    output_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    reset: bool = True,\n    track_id_offset: int = 1,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Compute and assign track ids to nodes.\n\n    Parameters\n    ----------\n    output_key : str\n        The key of the output track id attribute.\n    reset : bool\n        Whether to reset the track ids of the graph. If True, the track ids will be reset to -1.\n    track_id_offset : int\n        The starting track id, useful when assigning track ids to a subgraph.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed graph (parent -&gt; child) with track ids lineage relationships.\n    \"\"\"\n    try:\n        node_ids, track_ids, tracks_graph = _assign_track_ids(self.rx_graph, track_id_offset)\n    except RuntimeError as e:\n        raise RuntimeError(\n            \"Are you sure this graph is a valid lineage graph?\\n\"\n            \"This function expects a solved graph.\\n\"\n            \"Often used from `graph.subgraph(edge_attr_filter={'solution': True})`\"\n        ) from e\n\n    if output_key not in self.node_attr_keys:\n        self.add_node_attr_key(output_key, -1)\n    elif reset:\n        self.update_node_attrs(node_ids=self.node_ids(), attrs={output_key: -1})\n\n    # node_ids are rustworkx graph ids, therefore we don't need node_id mapping\n    # and we must use RustWorkXGraph for IndexedRXGraph\n    RustWorkXGraph.update_node_attrs(\n        self,\n        node_ids=node_ids,\n        attrs={output_key: track_ids},\n    )\n\n    return tracks_graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.assign_track_ids(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the output track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.assign_track_ids(reset)","title":"<code>reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset the track ids of the graph. If True, the track ids will be reset to -1.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.assign_track_ids(track_id_offset)","title":"<code>track_id_offset</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The starting track id, useful when assigning track ids to a subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bbox_spatial_filter","title":"bbox_spatial_filter","text":"<pre><code>bbox_spatial_filter(frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T, bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX) -&gt; BBoxSpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> <p>This method creates a spatial index of graph nodes based on their bounding box coordinates, enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for bounding boxes:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n# Query nodes intersecting with region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter()\n# Uses default [\"t\", \"bbox\"]\n# Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>BBoxSpatialFilter:     The bounding box spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bbox_spatial_filter(\n    self,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n) -&gt; \"BBoxSpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.\n\n    This method creates a spatial index of graph nodes based on their bounding box coordinates,\n    enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    frame_attr_key : str | None\n        The attribute key for the frame (time) coordinate.\n        Default is `DEFAULT_ATTR_KEYS.T`.\n        If None it will only use the bounding box coordinates.\n    bbox_attr_key : str\n        The attribute key for the bounding box coordinates.\n        Defaults to `DEFAULT_ATTR_KEYS.BBOX`.\n        The bounding box coordinates should be in the format:\n        [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]\n        where each dimension has a min and max value.\n\n    Returns\n    -------\n    BBoxSpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for bounding boxes:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n    # Query nodes intersecting with region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter()\n    # Uses default [\"t\", \"bbox\"]\n    # Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [BBoxSpatialFilter][tracksdata.graph.filters.BBoxSpatialFilter]:\n        The bounding box spatial filter query class.\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import BBoxSpatialFilter\n\n    return BBoxSpatialFilter(self, frame_attr_key=frame_attr_key, bbox_attr_key=bbox_attr_key)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bbox_spatial_filter(frame_attr_key)","title":"<code>frame_attr_key</code>","text":"(<code>str | None</code>, default:                   <code>T</code> )           \u2013            <p>The attribute key for the frame (time) coordinate. Default is <code>DEFAULT_ATTR_KEYS.T</code>. If None it will only use the bounding box coordinates.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bbox_spatial_filter(bbox_attr_key)","title":"<code>bbox_attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key for the bounding box coordinates. Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>. The bounding box coordinates should be in the format: [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...] where each dimension has a min and max value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None\n</code></pre> <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int] | None</code>           \u2013            <p>The IDs of the added edges.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def bulk_add_edges(self, edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None:\n    \"\"\"\n    Faster method to add multiple edges to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        The data of the edges to be added.\n        The keys of the data will be used as the attributes of the edges.\n        Must have \"source_id\" and \"target_id\" keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Returns\n    -------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    # saving for historical reasons, iterating over edges is faster than using rx.add_edges_from\n    # edges_data = [(d.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE), d.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET), d) for d in edges]\n    # indices = self.rx_graph.add_edges_from(edges_data)\n    # for i, d in zip(indices, edges, strict=True):\n    #     d[DEFAULT_ATTR_KEYS.EDGE_ID] = i\n    # return indices\n    return super().bulk_add_edges(edges, return_ids=return_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the edges to be added. The keys of the data will be used as the attributes of the edges. Must have \"source_id\" and \"target_id\" keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(nodes: list[dict[str, Any]], indices: list[int] | None = None) -&gt; list[int]\n</code></pre> <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the added nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def bulk_add_nodes(self, nodes: list[dict[str, Any]], indices: list[int] | None = None) -&gt; list[int]:\n    \"\"\"\n    Faster method to add multiple nodes to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        The data of the nodes to be added.\n        The keys of the data will be used as the attributes of the nodes.\n        Must have \"t\" key.\n    indices : list[int] | None\n        Optional list of node indices. RustWorkXGraph does not support custom indices\n        and will raise an error if this parameter is provided.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the added nodes.\n    \"\"\"\n    if indices is not None:\n        raise ValueError(\"RustWorkXGraph does not support custom node indices. Use IndexedRXGraph instead.\")\n\n    node_indices = list(self.rx_graph.add_nodes_from(nodes))\n    for node, index in zip(nodes, node_indices, strict=True):\n        self._time_to_nodes.setdefault(node[\"t\"], []).append(index)\n    return node_indices\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the nodes to be added. The keys of the data will be used as the attributes of the nodes. Must have \"t\" key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_nodes(indices)","title":"<code>indices</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of node indices. RustWorkXGraph does not support custom indices and will raise an error if this parameter is provided.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.BaseGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    for source_id, target_id in overlaps:\n        self.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_attrs = self.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t).node_attrs(\n            attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MASK],\n        )\n        node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        masks = node_attrs[DEFAULT_ATTR_KEYS.MASK].to_list()\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.contract_nodes","title":"contract_nodes","text":"<pre><code>contract_nodes(permanent_node_ids: Sequence[int]) -&gt; GraphView\n</code></pre> <p>Contract the graph to only include the given <code>permanent_node_ids</code>. Predecessor and sucessors of removed nodes are connected during contraction.</p> <p>Example:</p> <pre><code>graph TD\n    A((t=0)) --&gt; B((t=1))\n    A --&gt; C((t=1))\n    B --&gt; D((t=2))\n    C --&gt; E((t=2))\n    C --&gt; F((t=2))</code></pre> <p>After contraction only keeping nodes in <code>t=0</code> and <code>t=2</code>: <pre><code>graph TD\n    A((t=0)) --&gt; B((t=2))\n    A --&gt; C((t=2))\n    A --&gt; D((t=2))</code></pre></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphView</code>           \u2013            <p>A view of the contracted graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def contract_nodes(\n    self,\n    permanent_node_ids: Sequence[int],\n) -&gt; \"GraphView\":\n    \"\"\"\n    Contract the graph to only include the given `permanent_node_ids`.\n    Predecessor and sucessors of removed nodes are connected during contraction.\n\n    Example:\n\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=1))\n        A --&gt; C((t=1))\n        B --&gt; D((t=2))\n        C --&gt; E((t=2))\n        C --&gt; F((t=2))\n    ```\n\n    After contraction only keeping nodes in `t=0` and `t=2`:\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=2))\n        A --&gt; C((t=2))\n        A --&gt; D((t=2))\n    ```\n\n    Parameters\n    ----------\n    permanent_node_ids : Sequence[int]\n        The node ids to keep in the contracted graph.\n\n    Returns\n    -------\n    GraphView\n        A view of the contracted graph.\n    \"\"\"\n    from tracksdata.graph._graph_view import GraphView\n\n    all_node_ids = np.asarray(self.node_ids())\n    selected_nodes_mask = np.isin(all_node_ids, permanent_node_ids)\n    missing_node_ids = all_node_ids[~selected_nodes_mask]\n\n    # must block multigraphs to avoid edge duplication\n    rx_graph = rx.PyDiGraph(multigraph=False)\n    new_indices = rx_graph.add_nodes_from(self.rx_graph.nodes())\n    rx_graph.add_edges_from(self.rx_graph.weighted_edge_list())\n\n    for node_id in missing_node_ids:\n        rx_graph.remove_node_retain_edges(\n            node_id,\n            use_outgoing=True,\n            condition=lambda *args: True,\n        )\n\n    node_map_to_root = dict(\n        zip(\n            np.asarray(new_indices)[selected_nodes_mask].tolist(),\n            permanent_node_ids,\n            strict=True,\n        )\n    )\n\n    # I'm a bit concerned with the internal booking of indices of rustworkx\n    # so I'm adding this sanity check\n    assert len(node_map_to_root) == rx_graph.num_nodes()\n\n    graph_view = GraphView(rx_graph, node_map_to_root=node_map_to_root, root=self)\n\n    return graph_view\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.contract_nodes(permanent_node_ids)","title":"<code>permanent_node_ids</code>","text":"(<code>Sequence[int]</code>)           \u2013            <p>The node ids to keep in the contracted graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; BaseGraph\n</code></pre> <p>Create a copy of this graph.</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A new graph instance with the same nodes, edges, and attributes as this graph.</p> </li> <li> <code>**kwargs</code> (              <code>Any</code> )          \u2013            <p>Additional arguments to pass to the graph constructor.</p> </li> </ul> <p>Examples:</p> <pre><code>copied_graph = graph.copy()\n</code></pre> See Also <p>from_other:     Create a graph from another graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def copy(self, **kwargs) -&gt; \"BaseGraph\":\n    \"\"\"\n    Create a copy of this graph.\n\n    Returns\n    -------\n    BaseGraph\n        A new graph instance with the same nodes, edges, and attributes as this graph.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    copied_graph = graph.copy()\n    ```\n\n    See Also\n    --------\n    [from_other][tracksdata.graph.BaseGraph.from_other]:\n        Create a graph from another graph.\n    \"\"\"\n    return self.__class__.from_other(self, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs","title":"edge_attrs","text":"<pre><code>edge_attrs(*, attr_keys: Sequence[str] | str | None = None, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the edges as a polars DataFrame.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the edges as a polars DataFrame.\n\n    Parameters\n    ----------\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n    unpack : bool\n        Whether to unpack array attributesinto multiple scalar attributes.\n    \"\"\"\n    if attr_keys is None:\n        attr_keys = self.edge_attr_keys\n\n    attr_keys = [DEFAULT_ATTR_KEYS.EDGE_ID, *attr_keys]\n    attr_keys = list(dict.fromkeys(attr_keys))\n\n    rx_graph = self.rx_graph\n\n    edge_map = rx_graph.edge_index_map()\n    if len(edge_map) == 0:\n        return pl.DataFrame(\n            {\n                key: []\n                for key in [\n                    *attr_keys,\n                    DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n                    DEFAULT_ATTR_KEYS.EDGE_TARGET,\n                ]\n            }\n        )\n\n    source, target, data = zip(*edge_map.values(), strict=False)\n\n    columns = {key: [] for key in attr_keys}\n\n    for row in data:\n        for key in attr_keys:\n            columns[key].append(row[key])\n\n    columns[DEFAULT_ATTR_KEYS.EDGE_SOURCE] = source\n    columns[DEFAULT_ATTR_KEYS.EDGE_TARGET] = target\n\n    columns = {k: np.asarray(v) for k, v in columns.items()}\n\n    df = pl.DataFrame(columns)\n    if unpack:\n        df = unpack_array_attrs(df)\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributesinto multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_id","title":"edge_id","text":"<pre><code>edge_id(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Return the edge id between two nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_id(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Return the edge id between two nodes.\n    \"\"\"\n    return self.rx_graph.get_edge_data(source_id, target_id)[DEFAULT_ATTR_KEYS.EDGE_ID]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_ids","title":"edge_ids","text":"<pre><code>edge_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all edges in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all edges in the graph.\n    \"\"\"\n    return [int(i) for i in self.rx_graph.edge_indices()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(positions: ArrayLike, track_ids: ArrayLike | None = None, track_id_graph: dict[int, int] | None = None, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. track_ids : np.ndarray | None     Track ids of the nodes if available. track_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    track_ids: ArrayLike | None = None,\n    track_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    track_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    track_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import from_array\n\n    graph = cls(**kwargs)\n    from_array(\n        positions=np.asarray(positions),\n        graph=graph,\n        track_ids=track_ids,\n        track_id_graph=track_id_graph,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--see-also","title":"See Also","text":"<p>from_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--see-also_1","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [from_ctc][tracksdata.io._ctc.from_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n\n    See Also\n    --------\n    [to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import from_ctc\n\n    graph = cls(**kwargs)\n    from_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_geff","title":"from_geff  <code>classmethod</code>","text":"<pre><code>from_geff(geff_store: StoreLike, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a geff data directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>The loaded graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_geff(\n    cls: type[T],\n    geff_store: StoreLike,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to read the graph from.\n    **kwargs\n        Additional keyword arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    T\n        The loaded graph.\n    \"\"\"\n    from tracksdata.graph import IndexedRXGraph\n\n    # this performs a roundtrip with the rustworkx graph\n    rx_graph, _ = read_rx(geff_store)\n\n    if not isinstance(rx_graph, rx.PyDiGraph):\n        LOG.warning(\"The graph is not a directed graph, converting to directed graph.\")\n        rx_graph = rx_graph.to_directed()\n\n    indexed_graph = IndexedRXGraph(\n        rx_graph=rx_graph,\n        node_id_map=rx_graph.attrs[\"to_rx_id_map\"],\n        **kwargs,\n    )\n\n    if cls == IndexedRXGraph:\n        return indexed_graph\n\n    return cls.from_other(indexed_graph, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to read the graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_geff(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional keyword arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_other--parameters","title":"Parameters","text":"<p>other : BaseGraph     The other graph to create a new graph from. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_other--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the other graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            graph.add_node_attr_key(col, node_attrs[col].first())\n\n    if graph.supports_custom_indices:\n        new_node_ids = graph.bulk_add_nodes(\n            list(node_attrs.rows(named=True)),\n            indices=other_node_ids.to_list(),\n        )\n    else:\n        new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n        if other.supports_custom_indices:\n            LOG.warning(\n                f\"Other graph ({type(other).__name__}) supports custom indices, but this graph \"\n                f\"({type(graph).__name__}) does not, indexing automatically.\"\n            )\n\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.has_edge","title":"has_edge","text":"<pre><code>has_edge(source_id: int, target_id: int) -&gt; bool\n</code></pre> <p>Check if the graph has an edge between two nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_edge(self, source_id: int, target_id: int) -&gt; bool:\n    \"\"\"\n    Check if the graph has an edge between two nodes.\n    \"\"\"\n    return self.rx_graph.has_edge(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return len(self.overlaps()) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.in_degree","title":"in_degree","text":"<pre><code>in_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.in_degree(node_ids)\n    return [rx_graph.in_degree(node_id) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match","title":"match","text":"<pre><code>match(other: BaseGraph, matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID, match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE, matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_attrs","title":"node_attrs","text":"<pre><code>node_attrs(*, attr_keys: Sequence[str] | str | None = None, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the nodes as a polars DataFrame.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def node_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the nodes as a polars DataFrame.\n    \"\"\"\n    return self._node_attrs_from_node_ids(attr_keys=attr_keys, unpack=unpack)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_ids","title":"node_ids","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all nodes in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all nodes in the graph.\n    \"\"\"\n    return [int(i) for i in self.rx_graph.node_indices()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.out_degree","title":"out_degree","text":"<pre><code>out_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.out_degree(node_ids)\n    return [rx_graph.out_degree(node_id) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(node_ids: list[int] | None = None) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>. If <code>node_ids</code> is None, all nodes are used.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps between the nodes in <code>node_ids</code>.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    If `node_ids` is None, all nodes are used.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the overlaps for.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps between the nodes in `node_ids`.\n    \"\"\"\n    if len(self._overlaps) == 0:\n        return []\n\n    if node_ids is None:\n        return self._overlaps\n\n    node_ids = np.asarray(node_ids, dtype=int)\n    overlaps_arr = np.asarray(self._overlaps, dtype=int)\n\n    is_in_source = np.isin(overlaps_arr[:, 0], node_ids)\n    is_in_target = np.isin(overlaps_arr[:, 1], node_ids)\n    return overlaps_arr[is_in_source &amp; is_in_target].tolist()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the overlaps for. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.predecessors","title":"predecessors","text":"<pre><code>predecessors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>The predecessors of the nodes indexed by node ID if a list of nodes is provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the predecessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        The predecessors of the nodes indexed by node ID if a list of nodes is provided.\n    \"\"\"\n    return self._get_neighbors(\n        rx.PyDiGraph.predecessor_indices,\n        node_ids,\n        attr_keys,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the graph.</p> <p>This method removes the specified node and all edges connected to it (both incoming and outgoing edges). Also updates the time_to_nodes mapping.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the node_id does not exist in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph.\n\n    This method removes the specified node and all edges connected to it\n    (both incoming and outgoing edges). Also updates the time_to_nodes mapping.\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to remove.\n\n    Raises\n    ------\n    ValueError\n        If the node_id does not exist in the graph.\n    \"\"\"\n    if node_id not in self.rx_graph.node_indices():\n        raise ValueError(f\"Node {node_id} does not exist in the graph\")\n\n    # Get the time value before removing the node\n    t = self.rx_graph[node_id][\"t\"]\n\n    # Remove the node from the graph (this also removes all connected edges)\n    self.rx_graph.remove_node(node_id)\n\n    # Update the time_to_nodes mapping\n    self._time_to_nodes[t].remove(node_id)\n    # Clean up empty time entries\n    if not self._time_to_nodes[t]:\n        del self._time_to_nodes[t]\n\n    # Remove from overlaps if present\n    if self._overlaps is not None:\n        self._overlaps = [overlap for overlap in self._overlaps if node_id != overlap[0] and node_id != overlap[1]]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.spatial_filter","title":"spatial_filter","text":"<pre><code>spatial_filter(attr_keys: list[str] | None = None) -&gt; SpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> <p>This method creates a spatial index of graph nodes based on their spatial coordinates, enabling efficient querying of nodes within spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for image coordinates:</p> <pre><code>spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n# Query nodes in region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n# Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>SpatialFilter:     The point spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def spatial_filter(self, attr_keys: list[str] | None = None) -&gt; \"SpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes.\n\n    This method creates a spatial index of graph nodes based on their spatial coordinates,\n    enabling efficient querying of nodes within spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    attr_keys : list[str] | None, optional\n        List of attribute keys to use as spatial coordinates. If None, defaults to\n        [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.\n        Common combinations include:\n        - 2D: [\"y\", \"x\"]\n        - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"]\n        - 4D: [\"t\", \"z\", \"y\", \"x\"]\n\n    Returns\n    -------\n    SpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for image coordinates:\n\n    ```python\n    spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n    # Query nodes in region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n    # Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [SpatialFilter][tracksdata.graph.filters.SpatialFilter]:\n        The point spatial filter query class.\n\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import SpatialFilter\n\n    return SpatialFilter(self, attr_keys=attr_keys)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.spatial_filter(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute keys to use as spatial coordinates. If None, defaults to [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph. Common combinations include: - 2D: [\"y\", \"x\"] - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"] - 4D: [\"t\", \"z\", \"y\", \"x\"]</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.successors","title":"successors","text":"<pre><code>successors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the sucessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>The sucessors of the nodes indexed by node ID if a list of nodes is provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the sucessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the sucessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        The sucessors of the nodes indexed by node ID if a list of nodes is provided.\n    \"\"\"\n    return self._get_neighbors(\n        rx.PyDiGraph.successor_indices,\n        node_ids,\n        attr_keys,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the sucessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.summary","title":"summary","text":"<pre><code>summary(attrs_stats: bool = False, print_summary: bool = True) -&gt; str\n</code></pre> <p>Print a summary of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string with the summary of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def summary(\n    self,\n    attrs_stats: bool = False,\n    print_summary: bool = True,\n) -&gt; str:\n    \"\"\"\n    Print a summary of the graph.\n\n    Parameters\n    ----------\n    attrs_stats : bool\n        If true it will print statistics about the attributes of the nodes and edges.\n    print_summary : bool\n        If true it will print the summary of the graph.\n\n    Returns\n    -------\n    str\n        A string with the summary of the graph.\n    \"\"\"\n    summary = \"\"\n\n    summary += \"Graph summary:\\n\"\n    summary += f\"Number of nodes: {self.num_nodes}\\n\"\n    summary += f\"Number of edges: {self.num_edges}\\n\"\n    summary += f\"Number of overlaps: {len(self.overlaps())}\\n\"\n\n    time_points = self.time_points()\n    summary += f\"Number of distinct time points: {len(time_points)}\\n\"\n    if len(time_points) &gt; 0:\n        summary += f\"Start time: {min(time_points)}\\n\"\n        summary += f\"End time: {max(time_points)}\\n\"\n    else:\n        summary += \"No time points found.\\n\"\n\n    if attrs_stats:\n        nodes_attrs = self.node_attrs()\n        edges_attrs = self.edge_attrs()\n        summary += \"\\nNodes attributes:\\n\"\n        summary += str(nodes_attrs.describe())\n        summary += \"\\nEdges attributes:\\n\"\n        summary += str(edges_attrs.describe())\n\n    if print_summary:\n        print(summary)\n\n    return summary\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.summary(attrs_stats)","title":"<code>attrs_stats</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true it will print statistics about the attributes of the nodes and edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.summary(print_summary)","title":"<code>print_summary</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true it will print the summary of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.time_points","title":"time_points","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n    return list(self._time_to_nodes.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(shape: tuple[int, ...], output_dir: str | Path, track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, overwrite: bool = False) -&gt; None\n</code></pre> <p>Save the graph to a CTC ground truth directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_ctc--parameters","title":"Parameters","text":"<p>shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X) output_dir : str | Path     The directory to save the graph to. track_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_ctc--examples","title":"Examples","text":"<pre><code># ...\nsolution_graph = solver.solve(graph)\nsolution_graph.assign_track_ids()\nsolution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_ctc--see-also","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_ctc(\n    self,\n    shape: tuple[int, ...],\n    output_dir: str | Path,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save the graph to a CTC ground truth directory.\n\n    Parameters\n    ----------\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X)\n    output_dir : str | Path\n        The directory to save the graph to.\n    track_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    Examples\n    --------\n    ```python\n    # ...\n    solution_graph = solver.solve(graph)\n    solution_graph.assign_track_ids()\n    solution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n    ```\n\n    See Also\n    --------\n    [to_ctc][tracksdata.io.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import to_ctc\n\n    to_ctc(\n        graph=self,\n        shape=shape,\n        output_dir=output_dir,\n        track_id_key=track_id_key,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_geff","title":"to_geff","text":"<pre><code>to_geff(geff_store: StoreLike, geff_metadata: GeffMetadata | None = None, zarr_format: Literal[2, 3] = 3) -&gt; None\n</code></pre> <p>Write the graph to a geff data directory.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_geff(\n    self,\n    geff_store: StoreLike,\n    geff_metadata: GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None:\n    \"\"\"\n    Write the graph to a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to write the graph to.\n    geff_metadata : GeffMetadata | None\n        The geff metadata to write to the graph.\n        It automatically generates the metadata with:\n        - axes: time (t) and spatial axes ((z), y, x)\n        - tracklet node property: track_id\n    zarr_format : Literal[2, 3]\n        The zarr format to write the graph to.\n        Defaults to 3.\n    \"\"\"\n\n    node_attrs = self.node_attrs()\n\n    if DEFAULT_ATTR_KEYS.MASK in node_attrs.columns:\n        node_attrs = column_to_bytes(node_attrs, DEFAULT_ATTR_KEYS.MASK)\n\n    if geff_metadata is None:\n        axes = [Axis(name=DEFAULT_ATTR_KEYS.T, type=\"time\")]\n        axes.extend([Axis(name=c, type=\"space\") for c in (\"z\", \"y\", \"x\") if c in node_attrs.columns])\n\n        if DEFAULT_ATTR_KEYS.TRACK_ID in node_attrs.columns:\n            track_node_props = {\n                \"tracklet\": DEFAULT_ATTR_KEYS.TRACK_ID,\n            }\n        else:\n            track_node_props = None\n\n        geff_metadata = GeffMetadata(\n            directed=True,\n            axes=axes,\n            track_node_props=track_node_props,\n        )\n\n    edge_attrs = self.edge_attrs().drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    node_dict = {\n        k: (column_to_numpy(v), None) for k, v in node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID).to_dict().items()\n    }\n\n    edge_ids = edge_attrs.select(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET).to_numpy()\n\n    edge_dict = {\n        k: (column_to_numpy(v), None)\n        for k, v in edge_attrs.drop(\n            DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n            DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        )\n        .to_dict()\n        .items()\n    }\n\n    write_arrays(\n        geff_store,\n        metadata=geff_metadata,\n        node_ids=node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy(),\n        node_props=node_dict,\n        edge_ids=edge_ids,\n        edge_props=edge_dict,\n        zarr_format=zarr_format,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to write the graph to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_geff(geff_metadata)","title":"<code>geff_metadata</code>","text":"(<code>GeffMetadata | None</code>, default:                   <code>None</code> )           \u2013            <p>The geff metadata to write to the graph. It automatically generates the metadata with: - axes: time (t) and spatial axes ((z), y, x) - tracklet node property: track_id</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_geff(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The zarr format to write the graph to. Defaults to 3.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.tracklet_graph","title":"tracklet_graph","text":"<pre><code>tracklet_graph(track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, ignore_track_id: int | None = None) -&gt; rx.PyDiGraph\n</code></pre> <p>Create a compressed tracklet graph where each node is a tracklet and each edge is a transition between tracklets.</p> <p>IMPORTANT: rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values. And edge values are the tuple of source and target tracklet ids.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed tracklet graph.</p> </li> </ul> See Also <p>rx_digraph_to_napari_dict:     Convert a tracklet graph to a napari-ready dictionary.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_graph(\n    self,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    ignore_track_id: int | None = None,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Create a compressed tracklet graph where each node is a tracklet\n    and each edge is a transition between tracklets.\n\n    IMPORTANT:\n    rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values.\n    And edge values are the tuple of source and target tracklet ids.\n\n    Parameters\n    ----------\n    track_id_key : str\n        The key of the track id attribute.\n    ignore_track_id : int | None\n        The track id to ignore. If None, all track ids are used.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed tracklet graph.\n\n    See Also\n    --------\n    [rx_digraph_to_napari_dict][tracksdata.functional.rx_digraph_to_napari_dict]:\n        Convert a tracklet graph to a napari-ready dictionary.\n    \"\"\"\n\n    if track_id_key not in self.node_attr_keys:\n        raise ValueError(f\"Track id key '{track_id_key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n    nodes_df = self.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, track_id_key])\n    edges_df = self.edge_attrs(attr_keys=[])\n\n    if ignore_track_id is not None:\n        nodes_df = nodes_df.filter(pl.col(track_id_key) != ignore_track_id)\n\n    nodes_df = nodes_df.unique(subset=[track_id_key])\n\n    graph = rx.PyDiGraph()\n    nodes_df = nodes_df.with_columns(\n        pl.Series(\n            np.asarray(graph.add_nodes_from(nodes_df[track_id_key].to_list()), dtype=int),\n        ).alias(\"rx_id\"),\n    )\n\n    edges_df = (\n        edges_df.join(\n            nodes_df.rename({track_id_key: \"source_track_id\", \"rx_id\": \"source_rx_id\"}),\n            left_on=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n            right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n            how=\"right\",\n        )\n        .join(\n            nodes_df.rename({track_id_key: \"target_track_id\", \"rx_id\": \"target_rx_id\"}),\n            left_on=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n            right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n            how=\"right\",\n        )\n        .filter(~pl.col(DEFAULT_ATTR_KEYS.EDGE_ID).is_null())\n    )\n\n    graph.add_edges_from(\n        zip(\n            edges_df[\"source_rx_id\"].to_list(),\n            edges_df[\"target_rx_id\"].to_list(),\n            zip(edges_df[\"source_track_id\"].to_list(), edges_df[\"target_track_id\"].to_list(), strict=False),\n            strict=True,\n        )\n    )\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.tracklet_graph(track_id_key)","title":"<code>track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.tracklet_graph(ignore_track_id)","title":"<code>ignore_track_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The track id to ignore. If None, all track ids are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_edge_attrs","title":"update_edge_attrs","text":"<pre><code>update_edge_attrs(*, attrs: dict[str, Any], edge_ids: Sequence[int] | None = None) -&gt; None\n</code></pre> <p>Update the attributes of the edges.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def update_edge_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the edges.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        Attributes to be updated.\n    edge_ids : Sequence[int] | None\n        The IDs of the edges to update or None to update all edges.\n    \"\"\"\n    if edge_ids is None:\n        edge_ids = self.edge_ids()\n\n    size = len(edge_ids)\n    for key, value in attrs.items():\n        if key not in self.edge_attr_keys:\n            raise ValueError(f\"Edge attribute key '{key}' not found in graph. Expected '{self.edge_attr_keys}'\")\n\n        if np.isscalar(value):\n            attrs[key] = [value] * size\n\n        elif len(attrs[key]) != size:\n            raise ValueError(f\"Attribute '{key}' has wrong size. Expected {size}, got {len(attrs[key])}\")\n\n    edge_map = self._graph.edge_index_map()\n\n    for i, edge_id in enumerate(edge_ids):\n        edge_attr = edge_map[edge_id][2]  # 0=source, 1=target, 2=attributes\n        for key, value in attrs.items():\n            edge_attr[key] = value[i]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_edge_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Attributes to be updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_edge_attrs(edge_ids)","title":"<code>edge_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the edges to update or None to update all edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_node_attrs","title":"update_node_attrs","text":"<pre><code>update_node_attrs(*, attrs: dict[str, Any], node_ids: Sequence[int] | None = None) -&gt; None\n</code></pre> <p>Update the attributes of the nodes.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def update_node_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the nodes.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to update.\n    node_ids : Sequence[int] | None\n        The IDs of the nodes to update or None to update all nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n\n    for key, value in attrs.items():\n        if key not in self.node_attr_keys:\n            raise ValueError(f\"Node attribute key '{key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n        if not np.isscalar(value) and len(attrs[key]) != len(node_ids):\n            raise ValueError(f\"Attribute '{key}' has wrong size. Expected {len(node_ids)}, got {len(attrs[key])}\")\n\n    for key, value in attrs.items():\n        if np.isscalar(value):\n            value = [value] * len(node_ids)\n\n        for node_id, v in zip(node_ids, value, strict=False):\n            self._graph[node_id][key] = v\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_node_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to update.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_node_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to update or None to update all nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph","title":"SQLGraph","text":"<pre><code>SQLGraph(drivername: str, database: str, username: str | None = None, password: str | None = None, host: str | None = None, port: int | None = None, engine_kwargs: dict[str, Any] | None = None, overwrite: bool = False)\n</code></pre> <p>               Bases: <code>BaseGraph</code></p> <p>SQL-based graph implementation using SQLAlchemy ORM.</p> <p>Provides persistent storage and efficient querying of large graphs with support for dynamic schema modification and various database backends. Node IDs are automatically generated based on time to ensure uniqueness across time points.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--parameters","title":"Parameters","text":"<p>drivername : str     The database driver name (e.g., 'sqlite', 'postgresql', 'mysql'). database : str     The database name or path. For SQLite, this is the file path. username : str, optional     Database username. Not required for SQLite. password : str, optional     Database password. Not required for SQLite. host : str, optional     Database host. Not required for SQLite. port : int, optional     Database port. Not required for SQLite. overwrite : bool, default False     If True, drop and recreate all tables. Use with caution as this     will delete all existing data.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--attributes","title":"Attributes","text":"<p>node_id_time_multiplier : int     Multiplier used to generate node IDs based on time (default: 1,000,000,000). Base : type[DeclarativeBase]     SQLAlchemy declarative base class for this graph instance. Node : type[DeclarativeBase]     SQLAlchemy model class for nodes. Edge : type[DeclarativeBase]     SQLAlchemy model class for edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--see-also","title":"See Also","text":"<p>RustWorkXGraph:     In memory Rustworkx-based graph implementation.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--examples","title":"Examples","text":"<p>Create an in-memory SQLite graph:</p> <pre><code>graph = SQLGraph(\"sqlite\", \":memory:\")\n</code></pre> <p>Create a persistent SQLite graph:</p> <pre><code>graph = SQLGraph(\"sqlite\", \"my_graph.db\")\n</code></pre> <p>Create a PostgreSQL graph:</p> <pre><code>graph = SQLGraph(\"postgresql\", \"tracking_db\", username=\"user\", password=\"pass\", host=\"localhost\", port=5432)\n</code></pre> <p>Add nodes and edges:</p> <pre><code>node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\nedge_id = graph.add_edge(node_id, target_id, {\"weight\": 0.8})\n</code></pre> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Helper method to interact with a single node.</p> </li> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph at time t.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>bbox_spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Add multiple edges to the graph efficiently.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Add multiple nodes to the graph efficiently.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>copy</code>             \u2013              <p>Create a copy of this graph.</p> </li> <li> <code>edge_id</code>             \u2013              <p>Return the edge id between two nodes.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_geff</code>             \u2013              <p>Create a graph from a geff data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_edge</code>             \u2013              <p>Check if the graph has an edge between two nodes.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the IDs of all nodes in the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessor nodes of given nodes.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a node from the graph.</p> </li> <li> <code>spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> </li> <li> <code>successors</code>             \u2013              <p>Get the successor nodes of given nodes.</p> </li> <li> <code>summary</code>             \u2013              <p>Print a summary of the graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save the graph to a CTC ground truth directory.</p> </li> <li> <code>to_geff</code>             \u2013              <p>Write the graph to a geff data directory.</p> </li> <li> <code>tracklet_graph</code>             \u2013              <p>Create a compressed tracklet graph where each node is a tracklet</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def __init__(\n    self,\n    drivername: str,\n    database: str,\n    username: str | None = None,\n    password: str | None = None,\n    host: str | None = None,\n    port: int | None = None,\n    engine_kwargs: dict[str, Any] | None = None,\n    overwrite: bool = False,\n):\n    self._url = sa.engine.URL.create(\n        drivername,\n        username=username,\n        password=password,\n        host=host,\n        port=port,\n        database=database,\n    )\n    self._engine_kwargs = engine_kwargs if engine_kwargs is not None else {}\n    self._engine = sa.create_engine(self._url, **self._engine_kwargs)\n\n    # Create unique classes for this instance\n    self._define_schema(overwrite=overwrite)\n    self._boolean_columns: dict[str, list[str]] = {self.Node.__tablename__: [], self.Edge.__tablename__: []}\n\n    if overwrite:\n        self.Base.metadata.drop_all(self._engine)\n\n    self.Base.metadata.create_all(self._engine)\n\n    self._max_id_per_time = {}\n    self._update_max_id_per_time()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(node_id: int) -&gt; NodeInterface\n</code></pre> <p>Helper method to interact with a single node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NodeInterface</code>           \u2013            <p>A node interface for the given node id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def __getitem__(self, node_id: int) -&gt; \"NodeInterface\":\n    \"\"\"\n    Helper method to interact with a single node.\n\n    Parameters\n    ----------\n    node_id : int\n        The id of the node to interact with.\n\n    Returns\n    -------\n    NodeInterface\n        A node interface for the given node id.\n    \"\"\"\n\n    if not isinstance(node_id, int):\n        raise ValueError(f\"graph index must be a integer, found '{node_id}' of type {type(node_id)}\")\n    return NodeInterface(self, node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.__getitem__(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The id of the node to interact with.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._cast_boolean_columns","title":"_cast_boolean_columns","text":"<pre><code>_cast_boolean_columns(table_class: type[DeclarativeBase], df: DataFrame) -&gt; pl.DataFrame\n</code></pre> <p>This is required because polars bypasses the boolean type and converts it to integer.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _cast_boolean_columns(self, table_class: type[DeclarativeBase], df: pl.DataFrame) -&gt; pl.DataFrame:\n    \"\"\"\n    This is required because polars bypasses the boolean type and converts it to integer.\n    \"\"\"\n    df = df.with_columns(\n        pl.col(col).cast(pl.Boolean)\n        for col in self._boolean_columns[table_class.__tablename__]\n        if col in df.columns\n    )\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._define_schema","title":"_define_schema","text":"<pre><code>_define_schema(overwrite: bool) -&gt; None\n</code></pre> <p>Define the database schema classes for this SQLGraph instance.</p> <p>Creates unique SQLAlchemy model classes for this graph instance to avoid conflicts between multiple SQLGraph instances.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _define_schema(self, overwrite: bool) -&gt; None:\n    \"\"\"\n    Define the database schema classes for this SQLGraph instance.\n\n    Creates unique SQLAlchemy model classes for this graph instance to\n    avoid conflicts between multiple SQLGraph instances.\n    \"\"\"\n    metadata = sa.MetaData()\n    metadata.reflect(bind=self._engine)\n\n    class Base(DeclarativeBase):\n        pass\n\n    if len(metadata.tables) &gt; 0 and not overwrite:\n        for table_name, table in metadata.tables.items():\n            cls = type(\n                table_name,\n                (Base,),\n                {\n                    \"__table__\": table,\n                    \"__tablename__\": table_name,\n                },\n            )\n            setattr(self, table_name, cls)\n        self.Base = Base\n        return\n\n    class Node(Base):\n        __tablename__ = \"Node\"\n\n        # Use node_id as sole primary key for simpler updates\n        node_id = sa.Column(sa.BigInteger, primary_key=True, unique=True)\n\n        # Add t as a regular column\n        # NOTE might want to use as index for fast time-based queries\n        t = sa.Column(sa.Integer, nullable=False)\n\n    node_tb_name = Node.__tablename__\n\n    class Edge(Base):\n        __tablename__ = \"Edge\"\n        edge_id = sa.Column(sa.Integer, primary_key=True, unique=True, autoincrement=True)\n        source_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"))\n        target_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"))\n\n    class Overlap(Base):\n        __tablename__ = \"Overlap\"\n        overlap_id = sa.Column(sa.Integer, primary_key=True, unique=True, autoincrement=True)\n        source_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"))\n        target_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"))\n\n    # Assign to instance variables\n    self.Base = Base\n    self.Node = Node\n    self.Edge = Edge\n    self.Overlap = Overlap\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors","title":"_get_neighbors","text":"<pre><code>_get_neighbors(node_key: str, neighbor_key: str, node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessors or successors of nodes via database joins.</p> <p>Helper method used by sucessors() and predecessors() to efficiently query neighbor relationships through SQL joins.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>If multiple node_ids are provided, returns a dictionary mapping each node_id to a DataFrame of its neighbors. If a single node_id is provided, returns the DataFrame directly.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _get_neighbors(\n    self,\n    node_key: str,\n    neighbor_key: str,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessors or successors of nodes via database joins.\n\n    Helper method used by sucessors() and predecessors() to efficiently\n    query neighbor relationships through SQL joins.\n\n    Parameters\n    ----------\n    node_key : str\n        The edge attribute key for the query node (e.g., \"source_id\").\n    neighbor_key : str\n        The edge attribute key for the neighbor node (e.g., \"target_id\").\n    node_ids : list[int] | int\n        The IDs of the nodes to get neighbors for.\n    attr_keys : Sequence[str] | str | None, optional\n        The attribute keys to retrieve for neighbor nodes. If None,\n        all attributes are retrieved.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        If multiple node_ids are provided, returns a dictionary mapping\n        each node_id to a DataFrame of its neighbors. If a single node_id\n        is provided, returns the DataFrame directly.\n    \"\"\"\n    single_node = False\n    if isinstance(node_ids, int):\n        node_ids = [node_ids]\n        single_node = True\n\n    if isinstance(attr_keys, str):\n        attr_keys = [attr_keys]\n\n    with Session(self._engine) as session:\n        if attr_keys is None:\n            # all columns\n            node_columns = [self.Node]\n        else:\n            node_columns = [getattr(self.Node, key) for key in attr_keys]\n\n        query = session.query(getattr(self.Edge, node_key), *node_columns)\n        query = query.join(self.Edge, getattr(self.Edge, neighbor_key) == self.Node.node_id)\n        query = query.filter(getattr(self.Edge, node_key).in_(node_ids))\n\n        node_df = pl.read_database(\n            query.statement,\n            connection=session.connection(),\n        )\n        node_df = self._cast_boolean_columns(self.Node, node_df)\n        node_df = unpickle_bytes_columns(node_df)\n\n    if single_node:\n        return node_df\n\n    neighbors_dict = {node_id: group for (node_id,), group in node_df.group_by(node_key)}\n    for node_id in node_ids:\n        if node_id not in neighbors_dict:\n            neighbors_dict[node_id] = pl.DataFrame(schema=node_df.schema)\n\n    return neighbors_dict\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(node_key)","title":"<code>node_key</code>","text":"(<code>str</code>)           \u2013            <p>The edge attribute key for the query node (e.g., \"source_id\").</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(neighbor_key)","title":"<code>neighbor_key</code>","text":"(<code>str</code>)           \u2013            <p>The edge attribute key for the neighbor node (e.g., \"target_id\").</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get neighbors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve for neighbor nodes. If None, all attributes are retrieved.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._update_max_id_per_time","title":"_update_max_id_per_time","text":"<pre><code>_update_max_id_per_time() -&gt; None\n</code></pre> <p>Update the maximum node ID for each time point.</p> <p>Scans the database to find the current maximum node ID for each time point and updates the internal cache to ensure newly created nodes have unique IDs.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _update_max_id_per_time(self) -&gt; None:\n    \"\"\"\n    Update the maximum node ID for each time point.\n\n    Scans the database to find the current maximum node ID for each time\n    point and updates the internal cache to ensure newly created nodes\n    have unique IDs.\n    \"\"\"\n    with Session(self._engine) as session:\n        for t in session.query(self.Node.t).distinct():\n            self._max_id_per_time[t] = int(session.query(sa.func.max(self.Node.node_id)).scalar())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(attrs: dict[str, Any], reference_keys: list[str], mode: str) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys():\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(source_id: int, target_id: int, attrs: dict[str, Any], validate_keys: bool = True) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the newly added edge.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If validate_keys is True and the attributes contain invalid keys.</p> </li> </ul> <p>Examples:</p> <pre><code>edge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.8})\nedge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.9, \"distance\": 5.2, \"confidence\": 0.95})\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n    attrs : dict[str, Any]\n        Additional attributes for the edge (e.g., weight, distance).\n    validate_keys : bool, default True\n        Whether to check if the attribute keys are valid against the\n        current schema. If False, validation is skipped for performance.\n\n    Returns\n    -------\n    int\n        The ID of the newly added edge.\n\n    Raises\n    ------\n    ValueError\n        If validate_keys is True and the attributes contain invalid keys.\n\n    Examples\n    --------\n    ```python\n    edge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.8})\n    edge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.9, \"distance\": 5.2, \"confidence\": 0.95})\n    ```\n    \"\"\"\n    if validate_keys:\n        self._validate_attributes(attrs, self.edge_attr_keys, \"edge\")\n\n    if hasattr(source_id, \"item\"):\n        source_id = source_id.item()\n\n    if hasattr(target_id, \"item\"):\n        target_id = target_id.item()\n\n    edge = self.Edge(\n        source_id=source_id,\n        target_id=target_id,\n        **attrs,\n    )\n\n    with Session(self._engine) as session:\n        session.add(edge)\n        session.commit()\n        edge_id = edge.edge_id\n\n    return edge_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Additional attributes for the edge (e.g., weight, distance).</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attribute keys are valid against the current schema. If False, validation is skipped for performance.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node","title":"add_node","text":"<pre><code>add_node(attrs: dict[str, Any], validate_keys: bool = True, index: int | None = None) -&gt; int\n</code></pre> <p>Add a node to the graph at time t.</p> <p>Node IDs are automatically generated based on the time point and the node_id_time_multiplier to ensure uniqueness across time points, unless an explicit index is provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the newly added node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If validate_keys is True and the attributes contain invalid keys, or if the \"t\" key is missing.</p> </li> </ul> <p>Examples:</p> <pre><code>node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\nnode_id = graph.add_node({\"t\": 1, \"x\": 15.2, \"y\": 25.8, \"intensity\": 150.0})\nnode_id = graph.add_node({\"t\": 0, \"x\": 20.0, \"y\": 30.0}, index=12345)\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph at time t.\n\n    Node IDs are automatically generated based on the time point and\n    the node_id_time_multiplier to ensure uniqueness across time points,\n    unless an explicit index is provided.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes of the node to be added. Must contain a \"t\" key\n        specifying the time point. Additional keys will be stored as\n        node attributes.\n    validate_keys : bool, default True\n        Whether to check if the attribute keys are valid against the\n        current schema. If False, validation is skipped for performance.\n    index : int | None, default None\n        Optional specific node ID to use. If provided, this will be used\n        as the node_id instead of the auto-generated value.\n\n    Returns\n    -------\n    int\n        The ID of the newly added node.\n\n    Raises\n    ------\n    ValueError\n        If validate_keys is True and the attributes contain invalid keys,\n        or if the \"t\" key is missing.\n\n    Examples\n    --------\n    ```python\n    node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\n    node_id = graph.add_node({\"t\": 1, \"x\": 15.2, \"y\": 25.8, \"intensity\": 150.0})\n    node_id = graph.add_node({\"t\": 0, \"x\": 20.0, \"y\": 30.0}, index=12345)\n    ```\n    \"\"\"\n    if validate_keys:\n        self._validate_attributes(attrs, self.node_attr_keys, \"node\")\n\n        if \"t\" not in attrs:\n            raise ValueError(f\"Node attributes must have a 't' key. Got {attrs.keys()}\")\n\n    time = attrs[\"t\"]\n\n    if index is None:\n        default_node_id = (time * self.node_id_time_multiplier) - 1\n        node_id = self._max_id_per_time.get(time, default_node_id) + 1\n    else:\n        node_id = index\n\n    node = self.Node(\n        node_id=node_id,\n        **attrs,\n    )\n\n    with Session(self._engine) as session:\n        session.add(node)\n        session.commit()\n\n    # Update max_id tracking only if using auto-generated IDs\n    if index is None:\n        self._max_id_per_time[time] = node_id\n\n    return node_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the node to be added. Must contain a \"t\" key specifying the time point. Additional keys will be stored as node attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attribute keys are valid against the current schema. If False, validation is skipped for performance.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node(index)","title":"<code>index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional specific node ID to use. If provided, this will be used as the node_id instead of the auto-generated value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_overlap--parameters","title":"Parameters","text":"<p>source_id : int     The ID of the source node. target_id : int     The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_overlap--returns","title":"Returns","text":"<p>int     The ID of the added overlap.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    overlap = self.Overlap(\n        source_id=source_id,\n        target_id=target_id,\n    )\n    with Session(self._engine) as session:\n        session.add(overlap)\n        session.commit()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bbox_spatial_filter","title":"bbox_spatial_filter","text":"<pre><code>bbox_spatial_filter(frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T, bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX) -&gt; BBoxSpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> <p>This method creates a spatial index of graph nodes based on their bounding box coordinates, enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for bounding boxes:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n# Query nodes intersecting with region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter()\n# Uses default [\"t\", \"bbox\"]\n# Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>BBoxSpatialFilter:     The bounding box spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bbox_spatial_filter(\n    self,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n) -&gt; \"BBoxSpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.\n\n    This method creates a spatial index of graph nodes based on their bounding box coordinates,\n    enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    frame_attr_key : str | None\n        The attribute key for the frame (time) coordinate.\n        Default is `DEFAULT_ATTR_KEYS.T`.\n        If None it will only use the bounding box coordinates.\n    bbox_attr_key : str\n        The attribute key for the bounding box coordinates.\n        Defaults to `DEFAULT_ATTR_KEYS.BBOX`.\n        The bounding box coordinates should be in the format:\n        [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]\n        where each dimension has a min and max value.\n\n    Returns\n    -------\n    BBoxSpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for bounding boxes:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n    # Query nodes intersecting with region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter()\n    # Uses default [\"t\", \"bbox\"]\n    # Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [BBoxSpatialFilter][tracksdata.graph.filters.BBoxSpatialFilter]:\n        The bounding box spatial filter query class.\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import BBoxSpatialFilter\n\n    return BBoxSpatialFilter(self, frame_attr_key=frame_attr_key, bbox_attr_key=bbox_attr_key)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bbox_spatial_filter(frame_attr_key)","title":"<code>frame_attr_key</code>","text":"(<code>str | None</code>, default:                   <code>T</code> )           \u2013            <p>The attribute key for the frame (time) coordinate. Default is <code>DEFAULT_ATTR_KEYS.T</code>. If None it will only use the bounding box coordinates.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bbox_spatial_filter(bbox_attr_key)","title":"<code>bbox_attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key for the bounding box coordinates. Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>. The bounding box coordinates should be in the format: [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...] where each dimension has a min and max value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None\n</code></pre> <p>Add multiple edges to the graph efficiently.</p> <p>Provides better performance than calling add_edge multiple times by using SQLAlchemy's bulk insert functionality.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> Return <p>list[int] | None     The IDs of the added edges.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def bulk_add_edges(\n    self,\n    edges: list[dict[str, Any]],\n    return_ids: bool = False,\n) -&gt; list[int] | None:\n    \"\"\"\n    Add multiple edges to the graph efficiently.\n\n    Provides better performance than calling add_edge multiple times by\n    using SQLAlchemy's bulk insert functionality.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        List of edge attribute dictionaries. Each dictionary must contain\n        \"source_id\" and \"target_id\" keys, plus any additional feature keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Return\n    ------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    if len(edges) == 0:\n        if return_ids:\n            return []\n        return None\n\n    for edge in edges:\n        _data_numpy_to_native(edge)\n\n    with Session(self._engine) as session:\n        if return_ids:\n            result = session.execute(sa.insert(self.Edge).returning(self.Edge.edge_id), edges)\n            session.commit()\n            return list(result.scalars().all())\n        else:\n            session.execute(sa.insert(self.Edge), edges)\n            session.commit()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>List of edge attribute dictionaries. Each dictionary must contain \"source_id\" and \"target_id\" keys, plus any additional feature keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(nodes: list[dict[str, Any]], indices: list[int] | None = None) -&gt; list[int]\n</code></pre> <p>Add multiple nodes to the graph efficiently.</p> <p>Provides better performance than calling add_node multiple times by using SQLAlchemy's bulk insert functionality and reducing database transactions. Automatically assigns node IDs and handles time-based ID generation, or uses provided indices.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>nodes = [\n    {\"t\": 0, \"x\": 10, \"y\": 20, \"label\": \"A\"},\n    {\"t\": 0, \"x\": 15, \"y\": 25, \"label\": \"B\"},\n]\ngraph.bulk_add_nodes(nodes)\n\n# With specific indices\ngraph.bulk_add_nodes(nodes, indices=[1000, 2000])\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the added nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def bulk_add_nodes(\n    self,\n    nodes: list[dict[str, Any]],\n    indices: list[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Add multiple nodes to the graph efficiently.\n\n    Provides better performance than calling add_node multiple times by\n    using SQLAlchemy's bulk insert functionality and reducing database\n    transactions. Automatically assigns node IDs and handles time-based\n    ID generation, or uses provided indices.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        List of node attribute dictionaries. Each dictionary must contain\n        a \"t\" key and any additional attribute keys.\n    indices : list[int] | None, default None\n        Optional list of specific node IDs to use. If provided, must be\n        the same length as nodes. If None, IDs are auto-generated.\n\n    Examples\n    --------\n    ```python\n    nodes = [\n        {\"t\": 0, \"x\": 10, \"y\": 20, \"label\": \"A\"},\n        {\"t\": 0, \"x\": 15, \"y\": 25, \"label\": \"B\"},\n    ]\n    graph.bulk_add_nodes(nodes)\n\n    # With specific indices\n    graph.bulk_add_nodes(nodes, indices=[1000, 2000])\n    ```\n\n    Returns\n    -------\n    list[int]\n        The IDs of the added nodes.\n    \"\"\"\n    if len(nodes) == 0:\n        return []\n\n    self._validate_indices_length(nodes, indices)\n\n    node_ids = []\n    for i, node in enumerate(nodes):\n        time = node[\"t\"]\n\n        if indices is None:\n            default_node_id = (time * self.node_id_time_multiplier) - 1\n            node_id = self._max_id_per_time.get(time, default_node_id) + 1\n            # Update max_id tracking only for auto-generated IDs\n            self._max_id_per_time[time] = node_id\n        else:\n            node_id = indices[i]\n\n        node[DEFAULT_ATTR_KEYS.NODE_ID] = node_id\n        node_ids.append(node_id)\n\n    with Session(self._engine) as session:\n        session.execute(sa.insert(self.Node), nodes)\n        session.commit()\n\n    return node_ids\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>List of node attribute dictionaries. Each dictionary must contain a \"t\" key and any additional attribute keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_nodes(indices)","title":"<code>indices</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of specific node IDs to use. If provided, must be the same length as nodes. If None, IDs are auto-generated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.SQLGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    if hasattr(overlaps, \"tolist\"):\n        overlaps = overlaps.tolist()\n\n    overlaps = [{\"source_id\": source_id, \"target_id\": target_id} for source_id, target_id in overlaps]\n    with Session(self._engine) as session:\n        session.execute(sa.insert(self.Overlap), overlaps)\n        session.commit()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_attrs = self.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t).node_attrs(\n            attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MASK],\n        )\n        node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        masks = node_attrs[DEFAULT_ATTR_KEYS.MASK].to_list()\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; BaseGraph\n</code></pre> <p>Create a copy of this graph.</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A new graph instance with the same nodes, edges, and attributes as this graph.</p> </li> <li> <code>**kwargs</code> (              <code>Any</code> )          \u2013            <p>Additional arguments to pass to the graph constructor.</p> </li> </ul> <p>Examples:</p> <pre><code>copied_graph = graph.copy()\n</code></pre> See Also <p>from_other:     Create a graph from another graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def copy(self, **kwargs) -&gt; \"BaseGraph\":\n    \"\"\"\n    Create a copy of this graph.\n\n    Returns\n    -------\n    BaseGraph\n        A new graph instance with the same nodes, edges, and attributes as this graph.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    copied_graph = graph.copy()\n    ```\n\n    See Also\n    --------\n    [from_other][tracksdata.graph.BaseGraph.from_other]:\n        Create a graph from another graph.\n    \"\"\"\n    return self.__class__.from_other(self, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.edge_id","title":"edge_id","text":"<pre><code>edge_id(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Return the edge id between two nodes.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def edge_id(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Return the edge id between two nodes.\n    \"\"\"\n    with Session(self._engine) as session:\n        return (\n            session.query(self.Edge.edge_id)\n            .filter(self.Edge.source_id == source_id, self.Edge.target_id == target_id)\n            .scalar()\n        )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(positions: ArrayLike, track_ids: ArrayLike | None = None, track_id_graph: dict[int, int] | None = None, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. track_ids : np.ndarray | None     Track ids of the nodes if available. track_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    track_ids: ArrayLike | None = None,\n    track_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    track_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    track_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import from_array\n\n    graph = cls(**kwargs)\n    from_array(\n        positions=np.asarray(positions),\n        graph=graph,\n        track_ids=track_ids,\n        track_id_graph=track_id_graph,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--see-also","title":"See Also","text":"<p>from_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--see-also_1","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [from_ctc][tracksdata.io._ctc.from_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n\n    See Also\n    --------\n    [to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import from_ctc\n\n    graph = cls(**kwargs)\n    from_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_geff","title":"from_geff  <code>classmethod</code>","text":"<pre><code>from_geff(geff_store: StoreLike, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a geff data directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>The loaded graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_geff(\n    cls: type[T],\n    geff_store: StoreLike,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to read the graph from.\n    **kwargs\n        Additional keyword arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    T\n        The loaded graph.\n    \"\"\"\n    from tracksdata.graph import IndexedRXGraph\n\n    # this performs a roundtrip with the rustworkx graph\n    rx_graph, _ = read_rx(geff_store)\n\n    if not isinstance(rx_graph, rx.PyDiGraph):\n        LOG.warning(\"The graph is not a directed graph, converting to directed graph.\")\n        rx_graph = rx_graph.to_directed()\n\n    indexed_graph = IndexedRXGraph(\n        rx_graph=rx_graph,\n        node_id_map=rx_graph.attrs[\"to_rx_id_map\"],\n        **kwargs,\n    )\n\n    if cls == IndexedRXGraph:\n        return indexed_graph\n\n    return cls.from_other(indexed_graph, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to read the graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_geff(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional keyword arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_other--parameters","title":"Parameters","text":"<p>other : BaseGraph     The other graph to create a new graph from. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_other--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the other graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            graph.add_node_attr_key(col, node_attrs[col].first())\n\n    if graph.supports_custom_indices:\n        new_node_ids = graph.bulk_add_nodes(\n            list(node_attrs.rows(named=True)),\n            indices=other_node_ids.to_list(),\n        )\n    else:\n        new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n        if other.supports_custom_indices:\n            LOG.warning(\n                f\"Other graph ({type(other).__name__}) supports custom indices, but this graph \"\n                f\"({type(graph).__name__}) does not, indexing automatically.\"\n            )\n\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.has_edge","title":"has_edge","text":"<pre><code>has_edge(source_id: int, target_id: int) -&gt; bool\n</code></pre> <p>Check if the graph has an edge between two nodes.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def has_edge(self, source_id: int, target_id: int) -&gt; bool:\n    \"\"\"\n    Check if the graph has an edge between two nodes.\n    \"\"\"\n    with Session(self._engine) as session:\n        return (\n            session.query(self.Edge)\n            .filter(self.Edge.source_id == source_id, self.Edge.target_id == target_id)\n            .count()\n            &gt; 0\n        )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n    \"\"\"\n    with Session(self._engine) as session:\n        return session.query(self.Overlap).count() &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.in_degree","title":"in_degree","text":"<pre><code>in_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n    return self._get_degree(node_ids, DEFAULT_ATTR_KEYS.EDGE_TARGET)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match","title":"match","text":"<pre><code>match(other: BaseGraph, matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID, match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE, matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.node_ids","title":"node_ids","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all nodes in the graph.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all node IDs in the graph.</p> </li> </ul> <p>Examples:</p> <pre><code>all_nodes = graph.node_ids()\nprint(f\"Graph contains {len(all_nodes)} nodes\")\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all nodes in the graph.\n\n    Returns\n    -------\n    list[int]\n        List of all node IDs in the graph.\n\n    Examples\n    --------\n    ```python\n    all_nodes = graph.node_ids()\n    print(f\"Graph contains {len(all_nodes)} nodes\")\n    ```\n    \"\"\"\n    with Session(self._engine) as session:\n        return [i for (i,) in session.query(self.Node.node_id).all()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.out_degree","title":"out_degree","text":"<pre><code>out_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n    return self._get_degree(node_ids, DEFAULT_ATTR_KEYS.EDGE_SOURCE)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(node_ids: list[int] | None = None) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    \"\"\"\n    if hasattr(node_ids, \"tolist\"):\n        node_ids = node_ids.tolist()\n\n    with Session(self._engine) as session:\n        query = session.query(self.Overlap.source_id, self.Overlap.target_id)\n\n        if node_ids is not None:\n            query = query.filter(\n                self.Overlap.source_id.in_(node_ids),\n                self.Overlap.target_id.in_(node_ids),\n            )\n\n        return [[source_id, target_id] for source_id, target_id in query.all()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.predecessors","title":"predecessors","text":"<pre><code>predecessors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessor nodes of given nodes.</p> <p>Predecessors are nodes that are sources of edges targeting the given nodes (incoming edges). Uses efficient SQL joins to retrieve predecessor information with their attributes in a single query.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>If a list of node_ids is provided, returns a dictionary mapping each node_id to a DataFrame of its predecessors. If a single node_id is provided, returns the DataFrame directly.</p> </li> </ul> <p>Examples:</p> <pre><code>predecessors_df = graph.predecessors(node_id)\npredecessors_dict = graph.predecessors([node1, node2, node3])\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessor nodes of given nodes.\n\n    Predecessors are nodes that are sources of edges targeting the\n    given nodes (incoming edges). Uses efficient SQL joins to retrieve\n    predecessor information with their attributes in a single query.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get predecessors for.\n    attr_keys : Sequence[str] | str | None, optional\n        The attribute keys to retrieve for predecessor nodes. If None,\n        all attributes are retrieved.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        If a list of node_ids is provided, returns a dictionary mapping\n        each node_id to a DataFrame of its predecessors. If a single node_id\n        is provided, returns the DataFrame directly.\n\n    Examples\n    --------\n    ```python\n    predecessors_df = graph.predecessors(node_id)\n    predecessors_dict = graph.predecessors([node1, node2, node3])\n    ```\n    \"\"\"\n    return self._get_neighbors(\n        node_key=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        neighbor_key=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n        node_ids=node_ids,\n        attr_keys=attr_keys,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve for predecessor nodes. If None, all attributes are retrieved.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the graph.</p> <p>This method removes the specified node and all edges connected to it (both incoming and outgoing edges). Also removes any overlaps involving this node.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the node_id does not exist in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph.\n\n    This method removes the specified node and all edges connected to it\n    (both incoming and outgoing edges). Also removes any overlaps\n    involving this node.\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to remove.\n\n    Raises\n    ------\n    ValueError\n        If the node_id does not exist in the graph.\n    \"\"\"\n    with Session(self._engine) as session:\n        # Check if the node exists\n        node = session.query(self.Node).filter(self.Node.node_id == node_id).first()\n        if node is None:\n            raise ValueError(f\"Node {node_id} does not exist in the graph\")\n\n        # Remove all edges where this node is source or target\n        session.query(self.Edge).filter(\n            sa.or_(self.Edge.source_id == node_id, self.Edge.target_id == node_id)\n        ).delete()\n\n        # Remove all overlaps involving this node\n        session.query(self.Overlap).filter(\n            sa.or_(self.Overlap.source_id == node_id, self.Overlap.target_id == node_id)\n        ).delete()\n\n        # Remove the node itself\n        session.delete(node)\n        session.commit()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.spatial_filter","title":"spatial_filter","text":"<pre><code>spatial_filter(attr_keys: list[str] | None = None) -&gt; SpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> <p>This method creates a spatial index of graph nodes based on their spatial coordinates, enabling efficient querying of nodes within spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for image coordinates:</p> <pre><code>spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n# Query nodes in region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n# Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>SpatialFilter:     The point spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def spatial_filter(self, attr_keys: list[str] | None = None) -&gt; \"SpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes.\n\n    This method creates a spatial index of graph nodes based on their spatial coordinates,\n    enabling efficient querying of nodes within spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    attr_keys : list[str] | None, optional\n        List of attribute keys to use as spatial coordinates. If None, defaults to\n        [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.\n        Common combinations include:\n        - 2D: [\"y\", \"x\"]\n        - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"]\n        - 4D: [\"t\", \"z\", \"y\", \"x\"]\n\n    Returns\n    -------\n    SpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for image coordinates:\n\n    ```python\n    spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n    # Query nodes in region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n    # Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [SpatialFilter][tracksdata.graph.filters.SpatialFilter]:\n        The point spatial filter query class.\n\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import SpatialFilter\n\n    return SpatialFilter(self, attr_keys=attr_keys)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.spatial_filter(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute keys to use as spatial coordinates. If None, defaults to [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph. Common combinations include: - 2D: [\"y\", \"x\"] - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"] - 4D: [\"t\", \"z\", \"y\", \"x\"]</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.successors","title":"successors","text":"<pre><code>successors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the successor nodes of given nodes.</p> <p>Successors are nodes that are targets of edges originating from the given nodes (outgoing edges). Uses efficient SQL joins to retrieve successor information with their attributes in a single query.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>If a list of node_ids is provided, returns a dictionary mapping each node_id to a DataFrame of its successors. If a single node_id is provided, returns the DataFrame directly.</p> </li> </ul> <p>Examples:</p> <pre><code>successors_df = graph.sucessors(node_id)\nsuccessors_dict = graph.sucessors([node1, node2, node3])\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the successor nodes of given nodes.\n\n    Successors are nodes that are targets of edges originating from the\n    given nodes (outgoing edges). Uses efficient SQL joins to retrieve\n    successor information with their attributes in a single query.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get successors for.\n    attr_keys : Sequence[str] | str | None, optional\n        The attribute keys to retrieve for successor nodes. If None,\n        all attributes are retrieved.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        If a list of node_ids is provided, returns a dictionary mapping\n        each node_id to a DataFrame of its successors. If a single node_id\n        is provided, returns the DataFrame directly.\n\n    Examples\n    --------\n    ```python\n    successors_df = graph.sucessors(node_id)\n    successors_dict = graph.sucessors([node1, node2, node3])\n    ```\n    \"\"\"\n    return self._get_neighbors(\n        node_key=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n        neighbor_key=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        node_ids=node_ids,\n        attr_keys=attr_keys,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get successors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve for successor nodes. If None, all attributes are retrieved.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.summary","title":"summary","text":"<pre><code>summary(attrs_stats: bool = False, print_summary: bool = True) -&gt; str\n</code></pre> <p>Print a summary of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string with the summary of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def summary(\n    self,\n    attrs_stats: bool = False,\n    print_summary: bool = True,\n) -&gt; str:\n    \"\"\"\n    Print a summary of the graph.\n\n    Parameters\n    ----------\n    attrs_stats : bool\n        If true it will print statistics about the attributes of the nodes and edges.\n    print_summary : bool\n        If true it will print the summary of the graph.\n\n    Returns\n    -------\n    str\n        A string with the summary of the graph.\n    \"\"\"\n    summary = \"\"\n\n    summary += \"Graph summary:\\n\"\n    summary += f\"Number of nodes: {self.num_nodes}\\n\"\n    summary += f\"Number of edges: {self.num_edges}\\n\"\n    summary += f\"Number of overlaps: {len(self.overlaps())}\\n\"\n\n    time_points = self.time_points()\n    summary += f\"Number of distinct time points: {len(time_points)}\\n\"\n    if len(time_points) &gt; 0:\n        summary += f\"Start time: {min(time_points)}\\n\"\n        summary += f\"End time: {max(time_points)}\\n\"\n    else:\n        summary += \"No time points found.\\n\"\n\n    if attrs_stats:\n        nodes_attrs = self.node_attrs()\n        edges_attrs = self.edge_attrs()\n        summary += \"\\nNodes attributes:\\n\"\n        summary += str(nodes_attrs.describe())\n        summary += \"\\nEdges attributes:\\n\"\n        summary += str(edges_attrs.describe())\n\n    if print_summary:\n        print(summary)\n\n    return summary\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.summary(attrs_stats)","title":"<code>attrs_stats</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true it will print statistics about the attributes of the nodes and edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.summary(print_summary)","title":"<code>print_summary</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true it will print the summary of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(shape: tuple[int, ...], output_dir: str | Path, track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, overwrite: bool = False) -&gt; None\n</code></pre> <p>Save the graph to a CTC ground truth directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_ctc--parameters","title":"Parameters","text":"<p>shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X) output_dir : str | Path     The directory to save the graph to. track_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_ctc--examples","title":"Examples","text":"<pre><code># ...\nsolution_graph = solver.solve(graph)\nsolution_graph.assign_track_ids()\nsolution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_ctc--see-also","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_ctc(\n    self,\n    shape: tuple[int, ...],\n    output_dir: str | Path,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save the graph to a CTC ground truth directory.\n\n    Parameters\n    ----------\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X)\n    output_dir : str | Path\n        The directory to save the graph to.\n    track_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    Examples\n    --------\n    ```python\n    # ...\n    solution_graph = solver.solve(graph)\n    solution_graph.assign_track_ids()\n    solution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n    ```\n\n    See Also\n    --------\n    [to_ctc][tracksdata.io.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import to_ctc\n\n    to_ctc(\n        graph=self,\n        shape=shape,\n        output_dir=output_dir,\n        track_id_key=track_id_key,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_geff","title":"to_geff","text":"<pre><code>to_geff(geff_store: StoreLike, geff_metadata: GeffMetadata | None = None, zarr_format: Literal[2, 3] = 3) -&gt; None\n</code></pre> <p>Write the graph to a geff data directory.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_geff(\n    self,\n    geff_store: StoreLike,\n    geff_metadata: GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None:\n    \"\"\"\n    Write the graph to a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to write the graph to.\n    geff_metadata : GeffMetadata | None\n        The geff metadata to write to the graph.\n        It automatically generates the metadata with:\n        - axes: time (t) and spatial axes ((z), y, x)\n        - tracklet node property: track_id\n    zarr_format : Literal[2, 3]\n        The zarr format to write the graph to.\n        Defaults to 3.\n    \"\"\"\n\n    node_attrs = self.node_attrs()\n\n    if DEFAULT_ATTR_KEYS.MASK in node_attrs.columns:\n        node_attrs = column_to_bytes(node_attrs, DEFAULT_ATTR_KEYS.MASK)\n\n    if geff_metadata is None:\n        axes = [Axis(name=DEFAULT_ATTR_KEYS.T, type=\"time\")]\n        axes.extend([Axis(name=c, type=\"space\") for c in (\"z\", \"y\", \"x\") if c in node_attrs.columns])\n\n        if DEFAULT_ATTR_KEYS.TRACK_ID in node_attrs.columns:\n            track_node_props = {\n                \"tracklet\": DEFAULT_ATTR_KEYS.TRACK_ID,\n            }\n        else:\n            track_node_props = None\n\n        geff_metadata = GeffMetadata(\n            directed=True,\n            axes=axes,\n            track_node_props=track_node_props,\n        )\n\n    edge_attrs = self.edge_attrs().drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    node_dict = {\n        k: (column_to_numpy(v), None) for k, v in node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID).to_dict().items()\n    }\n\n    edge_ids = edge_attrs.select(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET).to_numpy()\n\n    edge_dict = {\n        k: (column_to_numpy(v), None)\n        for k, v in edge_attrs.drop(\n            DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n            DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        )\n        .to_dict()\n        .items()\n    }\n\n    write_arrays(\n        geff_store,\n        metadata=geff_metadata,\n        node_ids=node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy(),\n        node_props=node_dict,\n        edge_ids=edge_ids,\n        edge_props=edge_dict,\n        zarr_format=zarr_format,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to write the graph to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_geff(geff_metadata)","title":"<code>geff_metadata</code>","text":"(<code>GeffMetadata | None</code>, default:                   <code>None</code> )           \u2013            <p>The geff metadata to write to the graph. It automatically generates the metadata with: - axes: time (t) and spatial axes ((z), y, x) - tracklet node property: track_id</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_geff(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The zarr format to write the graph to. Defaults to 3.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.tracklet_graph","title":"tracklet_graph","text":"<pre><code>tracklet_graph(track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, ignore_track_id: int | None = None) -&gt; rx.PyDiGraph\n</code></pre> <p>Create a compressed tracklet graph where each node is a tracklet and each edge is a transition between tracklets.</p> <p>IMPORTANT: rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values. And edge values are the tuple of source and target tracklet ids.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed tracklet graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def tracklet_graph(\n    self,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    ignore_track_id: int | None = None,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Create a compressed tracklet graph where each node is a tracklet\n    and each edge is a transition between tracklets.\n\n    IMPORTANT:\n    rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values.\n    And edge values are the tuple of source and target tracklet ids.\n\n    Parameters\n    ----------\n    track_id_key : str\n        The key of the track id attribute.\n    ignore_track_id : int | None\n        The track id to ignore. If None, all track ids are used.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed tracklet graph.\n    \"\"\"\n\n    if track_id_key not in self.node_attr_keys:\n        raise ValueError(f\"Track id key '{track_id_key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n    with Session(self._engine) as session:\n        node_query = sa.select(getattr(self.Node, track_id_key)).distinct()\n\n        SourceNode = aliased(self.Node)\n        TargetNode = aliased(self.Node)\n\n        edge_query = (\n            sa.select(\n                getattr(self.Edge, DEFAULT_ATTR_KEYS.EDGE_SOURCE),\n                getattr(self.Edge, DEFAULT_ATTR_KEYS.EDGE_TARGET),\n            )\n            .join(\n                SourceNode,\n                SourceNode.node_id == self.Edge.source_id,\n            )\n            .join(\n                TargetNode,\n                TargetNode.node_id == self.Edge.target_id,\n            )\n            .filter(\n                getattr(SourceNode, track_id_key) != getattr(TargetNode, track_id_key),\n            )\n        )\n\n        if ignore_track_id is not None:\n            node_query = node_query.filter(getattr(self.Node, track_id_key) != ignore_track_id)\n            edge_query = edge_query.filter(\n                getattr(SourceNode, track_id_key) != ignore_track_id,\n                getattr(TargetNode, track_id_key) != ignore_track_id,\n            )\n\n        edge_query = edge_query.with_only_columns(\n            getattr(SourceNode, track_id_key).label(\"source_track_id\"),\n            getattr(TargetNode, track_id_key).label(\"target_track_id\"),\n        )\n\n        nodes_df = pl.read_database(\n            self._raw_query(node_query),\n            connection=session.connection(),\n        )\n\n        edges_df = pl.read_database(\n            self._raw_query(edge_query),\n            connection=session.connection(),\n        )\n\n    graph = rx.PyDiGraph()\n    tracklet_ids = nodes_df[track_id_key].to_list()\n    tracklet_id_to_rx = dict(zip(tracklet_ids, graph.add_nodes_from(tracklet_ids), strict=False))\n    graph.add_edges_from(\n        zip(\n            edges_df[\"source_track_id\"].map_elements(tracklet_id_to_rx.__getitem__, return_dtype=int).to_list(),\n            edges_df[\"target_track_id\"].map_elements(tracklet_id_to_rx.__getitem__, return_dtype=int).to_list(),\n            zip(edges_df[\"source_track_id\"].to_list(), edges_df[\"target_track_id\"].to_list(), strict=False),\n            strict=True,\n        )\n    )\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.tracklet_graph(track_id_key)","title":"<code>track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.tracklet_graph(ignore_track_id)","title":"<code>ignore_track_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The track id to ignore. If None, all track ids are used.</p>"},{"location":"reference/tracksdata/graph/filters/","title":"tracksdata.graph.filters","text":""},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters","title":"tracksdata.graph.filters","text":"<p>Classes:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>Spatial filter for bounding box queries on graph nodes.</p> </li> <li> <code>SpatialFilter</code>           \u2013            <p>Spatial filtering for graph nodes using spatial indexing.</p> </li> </ul>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter","title":"BBoxSpatialFilter","text":"<pre><code>BBoxSpatialFilter(graph: BaseGraph, frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T, bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX)\n</code></pre> <p>Spatial filter for bounding box queries on graph nodes.</p> <p>This filter allows querying nodes within a bounding box defined by minimum and maximum coordinates for each spatial dimension.</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter--parameters","title":"Parameters","text":"<p>graph : BaseGraph     The graph containing nodes with spatial coordinates. frame_attr_key : str | None, optional     The attribute key representing the frame or time dimension.     Default is None.     If None it will only use the bounding box coordinates. bbox_attr_key : str, optional     The attribute key representing the bounding box coordinates.     Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>.     The bounding box coordinates should be in the format:     [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]     where each dimension has a min and max value.</p> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Query nodes that overlaps with a spatial region of interest.</p> </li> </ul> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def __init__(\n    self,\n    graph: \"BaseGraph\",\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n) -&gt; None:\n    from spatial_graph import PointRTree\n\n    self._graph = graph\n\n    if frame_attr_key is None:\n        attr_keys = [DEFAULT_ATTR_KEYS.NODE_ID, bbox_attr_key]\n    else:\n        attr_keys = [DEFAULT_ATTR_KEYS.NODE_ID, frame_attr_key, bbox_attr_key]\n    nodes_df = graph.node_attrs(attr_keys=attr_keys)\n    node_ids = np.ascontiguousarray(nodes_df[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy(), dtype=np.int64).copy()\n\n    if nodes_df.is_empty():\n        self._node_rtree = None\n    else:\n        bboxes = nodes_df[bbox_attr_key].to_numpy()\n        if bboxes.shape[1] % 2 != 0:\n            raise ValueError(f\"Bounding box coordinates must have even number of dimensions, got {bboxes.shape[1]}\")\n        num_dims = bboxes.shape[1] // 2\n\n        if frame_attr_key is None:\n            self._ndims = num_dims\n            positions_min = np.ascontiguousarray(bboxes[:, :num_dims], dtype=np.float32)\n            positions_max = np.ascontiguousarray(bboxes[:, num_dims:], dtype=np.float32)\n        else:\n            frames = nodes_df[frame_attr_key].to_numpy()\n            self._ndims = num_dims + 1  # +1 for the frame dimension\n            positions_min = np.ascontiguousarray(\n                np.hstack((frames[:, np.newaxis], bboxes[:, :num_dims])), dtype=np.float32\n            )\n            positions_max = np.ascontiguousarray(\n                np.hstack((frames[:, np.newaxis], bboxes[:, num_dims:])), dtype=np.float32\n            )\n        self._node_rtree = PointRTree(\n            item_dtype=\"int64\",\n            coord_dtype=\"float32\",\n            dims=self._ndims,\n        )\n        self._node_rtree.insert_bb_items(node_ids, positions_min, positions_max)\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(keys: tuple[slice, ...]) -&gt; BaseFilter\n</code></pre> <p>Query nodes that overlaps with a spatial region of interest.</p> <p>Uses spatial indexing to efficiently find nodes whose bounding boxes fall within the specified bounds for each spatial dimension.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BaseFilter</code>           \u2013            <p>A filter containing only nodes and their edges that fall within the spatial ROI.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the number of slices doesn't match the number of coordinate dimensions.</p> </li> </ul> <p>Examples:</p> <pre><code># For 2D spatial filter with the bounding boxes\n# overlapping with the region [10, 20] x [50, 60]\nspatial_filter = BBoxSpatialFilter(graph, bbox_attr_key=\"bbox\")\nfilter = spatial_filter[10:50, 20:60]\n\n# For 4D spatial filter with the t in [0, 10] and\n# bounding boxes overlapping with the region [0, 5] x [10, 50] x [20, 60]\nspatial_filter = BBoxSpatialFilter(graph, frame_attr_key=\"t\", bbox_attr_key=\"bbox\")\nsubgraph = spatial_filter[0:10, 0:5, 10:50, 20:60].subgraph()\n</code></pre> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def __getitem__(self, keys: tuple[slice, ...]) -&gt; \"BaseFilter\":\n    \"\"\"\n    Query nodes that overlaps with a spatial region of interest.\n\n    Uses spatial indexing to efficiently find nodes whose bounding boxes fall within\n    the specified bounds for each spatial dimension.\n\n    Parameters\n    ----------\n    keys : tuple[slice, ...]\n        Tuple of slices defining the spatial bounds for each coordinate dimension.\n        Must match the number of coordinate dimensions specified in attr_keys.\n        Each slice defines [start, stop] bounds for that dimension.\n\n    Returns\n    -------\n    BaseFilter\n        A filter containing only nodes and their edges that fall within the spatial ROI.\n\n    Raises\n    ------\n    ValueError\n        If the number of slices doesn't match the number of coordinate dimensions.\n\n    Examples\n    --------\n    ```python\n    # For 2D spatial filter with the bounding boxes\n    # overlapping with the region [10, 20] x [50, 60]\n    spatial_filter = BBoxSpatialFilter(graph, bbox_attr_key=\"bbox\")\n    filter = spatial_filter[10:50, 20:60]\n\n    # For 4D spatial filter with the t in [0, 10] and\n    # bounding boxes overlapping with the region [0, 5] x [10, 50] x [20, 60]\n    spatial_filter = BBoxSpatialFilter(graph, frame_attr_key=\"t\", bbox_attr_key=\"bbox\")\n    subgraph = spatial_filter[0:10, 0:5, 10:50, 20:60].subgraph()\n    ```\n    \"\"\"\n\n    if self._node_rtree is None:\n        return self._graph.filter(node_ids=[])\n\n    for key in keys:\n        if key.start is None or key.stop is None:\n            raise ValueError(f\"Slice {key} must have start and stop\")\n\n    if len(keys) != self._ndims:\n        raise ValueError(f\"Expected {self._ndims} keys, got {len(keys)}\")\n\n    node_ids = self._node_rtree.search(\n        *(\n            np.stack(\n                [[s.start, s.stop] for s in keys],\n                axis=1,\n                dtype=np.float32,\n            )\n        )\n    )\n    return self._graph.filter(node_ids=node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter.__getitem__(keys)","title":"<code>keys</code>","text":"(<code>tuple[slice, ...]</code>)           \u2013            <p>Tuple of slices defining the spatial bounds for each coordinate dimension. Must match the number of coordinate dimensions specified in attr_keys. Each slice defines [start, stop] bounds for that dimension.</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.SpatialFilter","title":"SpatialFilter","text":"<pre><code>SpatialFilter(graph: BaseGraph, attr_keys: list[str] | None = None)\n</code></pre> <p>Spatial filtering for graph nodes using spatial indexing.</p> <p>This filter creates a spatial index of graph nodes based on their spatial coordinates and allows efficient querying of nodes within spatial regions of interest (ROI).</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.SpatialFilter--parameters","title":"Parameters","text":"<p>graph : BaseGraph     The graph containing nodes with spatial coordinates. attr_keys : list[str] | None, optional     List of attribute keys to use as spatial coordinates. If None, defaults to     [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.SpatialFilter--examples","title":"Examples","text":"<pre><code>graph = RustWorkXGraph()\n# Add nodes with spatial coordinates\ngraph.add_node({\"t\": 0, \"y\": 10, \"x\": 20})\ngraph.add_node({\"t\": 1, \"y\": 30, \"x\": 40})\n\n# Create spatial filter with 2D coordinates\nspatial_filter = SpatialFilter(graph, attr_keys=[\"y\", \"x\"])\n\n# Query nodes in spatial region\nsubgraph = spatial_filter[0:50, 0:50]\n</code></pre> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Query nodes within a spatial region of interest.</p> </li> </ul> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def __init__(\n    self,\n    graph: \"BaseGraph\",\n    attr_keys: list[str] | None = None,\n) -&gt; None:\n    if attr_keys is None:\n        attr_keys = [\"t\", \"z\", \"y\", \"x\"]\n        valid_keys = set(graph.node_attr_keys)\n        attr_keys = list(filter(lambda x: x in valid_keys, attr_keys))\n\n    self._graph = graph\n\n    nodes_df = graph.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, *attr_keys])\n    node_ids = nodes_df[DEFAULT_ATTR_KEYS.NODE_ID]\n\n    self._df_filter = DataFrameSpatialFilter(indices=node_ids, df=nodes_df.select(attr_keys))\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.SpatialFilter.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(keys: tuple[slice, ...]) -&gt; BaseFilter\n</code></pre> <p>Query nodes within a spatial region of interest.</p> <p>Uses spatial indexing to efficiently find nodes whose coordinates fall within the specified bounds for each spatial dimension.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BaseFilter</code>           \u2013            <p>A filter containing only nodes and their edges that fall within the spatial ROI.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the number of slices doesn't match the number of coordinate dimensions.</p> </li> </ul> <p>Examples:</p> <pre><code># For 2D spatial filter with [\"y\", \"x\"] coordinates\nfilter = spatial_filter[10:50, 20:60]\n\n# For 4D spatial filter with [\"t\", \"z\", \"y\", \"x\"] coordinates\nsubgraph = spatial_filter[0:10, 0:5, 10:50, 20:60].subgraph()\n</code></pre> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def __getitem__(self, keys: tuple[slice, ...]) -&gt; \"BaseFilter\":\n    \"\"\"\n    Query nodes within a spatial region of interest.\n\n    Uses spatial indexing to efficiently find nodes whose coordinates fall within\n    the specified bounds for each spatial dimension.\n\n    Parameters\n    ----------\n    keys : tuple[slice, ...]\n        Tuple of slices defining the spatial bounds for each coordinate dimension.\n        Must match the number of coordinate dimensions specified in attr_keys.\n        Each slice defines [start, stop) bounds for that dimension.\n\n    Returns\n    -------\n    BaseFilter\n        A filter containing only nodes and their edges that fall within the spatial ROI.\n\n    Raises\n    ------\n    ValueError\n        If the number of slices doesn't match the number of coordinate dimensions.\n\n    Examples\n    --------\n    ```python\n    # For 2D spatial filter with [\"y\", \"x\"] coordinates\n    filter = spatial_filter[10:50, 20:60]\n\n    # For 4D spatial filter with [\"t\", \"z\", \"y\", \"x\"] coordinates\n    subgraph = spatial_filter[0:10, 0:5, 10:50, 20:60].subgraph()\n    ```\n    \"\"\"\n    node_ids = self._df_filter[keys]\n    return self._graph.filter(node_ids=node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.SpatialFilter.__getitem__(keys)","title":"<code>keys</code>","text":"(<code>tuple[slice, ...]</code>)           \u2013            <p>Tuple of slices defining the spatial bounds for each coordinate dimension. Must match the number of coordinate dimensions specified in attr_keys. Each slice defines [start, stop) bounds for that dimension.</p>"},{"location":"reference/tracksdata/io/","title":"tracksdata.io","text":""},{"location":"reference/tracksdata/io/#tracksdata.io","title":"tracksdata.io","text":"<p>Input/output utilities for loading and saving tracking data in various formats.</p> <p>Functions:</p> <ul> <li> <code>compressed_tracks_table</code>             \u2013              <p>Compress the tracks of a graph into a (n, 4)-tabular format.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Load a CTC ground truth file into a graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save a graph to a CTC data directory.</p> </li> </ul>"},{"location":"reference/tracksdata/io/#tracksdata.io.compressed_tracks_table","title":"compressed_tracks_table","text":"<pre><code>compressed_tracks_table(graph: BaseGraph) -&gt; np.ndarray\n</code></pre> <p>Compress the tracks of a graph into a (n, 4)-tabular format.</p> <p>Where - n is the number of tracks - 4 is the number of columns:     - track_id: the track ID     - start: the start frame     - end: the end frame     - parent_track_id: the parent track ID</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tracks</code> (              <code>ndarray</code> )          \u2013            <p>The compressed tracks.</p> </li> </ul> Source code in <code>src/tracksdata/io/_ctc.py</code> <pre><code>def compressed_tracks_table(graph: BaseGraph) -&gt; np.ndarray:\n    \"\"\"\n    Compress the tracks of a graph into a (n, 4)-tabular format.\n\n    Where\n    - n is the number of tracks\n    - 4 is the number of columns:\n        - track_id: the track ID\n        - start: the start frame\n        - end: the end frame\n        - parent_track_id: the parent track ID\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to compress the tracks from.\n\n    Returns\n    -------\n    tracks : np.ndarray\n        The compressed tracks.\n    \"\"\"\n    nodes_df = graph.node_attrs(\n        attr_keys=[\n            DEFAULT_ATTR_KEYS.NODE_ID,\n            DEFAULT_ATTR_KEYS.T,\n            DEFAULT_ATTR_KEYS.TRACK_ID,\n        ]\n    )\n\n    tracks_data = []\n    node_ids = []\n\n    for (track_id,), group in nodes_df.group_by(DEFAULT_ATTR_KEYS.TRACK_ID):\n        start = group[DEFAULT_ATTR_KEYS.T].min()\n        end = group[DEFAULT_ATTR_KEYS.T].max()\n        tracks_data.append([track_id, start, end, 0])\n        node_ids.append(group.filter(pl.col(DEFAULT_ATTR_KEYS.T) == start)[DEFAULT_ATTR_KEYS.NODE_ID].item())\n\n    parents = graph.predecessors(\n        node_ids,\n        attr_keys=[DEFAULT_ATTR_KEYS.TRACK_ID],\n    )\n    for track_id, node_id in zip(tracks_data, node_ids, strict=True):\n        df = parents[node_id]\n        if len(df) &gt; 0:\n            track_id[3] = df[DEFAULT_ATTR_KEYS.TRACK_ID].item()\n\n    if len(tracks_data) == 0:\n        return np.empty((0, 4), dtype=int)\n\n    out_array = np.asarray(tracks_data, dtype=int)\n    out_array = out_array[np.argsort(out_array[:, 0])]\n\n    return out_array\n</code></pre>"},{"location":"reference/tracksdata/io/#tracksdata.io.compressed_tracks_table(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to compress the tracks from.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.from_ctc","title":"from_ctc","text":"<pre><code>from_ctc(data_dir: str | Path, graph: BaseGraph, region_props_kwargs: dict[str, Any] | None = None) -&gt; None\n</code></pre> <p>Load a CTC ground truth file into a graph. The resulting graph will have region properties attributes from a CTC data directory.</p> <p>Graph backend method API (e.g. <code>graph.from_ctc</code>) is preferred over this function.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. graph : BaseGraph     The graph to load the CTC data into. region_props_kwargs : dict[str, Any]     Keyword arguments to pass to RegionPropsNodes.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.from_ctc--examples","title":"Examples","text":"<pre><code>from tracksdata.io import from_ctc\nfrom tracksdata.graph import RustWorkXGraph\n\ngraph = RustWorkXGraph()\nfrom_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\", graph)\n</code></pre>"},{"location":"reference/tracksdata/io/#tracksdata.io.from_ctc--see-also","title":"See Also","text":"<p>BaseGraph.from_ctc:     Create a graph from a CTC data directory.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p> Source code in <code>src/tracksdata/io/_ctc.py</code> <pre><code>def from_ctc(\n    data_dir: str | Path,\n    graph: BaseGraph,\n    region_props_kwargs: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Load a CTC ground truth file into a graph.\n    The resulting graph will have region properties attributes from a CTC data directory.\n\n    Graph backend method API (e.g. `graph.from_ctc`) is preferred over this function.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    graph : BaseGraph\n        The graph to load the CTC data into.\n    region_props_kwargs : dict[str, Any]\n        Keyword arguments to pass to RegionPropsNodes.\n\n    Examples\n    --------\n    ```python\n    from tracksdata.io import from_ctc\n    from tracksdata.graph import RustWorkXGraph\n\n    graph = RustWorkXGraph()\n    from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\", graph)\n    ```\n\n    See Also\n    --------\n    [BaseGraph.from_ctc][tracksdata.graph.BaseGraph.from_ctc]:\n        Create a graph from a CTC data directory.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    \"\"\"\n    data_dir = Path(data_dir)\n    if not data_dir.exists():\n        raise FileNotFoundError(f\"Data directory {data_dir} does not exist.\")\n\n    if region_props_kwargs is None:\n        region_props_kwargs = {}\n\n    if \"extra_properties\" not in region_props_kwargs:\n        region_props_kwargs[\"extra_properties\"] = [\"label\"]\n\n    elif \"label\" not in region_props_kwargs[\"extra_properties\"]:\n        region_props_kwargs[\"extra_properties\"].append(\"label\")\n\n    tracks_file_found = False\n    track_id_graph = {}\n\n    for tracks_file in [\"man_track.txt\", \"res_track.txt\"]:\n        tracks_file_path = data_dir / tracks_file\n        if tracks_file_path.exists():\n            tracks_file_found = True\n            track_id_graph = _load_tracks_file(tracks_file_path)\n            break\n\n    if not tracks_file_found:\n        LOG.warning(\n            f\"Tracks file {data_dir}/man_track.txt and {data_dir}/res_track.txt does not exist.\\n\"\n            \"Graph won't have edges.\"\n        )\n\n    labels = dask_imread(str(data_dir / \"*.tif\"), imread=tiff.imread)\n\n    region_props_nodes = RegionPropsNodes(**region_props_kwargs)\n    region_props_nodes.add_nodes(graph, labels=labels)\n\n    nodes_df = graph.node_attrs(\n        attr_keys=[\n            DEFAULT_ATTR_KEYS.NODE_ID,\n            DEFAULT_ATTR_KEYS.T,\n            \"label\",\n        ]\n    )\n\n    _add_edges_from_track_ids(\n        graph,\n        nodes_df,\n        track_id_graph,\n        \"label\",\n    )\n\n    # is duplicating an attribute that bad?\n    graph.add_node_attr_key(DEFAULT_ATTR_KEYS.TRACK_ID, -1)\n    graph.update_node_attrs(\n        node_ids=nodes_df[DEFAULT_ATTR_KEYS.NODE_ID].to_list(),\n        attrs={\n            DEFAULT_ATTR_KEYS.TRACK_ID: nodes_df[\"label\"].to_list(),\n        },\n    )\n</code></pre>"},{"location":"reference/tracksdata/io/#tracksdata.io.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(graph: BaseGraph, shape: tuple[int, ...], output_dir: str | Path, track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, overwrite: bool = False) -&gt; None\n</code></pre> <p>Save a graph to a CTC data directory.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.to_ctc--parameters","title":"Parameters","text":"<p>graph : BaseGraph     The graph to save. shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X) output_dir : str | Path     The directory to save the label images and the tracks graph to. track_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.to_ctc--see-also","title":"See Also","text":"<p>BaseGraph.to_ctc:     Functional API to export into a CTC data directory.</p> Source code in <code>src/tracksdata/io/_ctc.py</code> <pre><code>def to_ctc(\n    graph: BaseGraph,\n    shape: tuple[int, ...],\n    output_dir: str | Path,\n    track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save a graph to a CTC data directory.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to save.\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X)\n    output_dir : str | Path\n        The directory to save the label images and the tracks graph to.\n    track_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    See Also\n    --------\n    [BaseGraph.to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Functional API to export into a CTC data directory.\n    \"\"\"\n    output_dir = Path(output_dir)\n    if output_dir.exists():\n        if overwrite:\n            shutil.rmtree(output_dir)\n        # and not empty\n        elif any(output_dir.iterdir()):\n            raise FileExistsError(f\"Output directory {output_dir} already exists.\")\n\n    output_dir = Path(output_dir)\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    view = GraphArrayView(graph, shape=shape, attr_key=track_id_key)\n\n    n_digits = max(len(str(view.shape[0])), 3)\n\n    tracks_table = compressed_tracks_table(graph)\n\n    np.savetxt(output_dir / \"res_track.txt\", tracks_table, fmt=\"%d\")\n\n    def _write_tiff(t: int) -&gt; None:\n        LOG.info(f\"Saving label image for time point {t}\")\n        tiff.imwrite(\n            output_dir / f\"mask{t:0{n_digits}d}.tif\",\n            view[t],\n            compression=\"LZW\",\n        )\n\n    list(\n        multiprocessing_apply(\n            _write_tiff,\n            range(view.shape[0]),\n            desc=\"Saving label images\",\n            sorted=False,\n        )\n    )\n</code></pre>"},{"location":"reference/tracksdata/metrics/","title":"tracksdata.metrics","text":""},{"location":"reference/tracksdata/metrics/#tracksdata.metrics","title":"tracksdata.metrics","text":"<p>Evaluation metrics for tracking performance, including the CTC benchmark metrics.</p> <p>If you use this module, please cite the respective papers of each metric, as described in here.</p> <p>Functions:</p> <ul> <li> <code>evaluate_ctc_metrics</code>             \u2013              <p>Evaluate CTC metrics using <code>py-ctcmetrics</code> developed by Timo Kaiser.</p> </li> <li> <code>visualize_matches</code>             \u2013              <p>Visualize the matches between the graph and the gt_graph.</p> </li> </ul>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics","title":"evaluate_ctc_metrics","text":"<pre><code>evaluate_ctc_metrics(input_graph: RustWorkXGraph, reference_graph: RustWorkXGraph, input_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, reference_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, input_reset: bool = True, reference_reset: bool = False, metrics: list[str] | None = None) -&gt; dict[str, float]\n</code></pre> <p>Evaluate CTC metrics using <code>py-ctcmetrics</code> developed by Timo Kaiser.</p> <p>If you use this function, please cite the respective papers of each metric, as described in here.</p> <p>IMPORTANT: The <code>SEG</code> metric is computed from the TRA masks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, float]</code>           \u2013            <p>Dictionary with the results of the evaluated metrics.</p> </li> </ul> Source code in <code>src/tracksdata/metrics/_ctc_metrics.py</code> <pre><code>def evaluate_ctc_metrics(\n    input_graph: \"RustWorkXGraph\",\n    reference_graph: \"RustWorkXGraph\",\n    input_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    reference_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    input_reset: bool = True,\n    reference_reset: bool = False,\n    metrics: list[str] | None = None,\n) -&gt; dict[str, float]:\n    \"\"\"\n    Evaluate CTC metrics using `py-ctcmetrics` developed by [Timo Kaiser](https://github.com/TimoK93).\n\n    If you use this function, please cite the respective papers of each metric, as described in\n    [here](https://github.com/CellTrackingChallenge/py-ctcmetrics?tab=readme-ov-file#acknowledgement-and-citations).\n\n    IMPORTANT: The `SEG` metric is computed from the TRA masks.\n\n    Parameters\n    ----------\n    input_graph : RustWorkXGraph\n        Input graph.\n    reference_graph : RustWorkXGraph\n        Reference graph.\n    input_track_id_key : str, optional\n        Key to obtain the track id from the input graph.\n        If key does not exist, it will be created.\n    reference_track_id_key : str, optional\n        Key to obtain the track id from the reference graph.\n        If key does not exist, it will be created.\n    input_reset : bool, optional\n        Whether to reset the track ids of the input graph. If True, the track ids will be reset to -1.\n    reference_reset : bool, optional\n        Whether to reset the track ids of the reference graph. If True, the track ids will be reset to -1.\n    metrics : list[str] | None, optional\n        List of metrics to evaluate. If None, all metrics are evaluated.\n        Available metrics:\n        \"CHOTA\", \"BC\", \"CT\", \"CCA\", \"TF\", \"TRA\", \"DET\", \"MOTA\", \"HOTA\",\n        \"IDF1\", \"MTML\", \"FAF\", \"LNK\", \"OP_CTB\", \"OP_CSB\", \"BIO\", \"OP_CLB\"\n\n    Returns\n    -------\n    dict[str, float]\n        Dictionary with the results of the evaluated metrics.\n    \"\"\"\n    try:\n        from ctc_metrics.metrics import ALL_METRICS\n        from ctc_metrics.scripts.evaluate import calculate_metrics\n    except ImportError as e:\n        raise ImportError(\n            \"`py-ctcmetrics` is required to evaluate CTC metrics.\\nPlease install it with `pip install py-ctcmetrics`.\"\n        ) from e\n\n    if metrics is None:\n        metrics: list[str] = ALL_METRICS.copy()\n\n    if \"SEG\" in metrics:\n        LOG.warning(\"IMPORTANT! 'SEG' metric results are based on TRA masks, not the SEG masks.\")\n\n    if input_graph.num_nodes == 0:\n        LOG.warning(\"Input graph has no nodes, returning -1.0 for all metrics.\")\n        return dict.fromkeys(metrics, -1.0)\n\n    if input_track_id_key not in input_graph.node_attr_keys:\n        input_graph.assign_track_ids(input_track_id_key, reset=input_reset)\n\n    if reference_track_id_key not in reference_graph.node_attr_keys:\n        reference_graph.assign_track_ids(reference_track_id_key, reset=reference_reset)\n\n    input_tracks, reference_tracks, matching_data = compute_ctc_metrics_data(\n        input_graph, reference_graph, input_track_id_key, reference_track_id_key\n    )\n\n    results = calculate_metrics(\n        comp_tracks=input_tracks,\n        ref_tracks=reference_tracks,\n        traj=matching_data,\n        segm=matching_data,\n        metrics=metrics,\n        is_valid=True,\n    )\n\n    results = {k: v.item() if hasattr(v, \"item\") else v for k, v in results.items()}\n\n    return results\n</code></pre>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(input_graph)","title":"<code>input_graph</code>","text":"(<code>RustWorkXGraph</code>)           \u2013            <p>Input graph.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(reference_graph)","title":"<code>reference_graph</code>","text":"(<code>RustWorkXGraph</code>)           \u2013            <p>Reference graph.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(input_track_id_key)","title":"<code>input_track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>Key to obtain the track id from the input graph. If key does not exist, it will be created.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(reference_track_id_key)","title":"<code>reference_track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>Key to obtain the track id from the reference graph. If key does not exist, it will be created.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(input_reset)","title":"<code>input_reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset the track ids of the input graph. If True, the track ids will be reset to -1.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(reference_reset)","title":"<code>reference_reset</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to reset the track ids of the reference graph. If True, the track ids will be reset to -1.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(metrics)","title":"<code>metrics</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of metrics to evaluate. If None, all metrics are evaluated. Available metrics: \"CHOTA\", \"BC\", \"CT\", \"CCA\", \"TF\", \"TRA\", \"DET\", \"MOTA\", \"HOTA\", \"IDF1\", \"MTML\", \"FAF\", \"LNK\", \"OP_CTB\", \"OP_CSB\", \"BIO\", \"OP_CLB\"</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches","title":"visualize_matches","text":"<pre><code>visualize_matches(input_graph: BaseGraph, ref_graph: BaseGraph, matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID, match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE, matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK, viewer: Optional[Viewer] = None, points_kwargs: dict | None = None, vector_kwargs: dict | None = None) -&gt; None\n</code></pre> <p>Visualize the matches between the graph and the gt_graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/metrics/_visualize.py</code> <pre><code>def visualize_matches(\n    input_graph: BaseGraph,\n    ref_graph: BaseGraph,\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n    viewer: Optional[\"napari.Viewer\"] = None,\n    points_kwargs: dict | None = None,\n    vector_kwargs: dict | None = None,\n) -&gt; None:\n    \"\"\"\n    Visualize the matches between the graph and the gt_graph.\n\n    Parameters\n    ----------\n    input_graph : BaseGraph\n        The predicted graph to visualize.\n    ref_graph : BaseGraph\n        The reference (ground truth) graph to visualize.\n    matched_node_id_key : str, optional\n        The key of the attribute that contains the matched node IDs.\n        If not provided, the default key will be used.\n    match_score_key : str, optional\n        The key of the attribute that contains the match scores.\n        If not provided, the default key will be used.\n    matched_edge_mask_key : str, optional\n        The key of the attribute that contains the matched edge mask.\n        If not provided, the default key will be used.\n    viewer : napari.Viewer, optional\n        The napari viewer to use. If not provided, a new viewer will be created.\n    points_kwargs : dict, optional\n        Additional keyword arguments to the napari.Viewer.add_points method.\n    vector_kwargs : dict, optional\n        Additional keyword arguments to the napari.Viewer.add_vectors method.\n    \"\"\"\n    try:\n        import napari\n    except ImportError as e:\n        raise ImportError(\n            \"napari must be installed to use this function.\\nPlease install it with `pip install napari`.\",\n        ) from e\n\n    if viewer is None:\n        viewer = napari.Viewer()\n\n    if \"z\" in input_graph.node_attr_keys:\n        pos = [\"t\", \"z\", \"y\", \"x\"]\n    else:\n        pos = [\"t\", \"y\", \"x\"]\n\n    node_attrs = input_graph.node_attrs()\n    ref_node_attrs = ref_graph.node_attrs()\n\n    matched_points_kwargs = _add_matching_text_and_color(points_kwargs)\n    points_kwargs = _points_kwargs_defaults(points_kwargs)\n\n    layer = viewer.add_points(\n        node_attrs[pos],\n        name=\"predicted\",\n        properties={\n            \"matched_node_id\": node_attrs[matched_node_id_key],\n            \"match_score\": node_attrs[match_score_key],\n            \"matched\": node_attrs[matched_node_id_key] &gt;= 0,\n        },\n        **matched_points_kwargs,\n    )\n    layer.text.visible = False\n\n    matched_ref_mask = ref_node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].is_in(node_attrs[matched_node_id_key].implode())\n    # matched_ref_node_attrs = ref_node_attrs.filter(matched_ref_mask)\n    unmatched_ref_node_attrs = ref_node_attrs.filter(~matched_ref_mask)\n\n    viewer.add_points(\n        unmatched_ref_node_attrs[pos],\n        name=\"missing objects\",\n        **points_kwargs,\n    )\n\n    edge_attrs = input_graph.edge_attrs(attr_keys=[matched_edge_mask_key])\n    source_pos = [f\"source_{p}\" for p in pos]\n    target_pos = [f\"target_{p}\" for p in pos]\n\n    source_mapping = dict(zip(pos, source_pos, strict=False))\n    source_mapping[matched_node_id_key] = \"matched_source\"\n    target_mapping = dict(zip(pos, target_pos, strict=False))\n    target_mapping[matched_node_id_key] = \"matched_target\"\n\n    edge_attrs = edge_attrs.join(\n        node_attrs.select(DEFAULT_ATTR_KEYS.NODE_ID, matched_node_id_key, *pos).rename(source_mapping),\n        left_on=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n        right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n    ).join(\n        node_attrs.select(DEFAULT_ATTR_KEYS.NODE_ID, matched_node_id_key, *pos).rename(target_mapping),\n        left_on=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n    )\n\n    # target positions is just the difference between source and target\n    # not the actual target position\n    edge_attrs[target_pos] = edge_attrs[target_pos] - edge_attrs[source_pos]\n\n    mask = edge_attrs[matched_edge_mask_key].to_numpy().astype(bool)\n\n    edge_arr = np.stack(\n        [\n            edge_attrs.select(*source_pos),\n            edge_attrs.select(*target_pos),\n        ],\n        axis=1,\n    )\n\n    matched_edge_arr = edge_arr[mask]\n    unmatched_edge_arr = edge_arr[~mask]\n\n    vector_kwargs = _vector_kwargs_defaults(vector_kwargs)\n\n    if matched_edge_arr.shape[0] &gt; 0:\n        viewer.add_vectors(\n            matched_edge_arr,\n            name=\"matched edges\",\n            edge_color=\"green\",\n            opacity=1,\n            **vector_kwargs,\n        )\n    else:\n        LOG.warning(\"No edges matched to the reference graph\")\n\n    if unmatched_edge_arr.shape[0] &gt; 0:\n        viewer.add_vectors(\n            unmatched_edge_arr,\n            name=\"unmatched input edges\",\n            edge_color=\"blue\",\n            opacity=0.2,\n            **vector_kwargs,\n        )\n    else:\n        LOG.warning(\"All edges matched to the reference graph\")\n\n    ref_edge_attrs = ref_graph.edge_attrs(attr_keys=[])\n\n    ref_edge_attrs = ref_edge_attrs.join(\n        edge_attrs.select(\n            matched_edge_mask_key,\n            \"matched_source\",\n            \"matched_target\",\n        ),\n        left_on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        right_on=[\"matched_source\", \"matched_target\"],\n        how=\"left\",\n    )\n\n    unmatched_ref_edge_attrs = ref_edge_attrs.filter(ref_edge_attrs[matched_edge_mask_key].is_null())\n\n    # not necessary anymore\n    del source_mapping[matched_node_id_key]\n    del target_mapping[matched_node_id_key]\n\n    unmatched_ref_edge_attrs = unmatched_ref_edge_attrs.join(\n        ref_node_attrs.select(DEFAULT_ATTR_KEYS.NODE_ID, *pos).rename(source_mapping),\n        left_on=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n        right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n    ).join(\n        ref_node_attrs.select(DEFAULT_ATTR_KEYS.NODE_ID, *pos).rename(target_mapping),\n        left_on=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n    )\n\n    # same as above, target positions is just the difference between source and target\n    unmatched_ref_edge_attrs[target_pos] = unmatched_ref_edge_attrs[target_pos] - unmatched_ref_edge_attrs[source_pos]\n\n    unmatched_ref_edge_arr = np.stack(\n        [\n            unmatched_ref_edge_attrs.select(*source_pos),\n            unmatched_ref_edge_attrs.select(*target_pos),\n        ],\n        axis=1,\n    )\n\n    viewer.add_vectors(\n        unmatched_ref_edge_arr,\n        name=\"unmatched reference edges\",\n        edge_color=\"yellow\",\n        opacity=1,\n        **vector_kwargs,\n    )\n</code></pre>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(input_graph)","title":"<code>input_graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The predicted graph to visualize.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(ref_graph)","title":"<code>ref_graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The reference (ground truth) graph to visualize.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the attribute that contains the matched node IDs. If not provided, the default key will be used.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the attribute that contains the match scores. If not provided, the default key will be used.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the attribute that contains the matched edge mask. If not provided, the default key will be used.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(viewer)","title":"<code>viewer</code>","text":"(<code>Viewer</code>, default:                   <code>None</code> )           \u2013            <p>The napari viewer to use. If not provided, a new viewer will be created.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(points_kwargs)","title":"<code>points_kwargs</code>","text":"(<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to the napari.Viewer.add_points method.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(vector_kwargs)","title":"<code>vector_kwargs</code>","text":"(<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to the napari.Viewer.add_vectors method.</p>"},{"location":"reference/tracksdata/nodes/","title":"tracksdata.nodes","text":""},{"location":"reference/tracksdata/nodes/#tracksdata.nodes","title":"tracksdata.nodes","text":"<p>Node operators for creating nodes and their respective attributes (e.g. masks) in a graph.</p> <p>Classes:</p> <ul> <li> <code>GenericFuncNodeAttrs</code>           \u2013            <p>Operator to apply a function to a node and insert the result as a new attribute.</p> </li> <li> <code>Mask</code>           \u2013            <p>Object used to store an individual segmentation mask of a single instance (object)</p> </li> <li> <code>MaskDiskAttrs</code>           \u2013            <p>Operator to create a disk mask for each node.</p> </li> <li> <code>RandomNodes</code>           \u2013            <p>Generate random node coordinates for testing and simulation purposes.</p> </li> <li> <code>RegionPropsNodes</code>           \u2013            <p>Operator that adds nodes to a graph using scikit-image's regionprops.</p> </li> </ul>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs","title":"GenericFuncNodeAttrs","text":"<pre><code>GenericFuncNodeAttrs(func: Callable[[T], R] | Callable[[list[T]], list[R]], output_key: str, default_value: Any = None, attr_keys: Sequence[str] = (), batch_size: int = 0)\n</code></pre> <p>               Bases: <code>BaseNodeAttrsOperator</code></p> <p>Operator to apply a function to a node and insert the result as a new attribute.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>video = ...\ngraph = ...\n\n\ndef intensity_median_times_t(image: NDArray, mask: Mask, t: int) -&gt; float:\n    cropped_frame = mask.crop(image)\n    valid_pixels = cropped_frame[mask.mask]\n    return np.median(valid_pixels) * t\n\n\ncrop_attrs = GenericFuncNodeAttrs(\n    func=intensity_median,\n    output_key=\"intensity_median\",\n    attr_keys=[\"mask\", \"t\"],\n)\n\ncrop_attrs.add_node_attrs(graph, frames=video)\n</code></pre> <p>With batching:</p> <pre><code>video = ...\ngraph = ...\n\n\ndef intensity_median_times_t(image: NDArray, masks: list[Mask], t: list[int]) -&gt; list[float]:\n    results = []\n    for i in range(len(masks)):\n        cropped_frame = masks[i].crop(image)\n        valid_pixels = cropped_frame[masks[i].mask]\n        value = np.median(valid_pixels) * t[i]\n        results.append(value)\n    return results\n\n\ncrop_attrs = GenericFuncNodeAttrs(\n    func=intensity_median,\n    output_key=\"intensity_median\",\n    attr_keys=[\"mask\", \"t\"],\n)\n\ncrop_attrs.add_node_attrs(graph, frames=video)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_node_attrs</code>             \u2013              <p>Add attributes to nodes of a graph.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[[T], R] | Callable[[list[T]], list[R]],\n    output_key: str,\n    default_value: Any = None,\n    attr_keys: Sequence[str] = (),\n    batch_size: int = 0,\n) -&gt; None:\n    super().__init__(output_key)\n    self.func = func\n    self.attr_keys = attr_keys\n    self.default_value = default_value\n    self.batch_size = batch_size\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(func)","title":"<code>func</code>","text":"(<code>Callable[[T], R] | Callable[[list[T]], list[R]]</code>)           \u2013            <p>Function to apply to the node. If <code>frames</code> is provided when calling <code>add_node_attrs</code>, the function must accept a single argument for the frame. Otherwise, the function must accept two arguments for the mask and the additional arguments.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>)           \u2013            <p>Key of the new attribute to add.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            <p>Additional attributes to pass to the <code>func</code> as keyword arguments.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Default value to use for the new attribute. TODO: this should be replaced by a more advanced typing that takes default values.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Batch size to use for the function. If 0, the function will be called for each node separately. If &gt; 0, the function will be called for each batch of nodes and return a list of results. The batch size is the number of nodes that will be passed to the function at once. Batch only contains nodes from the same time point.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._init_node_attrs","title":"_init_node_attrs","text":"<pre><code>_init_node_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the node attributes for the graph.</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def _init_node_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the node attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.node_attr_keys:\n        graph.add_node_attr_key(self.output_key, default_value=self.default_value)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time","title":"_node_attrs_per_time","text":"<pre><code>_node_attrs_per_time(t: int, *, graph: BaseGraph, frames: NDArray | None = None) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add attributes to nodes of a graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def _node_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n    frames: NDArray | None = None,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add attributes to nodes of a graph.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add attributes for.\n    graph : BaseGraph\n        The graph to add attributes to.\n    frames : NDArray | None\n        The frames to index by time point to pass to the `func` function.\n        Such that, when provided, `frames[t]` will be passed to the `func` function.\n    \"\"\"\n    # Get node IDs for the specified time point\n    graph_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n\n    if graph_filter.is_empty():\n        LOG.warning(f\"No nodes at time point {t}\")\n        return []\n\n    # Get attributes for these nodes\n    node_attrs = graph_filter.node_attrs(attr_keys=self.attr_keys)\n\n    args = []\n    if frames is not None:\n        args.append(np.asarray(frames[t]))\n\n    results = []\n    if self.batch_size &gt; 0:\n        size = len(node_attrs)\n        for i in range(0, size, self.batch_size):\n            batch_node_attrs = node_attrs.slice(i, self.batch_size)\n            batch_results = self.func(*args, **batch_node_attrs.to_dict())\n            results.extend(batch_results)\n\n    else:\n        for data_dict in node_attrs.rows(named=True):\n            result = self.func(*args, **data_dict)\n            results.append(result)\n\n    return graph_filter.node_ids(), {self.output_key: results}\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add attributes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time(frames)","title":"<code>frames</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>The frames to index by time point to pass to the <code>func</code> function. Such that, when provided, <code>frames[t]</code> will be passed to the <code>func</code> function.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs","title":"add_node_attrs","text":"<pre><code>add_node_attrs(graph: BaseGraph, *, t: int | None = None, frames: NDArray | None = None) -&gt; None\n</code></pre> <p>Add attributes to nodes of a graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def add_node_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    frames: NDArray | None = None,\n) -&gt; None:\n    \"\"\"\n    Add attributes to nodes of a graph.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    frames : NDArray | None\n        The frames to index by time point to pass to the `func` function.\n        Such that `frames[t]` will be passed to the `func` function.\n    \"\"\"\n    super().add_node_attrs(graph, t=t, frames=frames)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs(frames)","title":"<code>frames</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>The frames to index by time point to pass to the <code>func</code> function. Such that <code>frames[t]</code> will be passed to the <code>func</code> function.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask","title":"Mask","text":"<pre><code>Mask(mask: NDArray[bool_], bbox: ArrayLike)\n</code></pre> <p>Object used to store an individual segmentation mask of a single instance (object)</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask--parameters","title":"Parameters","text":"<p>mask : NDArray[np.bool_]     A binary indicating the pixels that are part of the object (e.g. cell, nucleus, etc.). bbox : np.ndarray     The bounding box of the region of interest with shape (2 * ndim,).     The first ndim elements are the start indices and the last ndim elements are the end indices.     Equivalent to slicing a numpy array with <code>[start:end]</code>. Examples</p> <pre><code>mask = Mask(mask=np.array([[True, False], [False, True]]), bbox=np.array([0, 0, 2, 2]))\n</code></pre> <p>Methods:</p> <ul> <li> <code>crop</code>             \u2013              <p>Crop the mask from an image.</p> </li> <li> <code>from_coordinates</code>             \u2013              <p>Create a mask from a center and a radius.</p> </li> <li> <code>intersection</code>             \u2013              <p>Compute the intersection between two masks considering their bounding boxes location.</p> </li> <li> <code>iou</code>             \u2013              <p>Compute the Intersection over Union (IoU) between two masks</p> </li> <li> <code>mask_indices</code>             \u2013              <p>Get the indices of the pixels that are part of the object.</p> </li> <li> <code>paint_buffer</code>             \u2013              <p>Paint object into a buffer.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>size</code>               (<code>int</code>)           \u2013            <p>Get the number of pixels that are part of the object.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def __init__(\n    self,\n    mask: NDArray[np.bool_],\n    bbox: ArrayLike,\n):\n    self._mask = mask\n    self.bbox = bbox\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.size","title":"size  <code>cached</code> <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>Get the number of pixels that are part of the object.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.crop","title":"crop","text":"<pre><code>crop(image: NDArray, shape: tuple[int, ...] | None = None) -&gt; NDArray\n</code></pre> <p>Crop the mask from an image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NDArray</code>           \u2013            <p>The cropped image.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def crop(\n    self,\n    image: NDArray,\n    shape: tuple[int, ...] | None = None,\n) -&gt; NDArray:\n    \"\"\"\n    Crop the mask from an image.\n\n    Parameters\n    ----------\n    image : NDArray\n        The image to crop from.\n    shape : tuple[int, ...] | None\n        The shape of the cropped image. If None, the `bbox` will be used.\n\n    Returns\n    -------\n    NDArray\n        The cropped image.\n    \"\"\"\n    if shape is None:\n        ndim = self._mask.ndim\n        slicing = tuple(slice(self._bbox[i], self._bbox[i + ndim]) for i in range(ndim))\n\n    else:\n        center = (self._bbox[: self._mask.ndim] + self._bbox[self._mask.ndim :]) // 2\n        half_shape = np.asarray(shape) // 2\n        start = np.maximum(center - half_shape, 0)\n        end = np.minimum(center + half_shape, image.shape)\n        slicing = tuple(slice(s, e) for s, e in zip(start, end, strict=True))\n\n    return image[slicing]\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.crop(image)","title":"<code>image</code>","text":"(<code>NDArray</code>)           \u2013            <p>The image to crop from.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.crop(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the cropped image. If None, the <code>bbox</code> will be used.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates","title":"from_coordinates  <code>classmethod</code>","text":"<pre><code>from_coordinates(center: NDArray, radius: int, image_shape: tuple[int, ...] | None = None) -&gt; Mask\n</code></pre> <p>Create a mask from a center and a radius. Regions outside the image are cropped.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Mask</code>           \u2013            <p>The mask.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>@classmethod\ndef from_coordinates(\n    cls,\n    center: NDArray,\n    radius: int,\n    image_shape: tuple[int, ...] | None = None,\n) -&gt; \"Mask\":\n    \"\"\"\n    Create a mask from a center and a radius.\n    Regions outside the image are cropped.\n\n    Parameters\n    ----------\n    center : NDArray\n        The center of the mask.\n    radius : int\n        The radius of the mask.\n    image_shape : tuple[int, ...] | None\n        The shape of the image.\n        When provided crops regions outside the image.\n\n    Returns\n    -------\n    Mask\n        The mask.\n    \"\"\"\n    mask = _spherical_mask(radius, len(center))\n    center = np.round(center).astype(int)\n\n    start = center - np.asarray(mask.shape) // 2\n    end = start + mask.shape\n\n    if image_shape is None:\n        bbox = np.concatenate([start, end])\n    else:\n        processed_start = np.maximum(start, 0)\n        processed_end = np.minimum(end, image_shape)\n\n        start_overhang = processed_start - start\n        end_overhang = end - processed_end\n\n        mask = mask[\n            tuple(slice(s, -e if e &gt; 0 else None) for s, e in zip(start_overhang, end_overhang, strict=True))\n        ]\n\n        bbox = np.concatenate([processed_start, processed_end])\n\n    return cls(mask, bbox)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates(center)","title":"<code>center</code>","text":"(<code>NDArray</code>)           \u2013            <p>The center of the mask.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates(radius)","title":"<code>radius</code>","text":"(<code>int</code>)           \u2013            <p>The radius of the mask.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates(image_shape)","title":"<code>image_shape</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the image. When provided crops regions outside the image.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.intersection","title":"intersection","text":"<pre><code>intersection(other: Mask) -&gt; float\n</code></pre> <p>Compute the intersection between two masks considering their bounding boxes location.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The intersection between the two masks.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def intersection(self, other: \"Mask\") -&gt; float:\n    \"\"\"\n    Compute the intersection between two masks considering their bounding boxes location.\n\n    Parameters\n    ----------\n    other : Mask\n        The other mask to compute the intersection with.\n\n    Returns\n    -------\n    float\n        The intersection between the two masks.\n    \"\"\"\n    return fast_intersection_with_bbox(self._bbox, other._bbox, self._mask, other._mask)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.intersection(other)","title":"<code>other</code>","text":"(<code>Mask</code>)           \u2013            <p>The other mask to compute the intersection with.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.iou","title":"iou","text":"<pre><code>iou(other: Mask) -&gt; float\n</code></pre> <p>Compute the Intersection over Union (IoU) between two masks considering their bounding boxes location.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The IoU between the two masks.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def iou(self, other: \"Mask\") -&gt; float:\n    \"\"\"\n    Compute the Intersection over Union (IoU) between two masks\n    considering their bounding boxes location.\n\n    Parameters\n    ----------\n    other : Mask\n        The other mask to compute the IoU with.\n\n    Returns\n    -------\n    float\n        The IoU between the two masks.\n    \"\"\"\n    return fast_iou_with_bbox(self._bbox, other._bbox, self._mask, other._mask)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.iou(other)","title":"<code>other</code>","text":"(<code>Mask</code>)           \u2013            <p>The other mask to compute the IoU with.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.mask_indices","title":"mask_indices","text":"<pre><code>mask_indices(offset: NDArray[integer] | int = 0) -&gt; tuple[NDArray[np.integer], ...]\n</code></pre> <p>Get the indices of the pixels that are part of the object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[NDArray[integer], ...]</code>           \u2013            <p>The indices of the pixels that are part of the object.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def mask_indices(\n    self,\n    offset: NDArray[np.integer] | int = 0,\n) -&gt; tuple[NDArray[np.integer], ...]:\n    \"\"\"\n    Get the indices of the pixels that are part of the object.\n\n    Parameters\n    ----------\n    offset : NDArray[np.integer] | int, optional\n        The offset to add to the indices, should be used with bounding box information.\n\n    Returns\n    -------\n    tuple[NDArray[np.integer], ...]\n        The indices of the pixels that are part of the object.\n    \"\"\"\n    if isinstance(offset, int):\n        offset = np.full(self._mask.ndim, offset)\n\n    indices = list(np.nonzero(self._mask))\n\n    for i, index in enumerate(indices):\n        indices[i] = index + self._bbox[i] + offset[i]\n\n    return tuple(indices)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.mask_indices(offset)","title":"<code>offset</code>","text":"(<code>NDArray[integer] | int</code>, default:                   <code>0</code> )           \u2013            <p>The offset to add to the indices, should be used with bounding box information.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer","title":"paint_buffer","text":"<pre><code>paint_buffer(buffer: ndarray, value: int | float, offset: NDArray[integer] | int = 0) -&gt; None\n</code></pre> <p>Paint object into a buffer.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def paint_buffer(\n    self,\n    buffer: np.ndarray,\n    value: int | float,\n    offset: NDArray[np.integer] | int = 0,\n) -&gt; None:\n    \"\"\"\n    Paint object into a buffer.\n\n    Parameters\n    ----------\n    buffer : np.ndarray\n        The buffer to paint inplace.\n    value : int | float\n        The value to paint the object.\n    offset : NDArray[np.integer] | int, optional\n        The offset to add to the indices, should be used with bounding box information.\n    \"\"\"\n    if isinstance(offset, int):\n        offset = np.full(self._mask.ndim, offset)\n\n    window = tuple(\n        slice(i + o, j + o)\n        for i, j, o in zip(self._bbox[: self._mask.ndim], self._bbox[self._mask.ndim :], offset, strict=True)\n    )\n    buffer[window][self._mask] = value\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer(buffer)","title":"<code>buffer</code>","text":"(<code>ndarray</code>)           \u2013            <p>The buffer to paint inplace.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer(value)","title":"<code>value</code>","text":"(<code>int | float</code>)           \u2013            <p>The value to paint the object.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer(offset)","title":"<code>offset</code>","text":"(<code>NDArray[integer] | int</code>, default:                   <code>0</code> )           \u2013            <p>The offset to add to the indices, should be used with bounding box information.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs","title":"MaskDiskAttrs","text":"<pre><code>MaskDiskAttrs(radius: int, image_shape: tuple[int, ...], attr_keys: Sequence[str] | None = None, output_key: str = DEFAULT_ATTR_KEYS.MASK)\n</code></pre> <p>               Bases: <code>GenericFuncNodeAttrs</code></p> <p>Operator to create a disk mask for each node.</p> <p>Masks are created in space, so temporal information should not be provided.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_node_attrs</code>             \u2013              <p>Add attributes to nodes of a graph.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def __init__(\n    self,\n    radius: int,\n    image_shape: tuple[int, ...],\n    attr_keys: Sequence[str] | None = None,\n    output_key: str = DEFAULT_ATTR_KEYS.MASK,\n):\n    if attr_keys is None:\n        default_columns = [\"z\", \"y\", \"x\"]\n        attr_keys = default_columns[-len(image_shape) :]\n\n    if len(attr_keys) != len(image_shape):\n        raise ValueError(\n            f\"Expected image shape {image_shape} to have the same number of dimensions as attr_keys '{attr_keys}'.\"\n        )\n\n    super().__init__(\n        func=lambda **kwargs: Mask.from_coordinates(\n            center=np.asarray(list(kwargs.values())),\n            radius=radius,\n            image_shape=image_shape,\n        ),\n        output_key=output_key,\n        attr_keys=attr_keys,\n        default_value=None,\n        batch_size=0,\n    )\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs(radius)","title":"<code>radius</code>","text":"(<code>int</code>)           \u2013            <p>The radius of the mask.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs(image_shape)","title":"<code>image_shape</code>","text":"(<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the image, must match the number of  of the attr_keys.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The attributes for the center of the mask. If not provided, \"z\", \"y\", \"x\" will be used.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>MASK</code> )           \u2013            <p>The key of the attribute to store the mask.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs._init_node_attrs","title":"_init_node_attrs","text":"<pre><code>_init_node_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the node attributes for the graph.</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def _init_node_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the node attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.node_attr_keys:\n        graph.add_node_attr_key(self.output_key, default_value=self.default_value)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs._node_attrs_per_time","title":"_node_attrs_per_time","text":"<pre><code>_node_attrs_per_time(t: int, *, graph: BaseGraph, frames: NDArray | None = None) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add attributes to nodes of a graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def _node_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n    frames: NDArray | None = None,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add attributes to nodes of a graph.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add attributes for.\n    graph : BaseGraph\n        The graph to add attributes to.\n    frames : NDArray | None\n        The frames to index by time point to pass to the `func` function.\n        Such that, when provided, `frames[t]` will be passed to the `func` function.\n    \"\"\"\n    # Get node IDs for the specified time point\n    graph_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n\n    if graph_filter.is_empty():\n        LOG.warning(f\"No nodes at time point {t}\")\n        return []\n\n    # Get attributes for these nodes\n    node_attrs = graph_filter.node_attrs(attr_keys=self.attr_keys)\n\n    args = []\n    if frames is not None:\n        args.append(np.asarray(frames[t]))\n\n    results = []\n    if self.batch_size &gt; 0:\n        size = len(node_attrs)\n        for i in range(0, size, self.batch_size):\n            batch_node_attrs = node_attrs.slice(i, self.batch_size)\n            batch_results = self.func(*args, **batch_node_attrs.to_dict())\n            results.extend(batch_results)\n\n    else:\n        for data_dict in node_attrs.rows(named=True):\n            result = self.func(*args, **data_dict)\n            results.append(result)\n\n    return graph_filter.node_ids(), {self.output_key: results}\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs._node_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add attributes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs._node_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs._node_attrs_per_time(frames)","title":"<code>frames</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>The frames to index by time point to pass to the <code>func</code> function. Such that, when provided, <code>frames[t]</code> will be passed to the <code>func</code> function.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs.add_node_attrs","title":"add_node_attrs","text":"<pre><code>add_node_attrs(graph: BaseGraph, *, t: int | None = None, frames: NDArray | None = None) -&gt; None\n</code></pre> <p>Add attributes to nodes of a graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def add_node_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    frames: NDArray | None = None,\n) -&gt; None:\n    \"\"\"\n    Add attributes to nodes of a graph.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    frames : NDArray | None\n        The frames to index by time point to pass to the `func` function.\n        Such that `frames[t]` will be passed to the `func` function.\n    \"\"\"\n    super().add_node_attrs(graph, t=t, frames=frames)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs.add_node_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs.add_node_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs.add_node_attrs(frames)","title":"<code>frames</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>The frames to index by time point to pass to the <code>func</code> function. Such that <code>frames[t]</code> will be passed to the <code>func</code> function.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes","title":"RandomNodes","text":"<pre><code>RandomNodes(n_time_points: int, n_nodes_per_tp: tuple[int, int], n_dim: Literal[2, 3] = 3, random_state: int = 0)\n</code></pre> <p>               Bases: <code>BaseNodesOperator</code></p> <p>Generate random node coordinates for testing and simulation purposes.</p> <p>RandomNodes creates nodes with randomly distributed coordinates within the unit hypercube [0,1]^n. This is useful for testing tracking algorithms, generating synthetic datasets, or creating baseline comparisons. The number of nodes per time point can vary randomly within a specified range.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>n_time_points</code>               (<code>int</code>)           \u2013            <p>Number of time points to generate.</p> </li> <li> <code>n_nodes</code>               (<code>tuple[int, int]</code>)           \u2013            <p>Range of nodes per time point.</p> </li> <li> <code>spatial_cols</code>               (<code>list[str]</code>)           \u2013            <p>Names of spatial coordinate columns.</p> </li> <li> <code>rng</code>               (<code>Generator</code>)           \u2013            <p>Random number generator instance.</p> </li> </ul> See Also <p>RegionPropsNodes:     Extract nodes from segmented images using region properties.</p> <p>Mask:     Node operator for mask-based objects.</p> <p>Examples:</p> <p>Generate 2D random nodes:</p> <pre><code>from tracksdata.nodes import RandomNodes\n\nnode_op = RandomNodes(n_time_points=10, n_nodes_per_tp=(5, 15), n_dim=2, random_state=42)\n</code></pre> <p>Add nodes to a graph:</p> <pre><code>node_op.add_nodes(graph)\n</code></pre> <p>Generate nodes for a specific time point:</p> <pre><code>node_op.add_nodes(graph, t=5)\n</code></pre> <p>Use 3D coordinates with consistent node count:</p> <pre><code>node_op = RandomNodes(\n    n_time_points=20,\n    n_nodes_per_tp=(10, 10),  # exactly 10 nodes per time point\n    n_dim=3,\n)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_nodes</code>             \u2013              <p>Override the base add_nodes method to handle n_time_points parameter.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_random.py</code> <pre><code>def __init__(\n    self,\n    n_time_points: int,\n    n_nodes_per_tp: tuple[int, int],\n    n_dim: Literal[2, 3] = 3,\n    random_state: int = 0,\n):\n    super().__init__()\n    if isinstance(n_nodes_per_tp, int):\n        raise ValueError(\"`n_nodes_per_tp` must be a tuple of two integers\")\n\n    self.n_time_points = n_time_points\n    self.n_nodes = n_nodes_per_tp\n\n    if n_dim == 2:\n        self.spatial_cols = [\"x\", \"y\"]\n    elif n_dim == 3:\n        self.spatial_cols = [\"x\", \"y\", \"z\"]\n    else:\n        raise ValueError(f\"Invalid number of dimensions: {n_dim}\")\n\n    self.rng = np.random.default_rng(random_state)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(n_time_points)","title":"<code>n_time_points</code>","text":"(<code>int</code>)           \u2013            <p>The number of time points to generate nodes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(n_nodes_per_tp)","title":"<code>n_nodes_per_tp</code>","text":"(<code>tuple[int, int]</code>)           \u2013            <p>The minimum and maximum number of nodes to generate per time point. The actual number is randomly chosen within this range for each time point.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(n_dim)","title":"<code>n_dim</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The spatial dimensionality of the coordinates:</p> <ul> <li>2: generates (x, y) coordinates</li> <li>3: generates (x, y, z) coordinates</li> </ul>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(random_state)","title":"<code>random_state</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Random seed for reproducible results.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes._nodes_per_time","title":"_nodes_per_time","text":"<pre><code>_nodes_per_time(t: int, **kwargs: Any) -&gt; list[dict[str, Any]]\n</code></pre> <p>Add nodes for a specific time point.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>The nodes to add to the graph.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_random.py</code> <pre><code>def _nodes_per_time(\n    self,\n    t: int,\n    **kwargs: Any,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Add nodes for a specific time point.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add nodes for.\n    **kwargs : Any\n        Additional keyword arguments to pass to add_node.\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        The nodes to add to the graph.\n    \"\"\"\n    n_nodes_at_t = self.rng.integers(\n        self.n_nodes[0],\n        self.n_nodes[1],\n    )\n\n    coords = self.rng.uniform(\n        low=0,\n        high=1,\n        size=(n_nodes_at_t, len(self.spatial_cols)),\n    ).tolist()\n\n    return [{\"t\": t, **dict(zip(self.spatial_cols, c, strict=True)), **kwargs} for c in coords]\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes._nodes_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add nodes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes._nodes_per_time(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to add_node.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(graph: BaseGraph, *, t: int | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Override the base add_nodes method to handle n_time_points parameter.</p> <p>When t=None, iterates over range(n_time_points) instead of graph.time_points(). When t is specified, uses the base implementation.</p> Source code in <code>src/tracksdata/nodes/_random.py</code> <pre><code>def add_nodes(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Override the base add_nodes method to handle n_time_points parameter.\n\n    When t=None, iterates over range(n_time_points) instead of graph.time_points().\n    When t is specified, uses the base implementation.\n    \"\"\"\n    # Register each spatial column individually\n    for col in self.spatial_cols:\n        if col not in graph.node_attr_keys:\n            graph.add_node_attr_key(col, -999999.0)\n\n    if t is None:\n        time_points = range(self.n_time_points)\n    else:\n        time_points = [t]\n\n    _add_nodes_per_time = curry(self._nodes_per_time, **kwargs)\n    for node_attrs in multiprocessing_apply(\n        _add_nodes_per_time,\n        time_points,\n        desc=\"Adding nodes\",\n    ):\n        graph.bulk_add_nodes(node_attrs)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes","title":"RegionPropsNodes","text":"<pre><code>RegionPropsNodes(extra_properties: list[str | Callable[[RegionProperties], Any]] | None = None, spacing: tuple[float, float] | None = None)\n</code></pre> <p>               Bases: <code>BaseNodesOperator</code></p> <p>Operator that adds nodes to a graph using scikit-image's regionprops.</p> <p>Extracts region properties from labeled images to create graph nodes using scikit-image's regionprops function to compute geometric and intensity-based features. Automatically adds centroid coordinates and mask information, with additional properties computed based on the extra_properties parameter.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes--parameters","title":"Parameters","text":"<p>extra_properties : list[str | Callable[[RegionProperties], Any]] | None, optional     Additional properties to compute for each region. Can be:     - String names of built-in regionprops properties (e.g., 'area', 'perimeter')     - Callable functions that take a RegionProperties object and return a value     If None, only centroid coordinates and masks are extracted. spacing : tuple[float, float] | None, optional     Physical spacing between pixels. If provided, affects distance-based     measurements. Should be (row_spacing, col_spacing) for 2D or     (depth_spacing, row_spacing, col_spacing) for 3D.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes--attributes","title":"Attributes","text":"<p>_extra_properties : list     List of additional properties to compute. _spacing : tuple[float, float] | None     Physical spacing between pixels.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes--examples","title":"Examples","text":"<p>Create a basic RegionPropsNodes operator:</p> <pre><code>from tracksdata.nodes import RegionPropsNodes\n\nnode_op = RegionPropsNodes()\n</code></pre> <p>Add common geometric properties:</p> <pre><code>node_op = RegionPropsNodes(extra_properties=[\"area\", \"perimeter\", \"eccentricity\"])\n</code></pre> <p>Add custom properties using functions:</p> <pre><code>def custom_property(region):\n    return region.area / region.perimeter\n\n\nnode_op = RegionPropsNodes(extra_properties=[\"area\", custom_property])\n</code></pre> <p>Use with physical spacing:</p> <pre><code>node_op = RegionPropsNodes(\n    spacing=(0.5, 0.1, 0.1),  # z, y, x spacing\n    extra_properties=[\"area\", \"volume\"],\n)\n</code></pre> <p>Add nodes from a time series:</p> <pre><code>labels_series = np.random.randint(0, 10, (10, 100, 100))\nnode_op.add_nodes(graph, labels=labels_series)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_nodes</code>             \u2013              <p>Add nodes to a graph using region properties from labeled images.</p> </li> <li> <code>attr_keys</code>             \u2013              <p>Get the keys of the node attributes that will be extracted.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def __init__(\n    self,\n    extra_properties: list[str | Callable[[RegionProperties], Any]] | None = None,\n    spacing: tuple[float, float] | None = None,\n):\n    super().__init__()\n    self._extra_properties = extra_properties or []\n    self._spacing = spacing\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._axis_names","title":"_axis_names","text":"<pre><code>_axis_names(labels: NDArray[integer]) -&gt; list[str]\n</code></pre> <p>Get the names of the axes of the labels.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The names of the axes of the labels.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def _axis_names(self, labels: NDArray[np.integer]) -&gt; list[str]:\n    \"\"\"\n    Get the names of the axes of the labels.\n\n    Parameters\n    ----------\n    labels : NDArray[np.integer]\n        The (t + nD) labels to get the axis names for.\n\n    Returns\n    -------\n    list[str]\n        The names of the axes of the labels.\n    \"\"\"\n    if labels.ndim == 3:\n        return [\"y\", \"x\"]\n    elif labels.ndim == 4:\n        return [\"z\", \"y\", \"x\"]\n    else:\n        raise ValueError(f\"`labels` must be 't + 2D' or 't + 3D', got '{labels.ndim}' dimensions.\")\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._axis_names(labels)","title":"<code>labels</code>","text":"(<code>NDArray[integer]</code>)           \u2013            <p>The (t + nD) labels to get the axis names for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._init_node_attrs","title":"_init_node_attrs","text":"<pre><code>_init_node_attrs(graph: BaseGraph, axis_names: list[str]) -&gt; None\n</code></pre> <p>Initialize the node attributes for the graph.</p> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def _init_node_attrs(self, graph: BaseGraph, axis_names: list[str]) -&gt; None:\n    \"\"\"\n    Initialize the node attributes for the graph.\n    \"\"\"\n    for attr_key in [DEFAULT_ATTR_KEYS.MASK, DEFAULT_ATTR_KEYS.BBOX]:\n        if attr_key not in graph.node_attr_keys:\n            graph.add_node_attr_key(attr_key, None)\n\n    # initialize the attribute keys\n    for attr_key in axis_names + self.attr_keys():\n        if attr_key not in graph.node_attr_keys:\n            graph.add_node_attr_key(attr_key, -1.0)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time","title":"_nodes_per_time","text":"<pre><code>_nodes_per_time(t: int, *, labels: NDArray[integer], intensity_image: NDArray | None = None) -&gt; list[dict[str, Any]]\n</code></pre> <p>Add nodes for a specific time point using region properties.</p> <p>Processes a single time point, computing region properties for each labeled region and creating corresponding graph nodes. Determines spatial dimensions from label shape, ensures required attribute keys exist, computes region properties, extracts coordinates and extra properties, creates mask objects, and bulk adds all nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>The nodes to add to the graph.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If labels is not 2D or 3D.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def _nodes_per_time(\n    self,\n    t: int,\n    *,\n    labels: NDArray[np.integer],\n    intensity_image: NDArray | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Add nodes for a specific time point using region properties.\n\n    Processes a single time point, computing region properties for each labeled\n    region and creating corresponding graph nodes. Determines spatial dimensions\n    from label shape, ensures required attribute keys exist, computes region\n    properties, extracts coordinates and extra properties, creates mask objects,\n    and bulk adds all nodes.\n\n    Parameters\n    ----------\n    t : int\n        The time point to assign to the created nodes.\n    labels : NDArray[np.integer]\n        2D or 3D labeled image for a single time point.\n    intensity_image : NDArray | None, optional\n        Corresponding intensity image for computing intensity-based properties.\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        The nodes to add to the graph.\n\n    Raises\n    ------\n    ValueError\n        If labels is not 2D or 3D.\n    \"\"\"\n    axis_names = self._axis_names(labels)\n\n    labels = np.asarray(labels[t])\n\n    if intensity_image is not None:\n        intensity_image = np.asarray(intensity_image[t])\n\n    nodes_data = []\n\n    for obj in regionprops(\n        labels,\n        intensity_image=intensity_image,\n        spacing=self._spacing,\n        cache=True,\n    ):\n        attrs = dict(zip(axis_names, obj.centroid, strict=False))\n\n        for prop in self._extra_properties:\n            if callable(prop):\n                attrs[prop.__name__] = prop(obj)\n            else:\n                attrs[prop] = getattr(obj, prop)\n\n        attrs[DEFAULT_ATTR_KEYS.MASK] = Mask(obj.image, obj.bbox)\n        attrs[DEFAULT_ATTR_KEYS.BBOX] = np.asarray(obj.bbox, dtype=int)\n        attrs[DEFAULT_ATTR_KEYS.T] = t\n\n        nodes_data.append(attrs)\n        obj._cache.clear()  # clearing to reduce memory footprint\n\n    if len(nodes_data) == 0:\n        LOG.warning(\"No valid nodes found for time point %d\", t)\n\n    return nodes_data\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to assign to the created nodes.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time(labels)","title":"<code>labels</code>","text":"(<code>NDArray[integer]</code>)           \u2013            <p>2D or 3D labeled image for a single time point.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time(intensity_image)","title":"<code>intensity_image</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>Corresponding intensity image for computing intensity-based properties.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(graph: BaseGraph, *, labels: NDArray[integer], t: int | None = None, intensity_image: NDArray | None = None) -&gt; None\n</code></pre> <p>Add nodes to a graph using region properties from labeled images.</p> <p>Extracts region properties from labeled images and creates corresponding nodes in the graph. Can handle both single time point and time series data. When t is None, the first axis of labels represents time and processes each time point sequentially. Automatically initializes required attribute keys in the graph schema before adding nodes.</p> <p>Parameters:</p> <p>Examples:</p> <p>Add nodes from a single 2D labeled image:</p> <pre><code>labels = skimage.measure.label(binary_image)\nnode_op.add_nodes(graph, labels=labels, t=0)\n</code></pre> <p>Add nodes from a time series:</p> <pre><code>labels_series = np.stack(\n    [\n        skimage.measure.label(binary_image_t0),\n        skimage.measure.label(binary_image_t1),\n    ]\n)\nnode_op.add_nodes(graph, labels=labels_series)\n</code></pre> <p>Add nodes with intensity information:</p> <pre><code>node_op.add_nodes(graph, labels=labels, t=0, intensity_image=fluorescence_image)\n</code></pre> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>@override\ndef add_nodes(\n    self,\n    graph: BaseGraph,\n    *,\n    labels: NDArray[np.integer],\n    t: int | None = None,\n    intensity_image: NDArray | None = None,\n) -&gt; None:\n    \"\"\"\n    Add nodes to a graph using region properties from labeled images.\n\n    Extracts region properties from labeled images and creates corresponding\n    nodes in the graph. Can handle both single time point and time series data.\n    When t is None, the first axis of labels represents time and processes each\n    time point sequentially. Automatically initializes required attribute keys\n    in the graph schema before adding nodes.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add nodes to.\n    labels : NDArray[np.integer]\n        Labeled image(s) where each unique positive integer represents\n        a different region/object. Can be:\n        - 3D array (time, height, width) for 2D time series\n        - 4D array (time, depth, height, width) for 3D time series\n        When `t` is provided, it should be padded to include the time dimension.\n    t : int | None, optional\n        Time point for the nodes. If None, labels are treated as a time\n        series where the first axis represents time.\n    intensity_image : NDArray | None, optional\n        Intensity image(s) corresponding to the labels. Used for computing\n        intensity-based properties. Must have the same shape as labels\n        (excluding the label values).\n\n    Examples\n    --------\n    Add nodes from a single 2D labeled image:\n\n    ```python\n    labels = skimage.measure.label(binary_image)\n    node_op.add_nodes(graph, labels=labels, t=0)\n    ```\n\n    Add nodes from a time series:\n\n    ```python\n    labels_series = np.stack(\n        [\n            skimage.measure.label(binary_image_t0),\n            skimage.measure.label(binary_image_t1),\n        ]\n    )\n    node_op.add_nodes(graph, labels=labels_series)\n    ```\n\n    Add nodes with intensity information:\n\n    ```python\n    node_op.add_nodes(graph, labels=labels, t=0, intensity_image=fluorescence_image)\n    ```\n    \"\"\"\n    axis_names = self._axis_names(labels)\n    self._init_node_attrs(graph, axis_names)\n\n    if t is None:\n        time_points = range(labels.shape[0])\n    else:\n        time_points = [t]\n\n    node_ids = []\n    for nodes_data in multiprocessing_apply(\n        func=curry(self._nodes_per_time, labels=labels, intensity_image=intensity_image),\n        sequence=time_points,\n        desc=\"Adding region properties nodes\",\n    ):\n        node_ids.extend(graph.bulk_add_nodes(nodes_data))\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add nodes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(labels)","title":"<code>labels</code>","text":"(<code>NDArray[integer]</code>)           \u2013            <p>Labeled image(s) where each unique positive integer represents a different region/object. Can be: - 3D array (time, height, width) for 2D time series - 4D array (time, depth, height, width) for 3D time series When <code>t</code> is provided, it should be padded to include the time dimension.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Time point for the nodes. If None, labels are treated as a time series where the first axis represents time.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(intensity_image)","title":"<code>intensity_image</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>Intensity image(s) corresponding to the labels. Used for computing intensity-based properties. Must have the same shape as labels (excluding the label values).</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.attr_keys","title":"attr_keys","text":"<pre><code>attr_keys() -&gt; list[str]\n</code></pre> <p>Get the keys of the node attributes that will be extracted.</p> <p>Returns only the keys for extra_properties. The centroid coordinates (x, y, z) and mask are always included but not listed here.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of attribute key names that will be added to nodes.</p> </li> </ul> <p>Examples:</p> <pre><code>node_op = RegionPropsNodes(extra_properties=[\"area\", \"perimeter\"])\nkeys = node_op.attr_keys()\nprint(keys)  # ['area', 'perimeter']\n</code></pre> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def attr_keys(self) -&gt; list[str]:\n    \"\"\"\n    Get the keys of the node attributes that will be extracted.\n\n    Returns only the keys for extra_properties. The centroid coordinates\n    (x, y, z) and mask are always included but not listed here.\n\n    Returns\n    -------\n    list[str]\n        List of attribute key names that will be added to nodes.\n\n    Examples\n    --------\n    ```python\n    node_op = RegionPropsNodes(extra_properties=[\"area\", \"perimeter\"])\n    keys = node_op.attr_keys()\n    print(keys)  # ['area', 'perimeter']\n    ```\n    \"\"\"\n    return [prop.__name__ if callable(prop) else prop for prop in self._extra_properties]\n</code></pre>"},{"location":"reference/tracksdata/options/","title":"tracksdata.options","text":""},{"location":"reference/tracksdata/options/#tracksdata.options","title":"tracksdata.options","text":"<p>Global options system for TracksData.</p> <p>Classes:</p> <ul> <li> <code>Options</code>           \u2013            <p>Global options for TracksData.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_options</code>             \u2013              <p>Get the current global options.</p> </li> <li> <code>options_context</code>             \u2013              <p>Context manager for temporarily modifying options.</p> </li> <li> <code>set_options</code>             \u2013              <p>Set the global options pushing a new Options object to the stack.</p> </li> </ul>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options","title":"Options  <code>dataclass</code>","text":"<pre><code>Options(show_progress: bool = True, n_workers: int = 1, gav_chunk_shape: tuple[int, ...] | int = 512, gav_default_dtype: dtype | str = np.uint64, gav_buffer_cache_size: int = 4)\n</code></pre> <p>Global options for TracksData.</p> <p>This class provides a centralized way to control various behaviors across the library, such as progress display and multiprocessing.</p>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options--parameters","title":"Parameters","text":"<p>show_progress : bool, default True     Whether to display progress bars during operations. n_workers : int     Number of worker processes to use for multiprocessing operations.     - 0 or 1: use default behavior (sequential)     - &gt; 1: use exactly this many worker processes     NOTE: Overhead of multiprocessing is significant, experiment with 1 before increasing. gav_chunk_size : tuple[int, ...] | int     Spatial chunk size for displaying data as GraphArrayView. If the length     is less than the number of dimensions, the remaining dimensions will be     filled with 1 from the left.     If an int is provided, it will be used for all dimensions. gav_default_dtype : np.dtype     Default dtype for GraphArrayView. gav_buffer_size : int     Number of chunks to buffer for GraphArrayView.</p> <p>Methods:</p> <ul> <li> <code>__enter__</code>             \u2013              <p>Enter the context manager.</p> </li> <li> <code>__exit__</code>             \u2013              <p>Exit the context manager.</p> </li> <li> <code>copy</code>             \u2013              <p>Return a copy of the options.</p> </li> <li> <code>update</code>             \u2013              <p>Update the options with the given keyword arguments.</p> </li> </ul>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Options\n</code></pre> <p>Enter the context manager.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def __enter__(self) -&gt; \"Options\":\n    \"\"\"Enter the context manager.\"\"\"\n    # Push current options to stack\n    _options_stack.append(self)\n    return self\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None\n</code></pre> <p>Exit the context manager.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"Exit the context manager.\"\"\"\n    # Pop this options from stack\n    if _options_stack:\n        _options_stack.pop()\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.copy","title":"copy","text":"<pre><code>copy() -&gt; Options\n</code></pre> <p>Return a copy of the options.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def copy(self) -&gt; \"Options\":\n    \"\"\"Return a copy of the options.\"\"\"\n    return Options(**self.__dict__)\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.update","title":"update","text":"<pre><code>update(**kwargs: Any) -&gt; None\n</code></pre> <p>Update the options with the given keyword arguments.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def update(self, **kwargs: Any) -&gt; None:\n    \"\"\"Update the options with the given keyword arguments.\"\"\"\n    valid_keys = set(self.__dict__.keys())\n    for key, value in kwargs.items():\n        if key not in valid_keys:\n            raise ValueError(f\"Invalid option: {key}. Expected one of {valid_keys}\")\n        setattr(self, key, value)\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.get_options","title":"get_options","text":"<pre><code>get_options() -&gt; Options\n</code></pre> <p>Get the current global options.</p> <p>Returns:</p> <ul> <li> <code>Options</code>           \u2013            <p>The current global options instance.</p> </li> </ul> Source code in <code>src/tracksdata/options.py</code> <pre><code>def get_options() -&gt; Options:\n    \"\"\"\n    Get the current global options.\n\n    Returns\n    -------\n    Options\n        The current global options instance.\n    \"\"\"\n    # Return the top of the stack, or default if stack is empty\n    return _options_stack[-1] if _options_stack else _default_options\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.options_context","title":"options_context","text":"<pre><code>options_context(**kwargs: Any) -&gt; Generator[Options, None, None]\n</code></pre> <p>Context manager for temporarily modifying options.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Options</code>           \u2013            <p>The options object with the temporary settings.</p> </li> </ul> <p>Examples:</p> <pre><code>from tracksdata.options import options_context\n\nwith options_context(show_progress=False):\n    # Operations here will not show progress\n    pass\n</code></pre> See Also <p>Options:     The global options class.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>@contextmanager\ndef options_context(**kwargs: Any) -&gt; Generator[Options, None, None]:\n    \"\"\"\n    Context manager for temporarily modifying options.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Options parameters to temporarily set.\n\n    Yields\n    ------\n    Options\n        The options object with the temporary settings.\n\n    Examples\n    --------\n    ```python\n    from tracksdata.options import options_context\n\n    with options_context(show_progress=False):\n        # Operations here will not show progress\n        pass\n    ```\n\n    See Also\n    --------\n    [Options][tracksdata.options.Options]:\n        The global options class.\n\n    \"\"\"\n    temp_options = Options(**kwargs)\n    with temp_options:\n        yield temp_options\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.options_context(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Options parameters to temporarily set.</p>"},{"location":"reference/tracksdata/options/#tracksdata.options.set_options","title":"set_options","text":"<pre><code>set_options(options: Options | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Set the global options pushing a new Options object to the stack.</p> <p>Parameters:</p> <p>Examples:</p> <p>Set options using an Options object:</p> <pre><code>&gt;&gt;&gt; from tracksdata.options import Options, set_options\n&gt;&gt;&gt; set_options(Options(show_progress=False))\n</code></pre> <p>Set options using keyword arguments:</p> <pre><code>&gt;&gt;&gt; set_options(show_progress=False)\n</code></pre> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both options and kwargs are provided, or if neither are provided.</p> </li> </ul> Source code in <code>src/tracksdata/options.py</code> <pre><code>def set_options(options: Options | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Set the global options pushing a new Options object to the stack.\n\n    Parameters\n    ----------\n    options : Options | None, optional\n        The options object to set as global. If None, kwargs will be used to create a new Options object.\n    **kwargs : Any\n        Individual option parameters to set. Only used if options is None.\n\n    Examples\n    --------\n    Set options using an Options object:\n\n    &gt;&gt;&gt; from tracksdata.options import Options, set_options\n    &gt;&gt;&gt; set_options(Options(show_progress=False))\n\n    Set options using keyword arguments:\n\n    &gt;&gt;&gt; set_options(show_progress=False)\n\n    Raises\n    ------\n    ValueError\n        If both options and kwargs are provided, or if neither are provided.\n    \"\"\"\n    if options is not None and kwargs:\n        raise ValueError(\"Cannot provide both 'options' and keyword arguments\")\n\n    if options is None and not kwargs:\n        raise ValueError(\"Must provide either 'options' or keyword arguments\")\n\n    if options is None:\n        options = get_options().copy()\n        options.update(**kwargs)\n\n    _options_stack.append(options)\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.set_options(options)","title":"<code>options</code>","text":"(<code>Options | None</code>, default:                   <code>None</code> )           \u2013            <p>The options object to set as global. If None, kwargs will be used to create a new Options object.</p>"},{"location":"reference/tracksdata/options/#tracksdata.options.set_options(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Individual option parameters to set. Only used if options is None.</p>"},{"location":"reference/tracksdata/solvers/","title":"tracksdata.solvers","text":""},{"location":"reference/tracksdata/solvers/#tracksdata.solvers","title":"tracksdata.solvers","text":"<p>Solvers for finding a valid tracking solution from a candidate graph.</p> <p>Classes:</p> <ul> <li> <code>ILPSolver</code>           \u2013            <p>Optimal tracking solver using Integer Linear Programming (ILP).</p> </li> <li> <code>NearestNeighborsSolver</code>           \u2013            <p>Solver for tracking problems using nearest neighbor edge selection.</p> </li> </ul>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver","title":"ILPSolver","text":"<pre><code>ILPSolver(*, edge_weight: str | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST, node_weight: str | ExprInput = 0.0, appearance_weight: str | ExprInput = 0.0, disappearance_weight: str | ExprInput = 0.0, division_weight: str | ExprInput = 0.0, output_key: str = DEFAULT_ATTR_KEYS.SOLUTION, num_threads: int = 1, reset: bool = True, return_solution: bool = True, gap: float = 0.0, timeout: float | None = None)\n</code></pre> <p>               Bases: <code>BaseSolver</code></p> <p>Optimal tracking solver using Integer Linear Programming (ILP).</p> <p>ILPSolver formulates the multi-object tracking problem as an Integer Linear Programming optimization problem. It finds globally optimal solutions by minimizing a cost function while satisfying flow conservation constraints. The solver supports appearance, disappearance, and division events, making it suitable for complex biological tracking scenarios.</p> <p>The optimization problem includes:</p> <ul> <li>Node selection variables (whether a detection is part of a track)</li> <li>Edge selection variables (connections between detections)</li> <li>Appearance variables (track starts)</li> <li>Disappearance variables (track ends)</li> <li>Division variables (cell divisions or track splits)</li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_weight_expr</code>               (<code>EdgeAttr</code>)           \u2013            <p>Compiled edge weight expression.</p> </li> <li> <code>node_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled node weight expression.</p> </li> <li> <code>appearance_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled appearance weight expression.</p> </li> <li> <code>disappearance_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled disappearance weight expression.</p> </li> <li> <code>division_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled division weight expression.</p> </li> </ul> See Also <p>NearestNeighborsSolver:     Greedy nearest neighbors tracking solver.</p> <p>NodeAttr:     For creating node attribute expressions.</p> <p>EdgeAttr:     For creating edge attribute expressions.</p> <p>Examples:</p> <p>Basic tracking with distance-based costs:</p> <pre><code>from tracksdata.solvers import ILPSolver\n\nsolver = ILPSolver(edge_weight=\"distance\")\nsolution = solver.solve(graph)\n</code></pre> <p>Tracking with appearance and disappearance costs:</p> <pre><code>solver = ILPSolver(edge_weight=\"distance\", appearance_weight=10.0, disappearance_weight=10.0)\nsolution = solver.solve(graph)\n</code></pre> <p>Using attribute expressions for complex costs:</p> <pre><code>from tracksdata.attrs import EdgeAttr\n\nsolver = ILPSolver(edge_weight=EdgeAttr(\"distance\") + 0.1 * EdgeAttr(\"angle_change\"), division_weight=5.0)\nsolution = solver.solve(graph)\n</code></pre> Notes <p>The solver uses the ilpy library which provides interfaces to commercial solvers (Gurobi) and open-source solvers (SCIP). For best performance, install Gurobi if available, otherwise SCIP will be used as fallback.</p> <p>The ILP formulation ensures:</p> <ul> <li>Flow conservation: incoming flow equals outgoing flow for each node</li> <li>Track consistency: each detection belongs to at most one track</li> <li>Optimal solution: globally minimizes the total cost function</li> </ul> Source code in <code>src/tracksdata/solvers/_ilp_solver.py</code> <pre><code>def __init__(\n    self,\n    *,\n    edge_weight: str | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    node_weight: str | ExprInput = 0.0,\n    appearance_weight: str | ExprInput = 0.0,\n    disappearance_weight: str | ExprInput = 0.0,\n    division_weight: str | ExprInput = 0.0,\n    output_key: str = DEFAULT_ATTR_KEYS.SOLUTION,\n    num_threads: int = 1,\n    reset: bool = True,\n    return_solution: bool = True,\n    gap: float = 0.0,\n    timeout: float | None = None,\n):\n    super().__init__(output_key=output_key, reset=reset, return_solution=return_solution)\n    self.edge_weight_expr = EdgeAttr(edge_weight)\n    self.node_weight_expr = NodeAttr(node_weight)\n    self.appearance_weight_expr = NodeAttr(appearance_weight)\n    self.disappearance_weight_expr = NodeAttr(disappearance_weight)\n    self.division_weight_expr = NodeAttr(division_weight)\n    self.num_threads = num_threads\n    self.gap = gap\n    self.timeout = timeout\n    self.reset_model()\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(edge_weight)","title":"<code>edge_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>DEFAULT_ATTR_KEYS.EDGE_WEIGHT</code> )           \u2013            <p>Edge attribute or expression to use as edge costs in the optimization. Lower values indicate preferred connections.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(node_weight)","title":"<code>node_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Node attribute or expression to use as node costs.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(appearance_weight)","title":"<code>appearance_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Cost for track appearances (new tracks starting).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(disappearance_weight)","title":"<code>disappearance_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Cost for track disappearances (tracks ending).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(division_weight)","title":"<code>division_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Cost for track divisions (one track splitting into two).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>DEFAULT_ATTR_KEYS.SOLUTION</code> )           \u2013            <p>Attribute key to store the solution (True/False for selected items).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(num_threads)","title":"<code>num_threads</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of threads to use for solving.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(reset)","title":"<code>reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset previous solutions before solving.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(return_solution)","title":"<code>return_solution</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return a subgraph containing only the solution.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(gap)","title":"<code>gap</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Optimality gap tolerance (0.0 for exact solutions).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(timeout)","title":"<code>timeout</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Time limit for solving in seconds. If None, no timeout is set.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr","title":"_evaluate_inf_expr","text":"<pre><code>_evaluate_inf_expr(inf_expr: list[Attr], df: DataFrame, node_key: str) -&gt; list[int]\n</code></pre> <p>Evaluate a list of infinity expressions and return the node ids that satisfy the expressions.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The node ids that satisfy the expressions.</p> </li> </ul> Source code in <code>src/tracksdata/solvers/_ilp_solver.py</code> <pre><code>def _evaluate_inf_expr(\n    self,\n    inf_expr: list[Attr],\n    df: pl.DataFrame,\n    node_key: str,\n) -&gt; list[int]:\n    \"\"\"\n    Evaluate a list of infinity expressions and return the node ids that satisfy the expressions.\n\n    Parameters\n    ----------\n    inf_expr : list[AttrExpr]\n        The list of infinity expressions to evaluate.\n    df : pl.DataFrame\n        The dataframe to evaluate the expressions on.\n    node_key : str\n        The key of the node column to filter on.\n\n    Returns\n    -------\n    list[int]\n        The node ids that satisfy the expressions.\n    \"\"\"\n    if len(inf_expr) == 0:\n        return []\n    mask = False\n    for expr in inf_expr:\n        mask = mask | expr.evaluate(df)\n    return df.select(node_key).filter(mask).to_series().to_list()\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr(inf_expr)","title":"<code>inf_expr</code>","text":"(<code>list[AttrExpr]</code>)           \u2013            <p>The list of infinity expressions to evaluate.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The dataframe to evaluate the expressions on.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr(node_key)","title":"<code>node_key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the node column to filter on.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver","title":"NearestNeighborsSolver","text":"<pre><code>NearestNeighborsSolver(max_children: int = 2, edge_weight: str | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST, output_key: str = DEFAULT_ATTR_KEYS.SOLUTION, reset: bool = True, return_solution: bool = True)\n</code></pre> <p>               Bases: <code>BaseSolver</code></p> <p>Solver for tracking problems using nearest neighbor edge selection.</p> <p>Implements a greedy nearest neighbor approach to solve tracking problems by selecting the best edges while enforcing constraints on parent-child relationships. Works by sorting all edges by weight, greedily selecting edges starting from the best weights, and enforcing constraints (each node can have at most one parent and max_children children). Runs in O(n log n) time due to sorting, where n is the number of edges.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver--parameters","title":"Parameters","text":"<p>max_children : int, default 2     Maximum number of children (successors) each node can have.     This constrains cell division events in biological tracking. edge_weight : str | AttrExpr, default DEFAULT_ATTR_KEYS.EDGE_WEIGHT     Edge attribute key or expression to use as edge weights for sorting.     Lower weights are preferred (treated as better matches).     Can be a string key or AttrExpr for complex expressions. output_key : str, default DEFAULT_ATTR_KEYS.SOLUTION     Attribute key to store the solution boolean values in nodes and edges.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver--attributes","title":"Attributes","text":"<p>max_children : int     Maximum number of children per node. solution_key : str     Key used to store solution results. edge_weight_expr : AttrExpr     Expression used to compute edge weights. output_key : str     The key to store the solution in the graph. reset : bool     Whether to reset the solution values in the whole graph before solving.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver--examples","title":"Examples","text":"<p>Basic usage with default settings:</p> <pre><code>from tracksdata.solvers import NearestNeighborsSolver\n\nsolver = NearestNeighborsSolver()\nsolver.solve(graph)\n</code></pre> <p>Customize maximum children for cell division tracking:</p> <pre><code>solver = NearestNeighborsSolver(max_children=3)\nsolver.solve(graph)\n</code></pre> <p>Use custom edge weight expression:</p> <pre><code>from tracksdata.attrs import EdgeAttr\n\nsolver = NearestNeighborsSolver(\n    edge_weight=-EdgeAttr(\"iou\"),  # Higher IoU is better\n    max_children=2,\n)\n</code></pre> <p>Combine multiple edge attributes:</p> <pre><code>weight_expr = EdgeAttr(\"distance\") + 0.5 * EdgeAttr(\"color_diff\")\nsolver = NearestNeighborsSolver(edge_weight=weight_expr)\n</code></pre> <p>Methods:</p> <ul> <li> <code>solve</code>             \u2013              <p>Solve the tracking problem using nearest neighbor edge selection.</p> </li> </ul> Source code in <code>src/tracksdata/solvers/_nearest_neighbors_solver.py</code> <pre><code>def __init__(\n    self,\n    max_children: int = 2,\n    edge_weight: str | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    output_key: str = DEFAULT_ATTR_KEYS.SOLUTION,\n    reset: bool = True,\n    return_solution: bool = True,\n):\n    super().__init__(\n        output_key=output_key,\n        reset=reset,\n        return_solution=return_solution,\n    )\n    self.max_children = max_children\n    self.edge_weight_expr = Attr(edge_weight)\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver.solve","title":"solve","text":"<pre><code>solve(graph: BaseGraph) -&gt; GraphView | None\n</code></pre> <p>Solve the tracking problem using nearest neighbor edge selection.</p> <p>Applies the nearest neighbor algorithm to find the optimal set of edges that form valid tracking paths while respecting parent-child relationship constraints. Automatically extends the graph schema to include the solution key if it doesn't already exist.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>solver = NearestNeighborsSolver(max_children=2)\nsolver.solve(graph)\n</code></pre> <p>Access solution edges:</p> <pre><code>solution_edges = graph.edge_attrs().filter(pl.col(\"solution\") == True)\n</code></pre> <p>Returns:</p> <ul> <li> <code>GraphView | None</code>           \u2013            <p>The graph view of the solution if <code>return_solution</code> is True, otherwise None.</p> </li> </ul> Source code in <code>src/tracksdata/solvers/_nearest_neighbors_solver.py</code> <pre><code>def solve(\n    self,\n    graph: BaseGraph,\n) -&gt; GraphView | None:\n    \"\"\"\n    Solve the tracking problem using nearest neighbor edge selection.\n\n    Applies the nearest neighbor algorithm to find the optimal set of edges\n    that form valid tracking paths while respecting parent-child relationship\n    constraints. Automatically extends the graph schema to include the solution\n    key if it doesn't already exist.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph containing nodes and edges to solve. The graph will be\n        modified in-place to add solution attributes to nodes and edges.\n\n    Examples\n    --------\n    ```python\n    solver = NearestNeighborsSolver(max_children=2)\n    solver.solve(graph)\n    ```\n\n    Access solution edges:\n\n    ```python\n    solution_edges = graph.edge_attrs().filter(pl.col(\"solution\") == True)\n    ```\n\n    Returns\n    -------\n    GraphView | None\n        The graph view of the solution if `return_solution` is True, otherwise None.\n    \"\"\"\n    # get edges and sort them by weight\n    edges_df = graph.edge_attrs(attr_keys=self.edge_weight_expr.columns)\n\n    if len(edges_df) == 0:\n        raise ValueError(\"No edges found in the graph, there is nothing to solve.\")\n\n    weights = self.edge_weight_expr.evaluate(edges_df).to_numpy()\n    sorted_indices = np.argsort(weights)\n\n    sorted_source = edges_df[DEFAULT_ATTR_KEYS.EDGE_SOURCE].to_numpy()[sorted_indices].astype(np.int64)\n    sorted_target = edges_df[DEFAULT_ATTR_KEYS.EDGE_TARGET].to_numpy()[sorted_indices].astype(np.int64)\n    sorted_solution = np.zeros(len(sorted_source), dtype=bool)\n\n    if graph.has_overlaps():\n        overlapping_sets = _build_constraint_dict(\n            np.asarray(graph.overlaps(), dtype=np.int64),\n        )\n        _constrained_nearest_neighbors(\n            sorted_source,\n            sorted_target,\n            sorted_solution,\n            self.max_children,\n            overlapping_sets,\n        )\n    else:\n        _constrained_nearest_neighbors(\n            sorted_source,\n            sorted_target,\n            sorted_solution,\n            self.max_children,\n        )\n    del sorted_source, sorted_target\n\n    inverted_indices = np.empty_like(sorted_indices)\n    inverted_indices[sorted_indices] = np.arange(len(sorted_indices))\n    solution = sorted_solution[inverted_indices]\n    del sorted_solution, inverted_indices, sorted_indices\n\n    solution_edges_df = edges_df.filter(solution)\n\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, False)\n    elif self.reset:\n        graph.update_edge_attrs(attrs={self.output_key: False})\n\n    graph.update_edge_attrs(\n        edge_ids=solution_edges_df[DEFAULT_ATTR_KEYS.EDGE_ID].to_numpy(),\n        attrs={self.output_key: True},\n    )\n\n    node_ids = np.unique(\n        np.concatenate(\n            [\n                solution_edges_df[DEFAULT_ATTR_KEYS.EDGE_SOURCE].to_numpy(),\n                solution_edges_df[DEFAULT_ATTR_KEYS.EDGE_TARGET].to_numpy(),\n            ]\n        )\n    )\n\n    if self.output_key not in graph.node_attr_keys:\n        graph.add_node_attr_key(self.output_key, False)\n\n    graph.update_node_attrs(\n        node_ids=node_ids,\n        attrs={self.output_key: True},\n    )\n\n    if self.return_solution:\n        return graph.filter(\n            NodeAttr(self.output_key) == True,\n            EdgeAttr(self.output_key) == True,\n        ).subgraph()\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver.solve(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph containing nodes and edges to solve. The graph will be modified in-place to add solution attributes to nodes and edges.</p>"},{"location":"reference/tracksdata/utils/","title":"tracksdata.utils","text":""},{"location":"reference/tracksdata/utils/#tracksdata.utils","title":"tracksdata.utils","text":"<p>Utility functions for data processing, type conversions, and progress tracking.</p>"}]}