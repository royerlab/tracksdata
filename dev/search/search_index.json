{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TracksData","text":"<p>A common data structure and basic tools for multi-object tracking.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Graph-based representation of tracking problems</li> <li>In-memory (RustWorkX) and database-backed (SQL) graph backends</li> <li>Nodes and edges can take arbitrary attributes</li> <li>Standardize API for node operators (e.g. defining objects and their attributes)</li> <li>Standardize API for edge operators (e.g. creating edges between nodes)</li> <li>Basic tracking solvers: nearest neighbors and integer linear programming</li> <li>Compatible with Cell Tracking Challenge (CTC) format</li> <li>Efficient subgraphing based on attributes on any graph backend</li> <li>Integration with cell tracking evaluation metrics</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Until rustworkx 0.17.0 is released, you need to have rust installed to compile the latest rustworkx.</p> <pre><code>conda install -c conda-forge rust\n</code></pre> <p>Then install tracksdata with the following command:</p> <pre><code>pip install .\n</code></pre>"},{"location":"#why-tracksdata","title":"Why tracksdata?","text":"<p>TracksData provides a common data structure for multi-object tracking problems. It uses graphs to represent detections (nodes) and their connections (edges), making it easier to work with tracking data across different algorithms.</p> <p>Key benefits: - Consistent data representation for tracking problems - Modular components that can be combined as needed - Support for both small datasets (in-memory) and large datasets (database)</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Full Documentation</li> <li>Installation</li> <li>Core Concepts</li> <li>Getting Started</li> <li>API Reference</li> <li>FAQ</li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":""},{"location":"concepts/#graph-based-tracking","title":"Graph-Based Tracking","text":"<p>TracksData represents tracking data as a directed graph where:</p> <ul> <li>Nodes are detections/objects at specific time points</li> <li>Edges connect objects across consecutive time frames forward in time (t to t + delta_t)</li> <li>Tracks are paths through the graph representing object trajectories</li> </ul>"},{"location":"concepts/#graph-backends","title":"Graph Backends","text":"<p>TracksData supports multiple graph backends for different use cases:</p>"},{"location":"concepts/#rustworkxgraph","title":"RustWorkXGraph","text":"<ul> <li>Use case: In-memory graphs that fit in RAM</li> <li>Performance: Excellent for algorithms and analysis</li> <li>Recommended: For most tracking applications</li> </ul>"},{"location":"concepts/#sqlgraph","title":"SQLGraph","text":"<ul> <li>Use case: Large datasets that don't fit in memory</li> <li>Performance: Good for storage and querying</li> <li>Features: Persistent storage, complex queries</li> </ul>"},{"location":"concepts/#graphview","title":"GraphView","text":"<ul> <li>Use case: Results subgraph either backends</li> <li>Performance: Low overhead, similar to RustWorkXGraph</li> <li>Features: Maintains connection to root graph, all operations are mirrored to the root graph</li> </ul>"},{"location":"concepts/#graph-operators","title":"Graph Operators","text":"<p>Graph operators are used to manipulate the graph:</p> <ul> <li>Node operators: Create or add attributes to nodes</li> <li>Edge operators: Create or add attributes to edges</li> <li>Solver operators: Solve the tracking problem</li> </ul>"},{"location":"concepts/#attribute-system","title":"Attribute System","text":"<p>TracksData uses a flexible attribute system:</p>"},{"location":"concepts/#node-attributes","title":"Node Attributes","text":"<ul> <li>Store object properties (coordinates, features, measurements)</li> <li>Support various data types (floats, arrays, segmentation masks)</li> </ul>"},{"location":"concepts/#edge-attributes","title":"Edge Attributes","text":"<ul> <li>Store connection properties (distances, costs, confidences)</li> <li>Used by solvers for optimization</li> </ul>"},{"location":"concepts/#attribute-expressions","title":"Attribute Expressions","text":"<p>Attributes are used to filter nodes or edges, or to formulate the objective function for solvers.</p> <pre><code>import tracksdata as td\n\n# Simple attribute access\nx_coords = td.NodeAttr(\"x\")\n\n# Mathematical expressions\ndistance_cost = td.EdgeAttr(\"distance\") + 0.1 * td.EdgeAttr(\"angle_change\")\n\n# Comparison operations for filtering\nrecent_nodes = td.NodeAttr(\"t\") &gt;= 10\nlarge_objects = td.NodeAttr(\"area\") &gt; 100\n</code></pre>"},{"location":"concepts/#data-flow","title":"Data Flow","text":"<p>A typical TracksData workflow:</p> <ol> <li>Create Graph: Choose appropriate backend</li> <li>Add Nodes: Use node operators to populate detections</li> <li>Add Edges: Use edge operators to create potential connections</li> <li>Solve: Apply solver to find optimal tracks</li> <li>Analyze: Query and filter results for downstream analysis</li> </ol> <p>This modular design allows mixing and matching components for different tracking scenarios.</p>"},{"location":"contributing/","title":"Contributing to Documentation","text":""},{"location":"contributing/#documentation-versioning","title":"Documentation Versioning","text":"<p>This project uses mike for documentation versioning. Documentation is automatically built and deployed via GitHub Actions.</p>"},{"location":"contributing/#automatic-deployment","title":"Automatic Deployment","text":"<ul> <li>Development docs: Built on every push to <code>main</code> branch \u2192 available at <code>/dev/</code></li> <li>Release docs: Built on every tag push (<code>v*</code>) \u2192 available at <code>/latest/</code> and <code>/v{version}/</code></li> </ul>"},{"location":"contributing/#manual-version-management","title":"Manual Version Management","text":"<p>If you need to manually manage documentation versions:</p> <pre><code># Install dependencies\nuv sync --extra docs\n\n# Deploy a new version\nuv run mike deploy --push --update-aliases v1.0.0 latest\n\n# Set default version\nuv run mike set-default --push latest\n\n# List all versions\nuv run mike list\n\n# Delete a version\nuv run mike delete --push v0.9.0\n</code></pre>"},{"location":"contributing/#local-development","title":"Local Development","text":"<p>To build and serve documentation locally:</p> <pre><code># Serve with live reload\nuv run mkdocs serve\n\n# Build static site\nuv run mkdocs build\n</code></pre>"},{"location":"contributing/#version-structure","title":"Version Structure","text":"<ul> <li><code>latest</code> - Latest stable release</li> <li><code>dev</code> - Development version from main branch</li> <li><code>v{X.Y.Z}</code> - Specific version tags</li> </ul> <p>The documentation will be available at: - https://royerlab.github.io/tracksdata/ (latest) - https://royerlab.github.io/tracksdata/dev/ (development) - https://royerlab.github.io/tracksdata/v1.0.0/ (specific version)</p>"},{"location":"examples/","title":"Examples","text":"<p>This section provides practical examples of using TracksData for multi-object tracking tasks.</p>"},{"location":"examples/#basic-tracking-example","title":"Basic Tracking Example","text":"<p>Here's a complete basic example that demonstrates the core workflow of TracksData. This example is available as an executable Python file at <code>docs/examples/basic.py</code>.</p> <pre><code>\"\"\"\nBasic multi-object tracking example using TracksData.\n\nThis example demonstrates the complete workflow for tracking objects across time:\n1. Load segmented image data\n2. Extract object features (nodes) from each frame\n3. Create temporal connections (edges) between objects\n4. Compute additional attributes to edges (e.g. IoU)\n5. Solve the tracking optimization problem\n6. Convert results to napari format\n7. Visualize results\n\n\nRequirements:\n- Set CTC_DIR environment variable pointing to Cell Tracking Challenge data\n- Example assumes Fluo-N2DL-HeLa dataset structure\n\nUsage:\n    python basic.py                    # Run with napari visualization\n    python basic.py --profile          # Run with performance profiling\n\"\"\"\n\nimport os\nfrom pathlib import Path\n\nimport click\nimport napari\nimport numpy as np\nfrom profilehooks import profile as profile_hook\nfrom tifffile import imread\n\nimport tracksdata as td\n\n\ndef basic_tracking_example(show_napari_viewer: bool = True) -&gt; tuple:\n    \"\"\"\n    Perform basic multi-object tracking on segmented microscopy data.\n\n    This function demonstrates the core TracksData workflow:\n    - Node extraction from regionprops\n    - Distance-based edge creation\n    - IoU attribute computation\n    - Nearest neighbors tracking solution\n\n    Parameters\n    ----------\n    show_napari_viewer : bool\n        Whether to display results in napari viewer\n\n    Returns\n    -------\n    tuple: (labels, tracks_df, track_graph) for further analysis\n    \"\"\"\n    # Step 1: Load and prepare data\n\n    # Load example data from Cell Tracking Challenge format\n    data_dir = Path(os.environ[\"CTC_DIR\"]) / \"training/Fluo-N2DL-HeLa/01_GT/TRA\"\n    assert data_dir.exists(), f\"Data directory {data_dir} does not exist.\"\n\n    # Load all timepoints as a 3D array: (time, height, width)\n    labels = np.stack(\n        [imread(p) for p in sorted(data_dir.glob(\"*.tif\"))],\n    )\n\n    # Configure TracksData options (disable progress bars for cleaner output)\n    td.options.set_options(show_progress=False)\n\n    print(\"Starting tracking workflow...\")\n\n    # Step 2: Initialize graph and extract nodes\n    graph = td.graph.InMemoryGraph()\n\n    # Extract object features using region properties\n    # This creates one node per object per timeframe\n    nodes_operator = td.nodes.RegionPropsNodes()\n    nodes_operator.add_nodes(graph, labels=labels)\n    print(f\"\u2713 Extracted {graph.num_nodes} nodes from {labels.shape[0]} timeframes\")\n\n    # Step 3: Create temporal edges between consecutive frames\n\n    # Add distance-based edges between objects in consecutive timeframes\n    # Only connects objects within distance_threshold and limits to n_neighbors\n    dist_operator = td.edges.DistanceEdges(\n        distance_threshold=30.0,\n        n_neighbors=5,\n    )\n    dist_operator.add_edges(graph)\n    print(f\"\u2713 Created {graph.num_edges} potential temporal connections\")\n\n    # Step 4: Add IoU (Intersection over Union) attributes to edges\n\n    # Compute IoU between connected objects to measure shape similarity\n    # Higher IoU values indicate better matches for tracking\n    iou_operator = td.edges.IoUEdgeAttr(output_key=\"iou\")\n    iou_operator.add_edge_attrs(graph)\n    print(\"\u2713 Computed IoU attributes for edge weights\")\n\n    # Step 5: Solve tracking optimization problem\n\n    # Create edge weights combining distance and IoU information\n    # Lower distance + higher IoU = better connection (lower cost)\n    dist_weight = 1 / dist_operator.distance_threshold\n\n    # Use nearest neighbors solver for fast, greedy tracking\n    # Each edge weight is defined as:\n    # - IoU(e_ij) * exp(-distance(e_ij) / dist_threshold)\n    # Where e_ij is the edge between nodes i and j.\n    # Alternative: ILPSolver for globally optimal but slower solutions\n    solver = td.solvers.NearestNeighborsSolver(\n        edge_weight=-td.EdgeAttr(\"iou\") * (td.EdgeAttr(\"distance\") * dist_weight).exp(),\n        max_children=2,  # Allow cell divisions (max 2 children per parent)\n    )\n\n    # Alternative ILP solver (uncomment for optimal tracking):\n    # solver = td.solvers.ILPSolver(\n    #     edge_weight=-td.EdgeAttr(\"iou\") * (td.EdgeAttr(\"weight\") * dist_weight).exp(),\n    #     node_weight=0.0,           # Cost for keeping an object\n    #     appearance_weight=1.0,    # Cost for object appearing\n    #     disappearance_weight=1.0, # Cost for object disappearing\n    #     division_weight=1.0,       # Cost for cell division\n    # )\n\n    solver.solve(graph)\n    print(\"\u2713 Solved tracking assignments\")\n\n    # Step 6: Convert results for visualization\n\n    # Convert tracking graph to napari-compatible format\n    # Returns: tracked labels, tracks dataframe, and track graph\n    print(\"Converting results to napari format...\")\n    labels_out, tracks_df, track_graph = td.functional.to_napari_format(graph, labels.shape)\n\n    print(f\"\u2713 Generated {len(tracks_df)} track points across {len(set(tracks_df['track_id']))} tracks\")\n\n    # Step 7: Visualize results (optional)\n\n    if show_napari_viewer:\n        print(\"Opening napari viewer...\")\n        viewer = napari.Viewer()\n\n        # Add original segmented labels\n        viewer.add_labels(labels_out, name=\"Tracked Labels\")\n\n        # Add tracking trajectories with lineage information\n        viewer.add_tracks(tracks_df, graph=track_graph, name=\"Tracks\")\n\n        # Start interactive viewer\n        napari.run()\n\n    return labels_out, tracks_df, track_graph\n\n\n@click.command()\n@click.option(\"--profile\", is_flag=True, help=\"Enable performance profiling (disables napari viewer)\")\ndef main(profile: bool) -&gt; None:\n    \"\"\"Run the basic tracking example with optional profiling.\"\"\"\n    if profile:\n        # Run with performance profiling, no visualization\n        profile_hook(basic_tracking_example, immediate=True, sort=\"time\")(show_napari_viewer=False)\n    else:\n        # Normal run with visualization\n        basic_tracking_example(show_napari_viewer=True)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#key-components-explained","title":"Key Components Explained","text":"<ul> <li>Graph: The core data structure holding nodes (objects) and edges (connections)</li> <li>Nodes Operators: Extract object features from segmented images (RegionPropsNodes, MaskNodes, etc.)</li> <li>Edges Operators: Create temporal connections between objects (DistanceEdges, IoUEdges, etc.)</li> <li>Solvers: Optimize a minimization problem to find the best tracking assignments (NearestNeighborsSolver, ILPSolver)</li> <li>Functional: Utilities for format conversion and visualization</li> </ul>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Check the Getting Started guide for more detailed explanations</li> <li>Explore the Concepts page to understand the architecture</li> <li>See the API reference for complete documentation of all components</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-tracksdata","title":"What is TracksData?","text":"<p>TracksData is a Python library that provides a common data structure and tools for multi-object tracking. It uses a graph-based representation where objects are nodes and tracks are edges connecting objects across time.</p>"},{"location":"faq/#when-should-i-use-tracksdata","title":"When should I use TracksData?","text":"<p>TracksData is ideal for:</p> <ul> <li>Multi-object tracking in microscopy or computer vision</li> <li>Biological cell tracking and lineage analysis</li> <li>Particle tracking in physics simulations</li> <li>Any scenario requiring temporal object associations</li> </ul>"},{"location":"faq/#how-does-tracksdata-differ-from-other-tracking-libraries","title":"How does TracksData differ from other tracking libraries?","text":"<p>TracksData focuses on providing a general unified data structure and modular components that can be combined for different tracking scenarios and scale to large datasets (e.g. millions of nodes in terabytes of 3D + time imaging data).</p>"},{"location":"faq/#which-graph-backend-should-i-use","title":"Which graph backend should I use?","text":"<ul> <li>RustWorkXGraph: For most applications where data fits in memory</li> <li>SQLGraph: For large datasets or when you need persistent storage</li> <li>GraphView: You shouldn't instantiate this directly, it is used internally by the library when you use <code>graph.subgraph()</code></li> </ul>"},{"location":"faq/#can-tracksdata-handle-cell-divisions","title":"Can TracksData handle cell divisions?","text":"<p>Yes! The :class:<code>tracksdata.solvers.NearestNeighborsSolver</code> lets you defined the maximum number of children nodes and :class:<code>tracksdata.solvers.ILPSolver</code> specifically supports division events with configurable division costs.</p>"},{"location":"faq/#how-do-i-add-custom-attributes","title":"How do I add custom attributes?","text":"<pre><code># Add new attribute keys to the graph\ngraph.add_node_attr_key(\"my_feature\", 0.0)\ngraph.add_edge_attr_key(\"confidence\", 1.0)\n\n# Use them when adding nodes/edges\ngraph.add_node({\"t\": 0, \"x\": 10, \"my_feature\": 42.0})\ngraph.add_edge(source_id, target_id, {\"confidence\": 0.95})\n</code></pre>"},{"location":"faq/#how-do-i-create-custom-operators","title":"How do I create custom operators?","text":"<p>Inherit from :class:<code>tracksdata.edges.BaseEdgesOperator</code> or :class:<code>tracksdata.nodes.BaseNodesOperator</code> and implement <code>_add_edges_per_time</code> or <code>_add_nodes_per_time</code>:</p> <pre><code>import tracksdata as td\n\nclass CustomNodes(td.nodes.BaseNodesOperator):\n    def add_nodes(\n        self,\n        graph: td.graph.BaseGraph,\n        *,\n        t: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        # Your custom logic here to add nodes to the graph\n        pass\n</code></pre>"},{"location":"faq/#how-do-i-visualize-results","title":"How do I visualize results?","text":"<p>TracksData provides utilities for converting to napari format:</p> <pre><code>import tracksdata as td\n\nlabels, tracks_df, track_graph = td.functional.to_napari_format(solution_graph)\n\nviewer = napari.Viewer()\nviewer.add_labels(labels)\nviewer.add_tracks(tracks_df, graph=track_graph)\nnapari.run()\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#basic-concepts","title":"Basic Concepts","text":"<p>TracksData is built around a graph-based representation of multi-object tracking data:</p> <ul> <li>Nodes represent objects at specific time points (detections)</li> <li>Edges represent connections between objects across time (connections)</li> <li>Attributes store additional data like coordinates, features, or costs</li> </ul>"},{"location":"getting_started/#quick-example","title":"Quick Example","text":"<p>Here's a simple example of creating a graph and adding tracking data:</p> <pre><code>import numpy as np\nimport tracksdata as td\n\n# Create a graph\ngraph = td.graph.InMemoryGraph()\n\n# Generate random nodes for testing\nnode_generator = td.nodes.RandomNodes(\n    n_time_points=5,\n    n_nodes_per_tp=(10, 15),\n    n_dim=2\n)\nnode_generator.add_nodes(graph)\n\n# Connect nearby nodes across time\nedge_generator = td.edges.DistanceEdges(\n    distance_threshold=0.3,\n    n_neighbors=3\n)\nedge_generator.add_edges(graph)\n\n# Solve the tracking problem\nsolver = td.solvers.NearestNeighborsSolver(edge_weight=\"distance\")\nsolution = solver.solve(graph)\n\nprint(f\"Original graph has {graph.num_nodes} nodes and {graph.num_edges} edges\")\nprint(f\"Solution has {solution.num_nodes} nodes and {solution.num_edges} edges\")\n</code></pre>"},{"location":"getting_started/#working-with-real-data","title":"Working with Real Data","text":"<p>For real tracking applications, you'll typically:</p> <ol> <li>Create nodes from detections using <code>RegionPropsNodes</code> for segmented images</li> <li>Add edges using <code>DistanceEdges</code> or custom edge operators</li> <li>Solve tracking using <code>ILPSolver</code> for optimal results or <code>NearestNeighborsSolver</code> for speed</li> <li>Analyze results using the graph's filtering and querying capabilities</li> </ol> <pre><code>import tracksdata as td\n\n# Extract nodes from labeled images\nnode_op = td.nodes.RegionPropsNodes(extra_properties=[\"area\", \"eccentricity\"])\nnode_op.add_nodes(graph, labels=labels)\n\n# Filter nodes by time\nt0_nodes = graph.filter_nodes_by_attrs(td.NodeAttr(\"t\") == 0)\nnode_data = graph.node_attrs(node_ids=t0_nodes)\nprint(node_data)\n</code></pre>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>See the Concepts page for detailed explanations</li> <li>Check the FAQ for common questions</li> <li>Browse the API documentation for complete reference</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>TracksData requires Python 3.10 or later.</p>"},{"location":"installation/#installing-rust-required","title":"Installing Rust (Required)","text":"<p>Until rustworkx 0.17.0 is released, you need to have Rust installed to compile the latest rustworkx:</p> <pre><code>conda install -c conda-forge rust\n</code></pre>"},{"location":"installation/#install-tracksdata","title":"Install TracksData","text":""},{"location":"installation/#from-source-development","title":"From Source (Development)","text":"<p>To install the latest development version:</p> <pre><code>git clone https://github.com/royerlab/tracksdata.git\ncd tracksdata\npip install .\n</code></pre>"},{"location":"installation/#with-optional-dependencies","title":"With Optional Dependencies","text":"<p>For testing: <pre><code>pip install .[test]\n</code></pre></p> <p>For documentation: <pre><code>pip install .[docs]\n</code></pre></p>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>You can verify the installation by importing the library:</p> <pre><code>import tracksdata as td\nprint(td.__version__)\n</code></pre>"},{"location":"reference/tracksdata/","title":"tracksdata","text":""},{"location":"reference/tracksdata/#tracksdata","title":"tracksdata","text":"<p>A common data structure and basic tools for multi-object tracking.</p> <p>Modules:</p> <ul> <li> <code>array</code>           \u2013            <p>Array representation of graphical data.</p> </li> <li> <code>attrs</code>           \u2013            <p>Module to compose attribute expressions for attribute filtering or value evaluation.</p> </li> <li> <code>constants</code>           \u2013            <p>Module to define default and often global values used through <code>tracksdata</code>.</p> </li> <li> <code>edges</code>           \u2013            <p>Edge operators for creating connections between nodes of a graph.</p> </li> <li> <code>functional</code>           \u2013            <p>Functional utilities for graph operations.</p> </li> <li> <code>graph</code>           \u2013            <p>Graph backends for representing tracking data as directed graphs in memory or on disk.</p> </li> <li> <code>io</code>           \u2013            <p>Input/output utilities for loading and saving tracking data in various formats.</p> </li> <li> <code>metrics</code>           \u2013            <p>Evaluation metrics for tracking performance, including the CTC benchmark metrics.</p> </li> <li> <code>nodes</code>           \u2013            <p>Node operators for creating nodes and their respective attributes (e.g. masks) in a graph.</p> </li> <li> <code>options</code>           \u2013            <p>Global options system for TracksData.</p> </li> <li> <code>solvers</code>           \u2013            <p>Solvers for finding a valid tracking solution from a candidate graph.</p> </li> <li> <code>utils</code>           \u2013            <p>Utility functions for data processing, type conversions, and progress tracking.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>EdgeAttr</code>           \u2013            <p>Wrapper of Attr to represent an edge attribute.</p> </li> <li> <code>NodeAttr</code>           \u2013            <p>Wrapper of Attr to represent a node attribute.</p> </li> </ul>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr","title":"EdgeAttr","text":"<pre><code>EdgeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <p>Wrapper of Attr to represent an edge attribute.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(other: ExprInput, op: Callable, reverse: bool = False) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr","title":"NodeAttr","text":"<pre><code>NodeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <p>Wrapper of Attr to represent a node attribute.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(other: ExprInput, op: Callable, reverse: bool = False) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/array/","title":"tracksdata.array","text":""},{"location":"reference/tracksdata/array/#tracksdata.array","title":"tracksdata.array","text":"<p>Array representation of graphical data.</p> <p>Provides read-only array views of graph attributes, with lazy loading from original data sources.</p> <p>Classes:</p> <ul> <li> <code>GraphArrayView</code>           \u2013            <p>Class used to view the content of a graph as an array.</p> </li> </ul>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView","title":"GraphArrayView","text":"<pre><code>GraphArrayView(graph: BaseGraph, shape: tuple[int, ...], attr_key: str, offset: int | ndarray = 0)\n</code></pre> <p>               Bases: <code>BaseReadOnlyArray</code></p> <p>Class used to view the content of a graph as an array.</p> <p>The resulting graph behaves as a read-only numpy array, displaying arbitrary attributes inside their respective instance mask.</p> <p>The content is lazy loaded from the original data source as it's done with a zarr.Array</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__len__</code>             \u2013              <p>Returns the length of the first dimension of the array.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>ndim</code>               (<code>int</code>)           \u2013            <p>Returns the number of dimensions of the array.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def __init__(\n    self,\n    graph: BaseGraph,\n    shape: tuple[int, ...],\n    attr_key: str,\n    offset: int | np.ndarray = 0,\n):\n    if attr_key not in graph.node_attr_keys:\n        raise ValueError(f\"Attribute key '{attr_key}' not found in graph. Expected '{graph.node_attr_keys}'\")\n\n    self.graph = graph\n    self._shape = shape\n    self._attr_key = attr_key\n    self._offset = offset\n    self._dtype = np.int32\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to view as an array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(attr_key)","title":"<code>attr_key</code>","text":"(<code>str</code>)           \u2013            <p>The attribute key to view as an array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(offset)","title":"<code>offset</code>","text":"(<code>int | ndarray</code>, default:                   <code>0</code> )           \u2013            <p>The offset to apply to the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.ndim","title":"ndim  <code>property</code>","text":"<pre><code>ndim: int\n</code></pre> <p>Returns the number of dimensions of the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns the length of the first dimension of the array.</p> Source code in <code>src/tracksdata/array/_base_array.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns the length of the first dimension of the array.\"\"\"\n    return self.shape[0]\n</code></pre>"},{"location":"reference/tracksdata/attrs/","title":"tracksdata.attrs","text":""},{"location":"reference/tracksdata/attrs/#tracksdata.attrs","title":"tracksdata.attrs","text":"<p>Module to compose attribute expressions for attribute filtering or value evaluation.</p> <p>Attributes are used to query content of nodes and edges through their names as columns in a data frame.</p> <p>Users will mostly interact with NodeAttr and EdgeAttr which are thin wrappers around Attr to distinguish between node and edge attributes in ambiguous cases.</p> <p>They can be used to filter elements in the graph as: <pre><code>graph.subgraph(NodeAttr(\"t\") == 1)\n</code></pre></p> <p>Or to create complex expression when solving the tracking problem: <pre><code>NearestNeighborsSolver(-Attr(\"iou\") * (-Attr(\"distance\") / 30.0).exp())\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>AttrComparison</code>           \u2013            <p>Class to store a comparison between an Attr and a value.</p> </li> <li> <code>EdgeAttr</code>           \u2013            <p>Wrapper of Attr to represent an edge attribute.</p> </li> <li> <code>NodeAttr</code>           \u2013            <p>Wrapper of Attr to represent a node attribute.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>attr_comps_to_strs</code>             \u2013              <p>Convert a list of attribute comparisons to a list of strings.</p> </li> <li> <code>polars_reduce_attr_comps</code>             \u2013              <p>Reduce a list of attribute comparisons into a single polars expression.</p> </li> <li> <code>split_attr_comps</code>             \u2013              <p>Split a list of attribute comparisons into node and edge attribute comparisons.</p> </li> </ul>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr","title":"Attr","text":"<pre><code>Attr(value: ExprInput)\n</code></pre> <p>A class to compose an attribute expression for attribute filtering or value evaluation.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr--parameters","title":"Parameters","text":"<p>value : ExprInput     The value to compose the attribute expression from.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr--examples","title":"Examples","text":"<pre><code>Attr(\"t\") == 1  # filter for time point 1\nAttr(\"iou\").log()  # log the iou\nAttr(1.0)  # constant value\nAttr((1 - Attr(\"iou\")) * Attr(\"distance\"))  # complex expression\n</code></pre> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(other: ExprInput, op: Callable, reverse: bool = False) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.AttrComparison","title":"AttrComparison","text":"<pre><code>AttrComparison(attr: Attr, op: Callable, other: ExprInput)\n</code></pre> <p>Class to store a comparison between an Attr and a value. It's mainly used for filtering. Complex expression are transformed back to Attr objects which can be used to evaluate the expression on a DataFrame.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.AttrComparison--parameters","title":"Parameters","text":"<p>attr : Attr     The attribute to compare. op : Callable     The operator to use for the comparison. other : ExprInput     The value to compare the attribute to.</p> <p>Methods:</p> <ul> <li> <code>to_attr</code>             \u2013              <p>Transform the comparison back to an Attr object.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, attr: \"Attr\", op: Callable, other: ExprInput) -&gt; None:\n    if attr.has_inf():\n        raise ValueError(\"Comparison operators are not supported for expressions with infinity.\")\n\n    if isinstance(other, Attr):\n        raise ValueError(f\"Does not support comparison between expressions. Found {other} and {attr}.\")\n\n    columns = attr.expr_columns\n\n    if len(columns) == 0:\n        raise ValueError(\"Comparison operators are not supported for empty expressions.\")\n\n    elif len(columns) &gt; 1:\n        raise ValueError(f\"Comparison operators are not supported for multiple columns. Found {columns}.\")\n\n    self.attr = attr\n    self.column = columns[0]\n    self.op = op\n\n    if isinstance(other, np.ndarray):\n        # casting numpy scalars to python scalars\n        # numpy scalars are problematic for sqlalchemy\n        other = other.item()\n    self.other = other\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.AttrComparison.to_attr","title":"to_attr","text":"<pre><code>to_attr() -&gt; Attr\n</code></pre> <p>Transform the comparison back to an Attr object. This is useful for evaluating the expression on a DataFrame.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def to_attr(self) -&gt; \"Attr\":\n    \"\"\"\n    Transform the comparison back to an [Attr][tracksdata.attrs.Attr] object.\n    This is useful for evaluating the expression on a DataFrame.\n    \"\"\"\n    return Attr(self.op(pl.col(self.column), self.other))\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr","title":"EdgeAttr","text":"<pre><code>EdgeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <p>Wrapper of Attr to represent an edge attribute.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(other: ExprInput, op: Callable, reverse: bool = False) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr","title":"NodeAttr","text":"<pre><code>NodeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <p>Wrapper of Attr to represent a node attribute.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(other: ExprInput, op: Callable, reverse: bool = False) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs._setup_ops","title":"_setup_ops","text":"<pre><code>_setup_ops() -&gt; None\n</code></pre> <p>Setup the operator methods for the AttrExpr class.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _setup_ops() -&gt; None:\n    \"\"\"\n    Setup the operator methods for the AttrExpr class.\n    \"\"\"\n    bin_ops = {\n        \"add\": operator.add,\n        \"sub\": operator.sub,\n        \"mul\": operator.mul,\n        \"truediv\": operator.truediv,\n        \"floordiv\": operator.floordiv,\n        \"mod\": operator.mod,\n        \"pow\": operator.pow,\n        \"and\": operator.and_,\n        \"or\": operator.or_,\n        \"xor\": operator.xor,\n    }\n\n    comp_ops = {\n        \"eq\": operator.eq,\n        \"ne\": operator.ne,\n        \"lt\": operator.lt,\n        \"le\": operator.le,\n        \"gt\": operator.gt,\n        \"ge\": operator.ge,\n    }\n\n    for op_name, op_func in bin_ops.items():\n        _add_operator(Attr, f\"__{op_name}__\", op_func, reverse=False)\n        _add_operator(Attr, f\"__r{op_name}__\", op_func, reverse=True)\n        _add_operator(AttrComparison, f\"__{op_name}__\", op_func, reverse=False)\n        _add_operator(AttrComparison, f\"__r{op_name}__\", op_func, reverse=True)\n\n    for op_name, op_func in comp_ops.items():\n        _add_comparison_operator(f\"__{op_name}__\", op_func, reverse=False)\n        _add_comparison_operator(f\"__r{op_name}__\", op_func, reverse=True)\n\n        # attrr_comparision uses normal delegate_operator\n        _add_operator(AttrComparison, f\"__{op_name}__\", op_func, reverse=False)\n        _add_operator(AttrComparison, f\"__r{op_name}__\", op_func, reverse=True)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.attr_comps_to_strs","title":"attr_comps_to_strs","text":"<pre><code>attr_comps_to_strs(attr_comps: Sequence[AttrComparison]) -&gt; list[str]\n</code></pre> <p>Convert a list of attribute comparisons to a list of strings.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The attribute comparisons as strings.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def attr_comps_to_strs(attr_comps: Sequence[AttrComparison]) -&gt; list[str]:\n    \"\"\"\n    Convert a list of attribute comparisons to a list of strings.\n\n    Parameters\n    ----------\n    attr_comps : Sequence[AttrComparison]\n        The attribute comparisons to convert to strings.\n\n    Returns\n    -------\n    list[str]\n        The attribute comparisons as strings.\n    \"\"\"\n    return [str(attr_comp.column) for attr_comp in attr_comps]\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.attr_comps_to_strs(attr_comps)","title":"<code>attr_comps</code>","text":"(<code>Sequence[AttrComparison]</code>)           \u2013            <p>The attribute comparisons to convert to strings.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps","title":"polars_reduce_attr_comps","text":"<pre><code>polars_reduce_attr_comps(df: DataFrame, attr_comps: Sequence[AttrComparison], reduce_op: Callable[[Expr, Expr], Expr]) -&gt; pl.Expr\n</code></pre> <p>Reduce a list of attribute comparisons into a single polars expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Expr</code>           \u2013            <p>The reduced polars expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def polars_reduce_attr_comps(\n    df: pl.DataFrame,\n    attr_comps: Sequence[AttrComparison],\n    reduce_op: Callable[[Expr, Expr], Expr],\n) -&gt; pl.Expr:\n    \"\"\"\n    Reduce a list of attribute comparisons into a single polars expression.\n\n    Parameters\n    ----------\n    df : pl.DataFrame\n        The dataframe to reduce the attribute comparisons on.\n    attr_comps : Sequence[AttrComparison]\n        The attribute comparisons to reduce.\n    reduce_op : Callable[[Expr, Expr], Expr]\n        The operation to reduce the attribute comparisons with.\n\n    Returns\n    -------\n    pl.Expr\n        The reduced polars expression.\n    \"\"\"\n    if not attr_comps:\n        # Return True for all rows by using the first column as a reference\n        raise ValueError(\"No attribute comparisons provided.\")\n\n    return pl.reduce(reduce_op, [attr_comp.op(df[str(attr_comp.column)], attr_comp.other) for attr_comp in attr_comps])\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The dataframe to reduce the attribute comparisons on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps(attr_comps)","title":"<code>attr_comps</code>","text":"(<code>Sequence[AttrComparison]</code>)           \u2013            <p>The attribute comparisons to reduce.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps(reduce_op)","title":"<code>reduce_op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operation to reduce the attribute comparisons with.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.split_attr_comps","title":"split_attr_comps","text":"<pre><code>split_attr_comps(attr_comps: Sequence[AttrComparison]) -&gt; tuple[list[AttrComparison], list[AttrComparison]]\n</code></pre> <p>Split a list of attribute comparisons into node and edge attribute comparisons.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[AttrComparison], list[AttrComparison]]</code>           \u2013            <p>A tuple of lists of node and edge attribute comparisons.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def split_attr_comps(attr_comps: Sequence[AttrComparison]) -&gt; tuple[list[AttrComparison], list[AttrComparison]]:\n    \"\"\"\n    Split a list of attribute comparisons into node and edge attribute comparisons.\n\n    Parameters\n    ----------\n    attr_comps : Sequence[AttrComparison]\n        The attribute comparisons to split.\n\n    Returns\n    -------\n    tuple[list[AttrComparison], list[AttrComparison]]\n        A tuple of lists of node and edge attribute comparisons.\n    \"\"\"\n    node_attr_comps = []\n    edge_attr_comps = []\n\n    for attr_comp in attr_comps:\n        if isinstance(attr_comp.attr, NodeAttr):\n            node_attr_comps.append(attr_comp)\n        elif isinstance(attr_comp.attr, EdgeAttr):\n            edge_attr_comps.append(attr_comp)\n        else:\n            raise ValueError(f\"Expected comparisons of 'NodeAttr' or 'EdgeAttr' objects, got {type(attr_comp.attr)}\")\n\n    return node_attr_comps, edge_attr_comps\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.split_attr_comps(attr_comps)","title":"<code>attr_comps</code>","text":"(<code>Sequence[AttrComparison]</code>)           \u2013            <p>The attribute comparisons to split.</p>"},{"location":"reference/tracksdata/constants/","title":"tracksdata.constants","text":""},{"location":"reference/tracksdata/constants/#tracksdata.constants","title":"tracksdata.constants","text":"<p>Module to define default and often global values used through <code>tracksdata</code>.</p> <p>Classes:</p> <ul> <li> <code>DefaultAttrKeys</code>           \u2013            <p>This class defines the standard attribute names for nodes and edges in graphs to ensure</p> </li> </ul>"},{"location":"reference/tracksdata/constants/#tracksdata.constants.DefaultAttrKeys","title":"DefaultAttrKeys","text":"<p>This class defines the standard attribute names for nodes and edges in graphs to ensure consistency across different graph implementations and operators.</p> <p>Using these constants instead of hardcoded strings helps prevent typos.</p> <p>Attributes:</p> <ul> <li> <code>NODE_ID</code>               (<code>str</code>)           \u2013            <p>Default key for node identifiers.</p> </li> <li> <code>T</code>               (<code>str</code>)           \u2013            <p>Default key for time information.</p> </li> <li> <code>MASK</code>               (<code>str</code>)           \u2013            <p>Default key for node masks.</p> </li> <li> <code>SOLUTION</code>               (<code>str</code>)           \u2013            <p>Default key for solution information.</p> </li> <li> <code>TRACK_ID</code>               (<code>str</code>)           \u2013            <p>Default key for track identifiers.</p> </li> <li> <code>EDGE_ID</code>               (<code>str</code>)           \u2013            <p>Default key for edge identifiers.</p> </li> <li> <code>EDGE_WEIGHT</code>               (<code>str</code>)           \u2013            <p>Default key for edge weights.</p> </li> <li> <code>EDGE_SOURCE</code>               (<code>str</code>)           \u2013            <p>Default key for edge source node identifier.</p> </li> <li> <code>EDGE_TARGET</code>               (<code>str</code>)           \u2013            <p>Default key for edge target node identifier.</p> </li> <li> <code>MATCHED_NODE_ID</code>               (<code>str</code>)           \u2013            <p>Default key to identify respective node in another graph used for matching.</p> </li> <li> <code>MATCH_SCORE</code>               (<code>str</code>)           \u2013            <p>Default key between a node and its respective node in another graph used for matching.</p> </li> <li> <code>MATCHED_EDGE_MASK</code>               (<code>str</code>)           \u2013            <p>Default key for boolean mask indicating if edge exists in the matching graph.</p> </li> </ul> <p>Examples:</p> <pre><code>from tracksdata.constants import DEFAULT_ATTR_KEYS\n\nprint(DEFAULT_ATTR_KEYS.NODE_ID)  # Output: node_id\nprint(DEFAULT_ATTR_KEYS.EDGE_WEIGHT)  # Output: weight\n</code></pre>"},{"location":"reference/tracksdata/edges/","title":"tracksdata.edges","text":""},{"location":"reference/tracksdata/edges/#tracksdata.edges","title":"tracksdata.edges","text":"<p>Edge operators for creating connections between nodes of a graph.</p> <p>Classes:</p> <ul> <li> <code>DistanceEdges</code>           \u2013            <p>Operator that adds edges to a graph based on Euclidean distance between nodes.</p> </li> <li> <code>GenericFuncEdgeAttrs</code>           \u2013            <p>Add weights to the edges of the graph based on the output of a function.</p> </li> <li> <code>IoUEdgeAttr</code>           \u2013            <p>Add weights to the edges of the graph based on the IoU</p> </li> </ul>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges","title":"DistanceEdges","text":"<pre><code>DistanceEdges(distance_threshold: float, n_neighbors: int, delta_t: int = 1, output_key: str = DEFAULT_ATTR_KEYS.EDGE_DIST, attr_keys: Sequence[str] | None = None)\n</code></pre> <p>               Bases: <code>BaseEdgesOperator</code></p> <p>Operator that adds edges to a graph based on Euclidean distance between nodes.</p> <p>Creates edges between nodes in consecutive time points by finding the closest neighbors within a specified distance threshold using efficient KDTree-based spatial indexing. Creates directed edges from nodes in the range t-1 to t-delta_t to the nodes in the current time point t, representing potential transitions.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            <p>The distance threshold for adding edges.</p> </li> <li> <code>n_neighbors</code>               (<code>int</code>)           \u2013            <p>The maximum number of neighbors to consider for adding edges. This in respect from the current to the previous frame. That means, a node in frame t will have edges to the closest n_neighbors nodes in frame t-1.</p> </li> <li> <code>output_key</code>               (<code>str</code>)           \u2013            <p>The key used to store distance values in edges.</p> </li> <li> <code>attr_keys</code>               (<code>Sequence[str] | None</code>)           \u2013            <p>The attribute keys to use for the distance calculation. When None, \"z\", \"y\", \"x\" are used.</p> </li> <li> <code>show_progress</code>               (<code>bool</code>)           \u2013            <p>Whether to print progress of the edges addition.</p> </li> </ul> <p>Examples:</p> <p>Create a distance-based edge operator:</p> <pre><code>from tracksdata.edges import DistanceEdges\n\nedge_op = DistanceEdges(distance_threshold=50.0, n_neighbors=3, attr_keys=[\"x\", \"y\"])\n</code></pre> <p>Add edges to a graph:</p> <pre><code>edge_op.add_edges(graph)\n</code></pre> <p>Add edges for a specific time point:</p> <pre><code>edge_op.add_edges(graph, t=5)\n</code></pre> <p>Use custom output key:</p> <pre><code>edge_op = DistanceEdges(distance_threshold=30.0, n_neighbors=2, output_key=\"euclidean_distance\")\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_edges</code>             \u2013              <p>Initialize the edges from nodes of given <code>time</code> to nodes in neighboring</p> </li> </ul> Source code in <code>src/tracksdata/edges/_distance_edges.py</code> <pre><code>def __init__(\n    self,\n    distance_threshold: float,\n    n_neighbors: int,\n    delta_t: int = 1,\n    output_key: str = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    attr_keys: Sequence[str] | None = None,\n):\n    if delta_t &lt; 1:\n        raise ValueError(f\"'delta_t' must be at least 1, got {delta_t}\")\n\n    super().__init__(output_key=output_key)\n    self.distance_threshold = distance_threshold\n    self.n_neighbors = n_neighbors\n    self.delta_t = delta_t\n    self.attr_keys = attr_keys\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(distance_threshold)","title":"<code>distance_threshold</code>","text":"(<code>float</code>)           \u2013            <p>Maximum Euclidean distance for adding edges between nodes. Nodes farther apart than this threshold will not be connected.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(n_neighbors)","title":"<code>n_neighbors</code>","text":"(<code>int</code>)           \u2013            <p>Maximum number of neighbors to consider for each node when adding edges. For each node at time t, edges will be created to at most n_neighbors closest nodes at time t-1 to t-delta_t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(delta_t)","title":"<code>delta_t</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of time points to consider for adding edges. For each node at time t, edges will be created to the closest n_neighbors nodes at time t-1 to t-delta_t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>DEFAULT_ATTR_KEYS.EDGE_WEIGHT</code> )           \u2013            <p>The attribute key to store the distance values in the edges.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node attribute keys to use for distance calculation. If None, defaults to [\"z\", \"y\", \"x\"] if \"z\" exists, otherwise [\"y\", \"x\"].</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._add_edges_per_time","title":"_add_edges_per_time","text":"<pre><code>_add_edges_per_time(t: int, *, graph: BaseGraph) -&gt; list[dict[str, Any]]\n</code></pre> <p>Add distance-based edges between nodes at consecutive time points.</p> <p>Finds nodes at time t-1 and t, computes pairwise distances using KDTree, and creates edges between nearby nodes within the distance threshold. Uses bulk edge insertion for efficiency.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_distance_edges.py</code> <pre><code>def _add_edges_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Add distance-based edges between nodes at consecutive time points.\n\n    Finds nodes at time t-1 and t, computes pairwise distances using KDTree,\n    and creates edges between nearby nodes within the distance threshold.\n    Uses bulk edge insertion for efficiency.\n\n    Parameters\n    ----------\n    t : int\n        The current time point. Edges will be created from nodes at\n        time t-1 to nodes at time t.\n    graph : BaseGraph\n        The current time point. Edges will be created from nodes at\n        time t-1 to nodes at time t.\n    \"\"\"\n    if self.attr_keys is None:\n        if \"z\" in graph.node_attr_keys:\n            attr_keys = [\"z\", \"y\", \"x\"]\n        else:\n            attr_keys = [\"y\", \"x\"]\n    else:\n        attr_keys = self.attr_keys\n\n    if self.delta_t == 1:\n        # faster than the range filter\n        prev_node_ids = graph.filter_nodes_by_attrs(NodeAttr(DEFAULT_ATTR_KEYS.T) == t - 1)\n    else:\n        prev_node_ids = graph.filter_nodes_by_attrs(\n            NodeAttr(DEFAULT_ATTR_KEYS.T) &gt;= t - self.delta_t,\n            NodeAttr(DEFAULT_ATTR_KEYS.T) &lt; t,\n        )\n    cur_node_ids = graph.filter_nodes_by_attrs(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n\n    if len(prev_node_ids) == 0:\n        LOG.warning(\n            \"No nodes found for time point in range (%d &lt;= t &lt; %d)\",\n            t - self.delta_t,\n            t,\n        )\n        return []\n\n    if len(cur_node_ids) == 0:\n        LOG.warning(\n            \"No nodes found for time point %d\",\n            t,\n        )\n        return []\n\n    prev_attrs = graph.node_attrs(node_ids=prev_node_ids, attr_keys=attr_keys)\n    cur_attrs = graph.node_attrs(node_ids=cur_node_ids, attr_keys=attr_keys)\n\n    prev_kdtree = KDTree(prev_attrs.to_numpy())\n\n    distances, prev_neigh_ids = prev_kdtree.query(\n        cur_attrs.to_numpy(),\n        k=self.n_neighbors,\n        distance_upper_bound=self.distance_threshold,\n    )\n    is_valid = ~np.isinf(distances)\n\n    prev_node_ids = np.asarray(prev_node_ids)\n    # kdtree return from 0 to n-1\n    # converting back to arbitrary indexing\n    prev_neigh_ids[is_valid] = prev_node_ids[prev_neigh_ids[is_valid]]\n\n    edges_data = []\n    for cur_id, neigh_ids, neigh_dist, neigh_valid in zip(\n        cur_node_ids, prev_neigh_ids, distances, is_valid, strict=True\n    ):\n        for neigh_id, dist in zip(neigh_ids[neigh_valid].tolist(), neigh_dist[neigh_valid].tolist(), strict=True):\n            edges_data.append(\n                {\n                    \"source_id\": neigh_id,\n                    \"target_id\": cur_id,\n                    self.output_key: dist,\n                }\n            )\n\n    if len(edges_data) == 0:\n        LOG.warning(\"No valid edges found for the pair of time point (%d, %d)\", t, t - 1)\n\n    return edges_data\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._add_edges_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The current time point. Edges will be created from nodes at time t-1 to nodes at time t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._add_edges_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The current time point. Edges will be created from nodes at time t-1 to nodes at time t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._init_edge_attrs","title":"_init_edge_attrs","text":"<pre><code>_init_edge_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the edge attributes for the graph.</p> Source code in <code>src/tracksdata/edges/_distance_edges.py</code> <pre><code>def _init_edge_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the edge attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, default_value=-99999.0)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges","title":"add_edges","text":"<pre><code>add_edges(graph: BaseGraph, *, t: int | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the edges from nodes of given <code>time</code> to nodes in neighboring times (<code>time</code> + <code>\\delta time</code>)</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_base_edges.py</code> <pre><code>def add_edges(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    r\"\"\"\n    Initialize the edges from nodes of given `time` to nodes in neighboring\n    times (`time` + `\\delta time`)\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to initialize the edges in.\n    t: int\n        The time of the nodes to initialize the edges from.\n    **kwargs: Any\n        Additional keyword arguments to pass to the `add_edges` method.\n    \"\"\"\n    self._init_edge_attrs(graph)\n\n    if t is None:\n        time_points = graph.time_points()\n    else:\n        time_points = [t]\n\n    for edge_attrs in multiprocessing_apply(\n        curry(self._add_edges_per_time, graph=graph, **kwargs),\n        time_points,\n        desc=\"Adding edges\",\n    ):\n        graph.bulk_add_edges(edge_attrs)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to initialize the edges in.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time of the nodes to initialize the edges from.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>add_edges</code> method.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs","title":"GenericFuncEdgeAttrs","text":"<pre><code>GenericFuncEdgeAttrs(func: Callable[[dict[str, Any] | Any, dict[str, Any] | Any], Any], attr_keys: Sequence[str] | str, output_key: str)\n</code></pre> <p>               Bases: <code>BaseEdgeAttrsOperator</code></p> <p>Add weights to the edges of the graph based on the output of a function.</p> <p>When provided multiple attribute keys, the function should take a dict with the keys as values for each node.</p> <p>When provided a single attribute key, the function should take the value for each node.</p> <p>For example, if the function is <code>func(source_attr, target_attr)</code>, and the attribute keys are <code>[\"a\", \"b\"]</code>, then the function should be <code>func({\"a\": 1, \"b\": 2}, {\"a\": 3, \"b\": 4})</code>.</p> <p>For a single attribute key \"a\", the function should take a single value for each node, as <code>func(1, 3)</code>.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_edge_attrs</code>             \u2013              <p>Add attributes to the edges of the graph for a given time or all time points.</p> </li> </ul> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[[dict[str, Any] | Any, dict[str, Any] | Any], Any],\n    attr_keys: Sequence[str] | str,\n    output_key: str,\n) -&gt; None:\n    super().__init__(output_key=output_key)\n    self.attr_keys = attr_keys\n    self.func = func\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs(func)","title":"<code>func</code>","text":"(<code>Callable[[dict[str, Any] | Any, dict[str, Any] | Any], Any]</code>)           \u2013            <p>The function to apply to the source and target attributes.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str</code>)           \u2013            <p>The keys of the attributes to pass to the function.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to store the output of the function.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._edge_attrs_per_time","title":"_edge_attrs_per_time","text":"<pre><code>_edge_attrs_per_time(t: int, *, graph: BaseGraph) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add weights to the edges of the graph based on the output of a function for a specific time point.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _edge_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add weights to the edges of the graph based on the output of a function\n    for a specific time point.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add weights for.\n    graph : BaseGraph\n        The graph to add weights to.\n    \"\"\"\n    source_ids = graph.filter_nodes_by_attrs(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n    edges_df = graph.edge_attrs(node_ids=source_ids, include_targets=True)\n\n    if len(edges_df) == 0:\n        LOG.warning(f\"No edges found for time point {t} to sucessors\")\n        return [], {}\n\n    source_df = graph.node_attrs(\n        node_ids=edges_df[DEFAULT_ATTR_KEYS.EDGE_SOURCE].to_numpy(),\n        attr_keys=self.attr_keys,\n    )\n    target_df = graph.node_attrs(\n        node_ids=edges_df[DEFAULT_ATTR_KEYS.EDGE_TARGET].to_numpy(),\n        attr_keys=self.attr_keys,\n    )\n\n    weights = np.zeros(len(edges_df), dtype=np.float32)\n\n    if isinstance(self.attr_keys, str):\n        # faster than creating a dict\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys],\n                target_df[self.attr_keys],\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n    else:\n        # a bit more expensive to create a dict but more flexible\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys].iter_rows(named=True),\n                target_df[self.attr_keys].iter_rows(named=True),\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n\n    return edges_df[DEFAULT_ATTR_KEYS.EDGE_ID].to_list(), {self.output_key: weights}\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._edge_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add weights for.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._edge_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add weights to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._init_edge_attrs","title":"_init_edge_attrs","text":"<pre><code>_init_edge_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the edge attributes for the graph.</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _init_edge_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the edge attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, default_value=-99999.0)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs","title":"add_edge_attrs","text":"<pre><code>add_edge_attrs(graph: BaseGraph, *, t: int | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Add attributes to the edges of the graph for a given time or all time points.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_base_edge_attrs.py</code> <pre><code>def add_edge_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Add attributes to the edges of the graph for a given time or all time points.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    **kwargs : Any\n        Additional keyword arguments to pass to the `_add_edge_attrs_per_time` method.\n    \"\"\"\n    self._init_edge_attrs(graph)\n\n    if t is None:\n        time_points = graph.time_points()\n    else:\n        time_points = [t]\n\n    for edge_ids, edge_attrs in multiprocessing_apply(\n        func=curry(self._edge_attrs_per_time, graph=graph, **kwargs),\n        sequence=time_points,\n        desc=\"Adding edge attributes\",\n    ):\n        graph.update_edge_attrs(edge_ids=edge_ids, attrs=edge_attrs)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>_add_edge_attrs_per_time</code> method.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr","title":"IoUEdgeAttr","text":"<pre><code>IoUEdgeAttr(output_key: str, mask_key: str = DEFAULT_ATTR_KEYS.MASK)\n</code></pre> <p>               Bases: <code>GenericFuncEdgeAttrs</code></p> <p>Add weights to the edges of the graph based on the IoU of the masks of the nodes.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_edge_attrs</code>             \u2013              <p>Add attributes to the edges of the graph for a given time or all time points.</p> </li> </ul> Source code in <code>src/tracksdata/edges/_iou_edges.py</code> <pre><code>def __init__(\n    self,\n    output_key: str,\n    mask_key: str = DEFAULT_ATTR_KEYS.MASK,\n):\n    super().__init__(\n        func=Mask.iou,\n        attr_keys=mask_key,\n        output_key=output_key,\n    )\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the output of the IoU.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr(mask_key)","title":"<code>mask_key</code>","text":"(<code>str</code>, default:                   <code>MASK</code> )           \u2013            <p>The key to use for the masks of the nodes.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._edge_attrs_per_time","title":"_edge_attrs_per_time","text":"<pre><code>_edge_attrs_per_time(t: int, *, graph: BaseGraph) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add weights to the edges of the graph based on the output of a function for a specific time point.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _edge_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add weights to the edges of the graph based on the output of a function\n    for a specific time point.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add weights for.\n    graph : BaseGraph\n        The graph to add weights to.\n    \"\"\"\n    source_ids = graph.filter_nodes_by_attrs(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n    edges_df = graph.edge_attrs(node_ids=source_ids, include_targets=True)\n\n    if len(edges_df) == 0:\n        LOG.warning(f\"No edges found for time point {t} to sucessors\")\n        return [], {}\n\n    source_df = graph.node_attrs(\n        node_ids=edges_df[DEFAULT_ATTR_KEYS.EDGE_SOURCE].to_numpy(),\n        attr_keys=self.attr_keys,\n    )\n    target_df = graph.node_attrs(\n        node_ids=edges_df[DEFAULT_ATTR_KEYS.EDGE_TARGET].to_numpy(),\n        attr_keys=self.attr_keys,\n    )\n\n    weights = np.zeros(len(edges_df), dtype=np.float32)\n\n    if isinstance(self.attr_keys, str):\n        # faster than creating a dict\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys],\n                target_df[self.attr_keys],\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n    else:\n        # a bit more expensive to create a dict but more flexible\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys].iter_rows(named=True),\n                target_df[self.attr_keys].iter_rows(named=True),\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n\n    return edges_df[DEFAULT_ATTR_KEYS.EDGE_ID].to_list(), {self.output_key: weights}\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._edge_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add weights for.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._edge_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add weights to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._init_edge_attrs","title":"_init_edge_attrs","text":"<pre><code>_init_edge_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the edge attributes for the graph.</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _init_edge_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the edge attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, default_value=-99999.0)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs","title":"add_edge_attrs","text":"<pre><code>add_edge_attrs(graph: BaseGraph, *, t: int | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Add attributes to the edges of the graph for a given time or all time points.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_base_edge_attrs.py</code> <pre><code>def add_edge_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Add attributes to the edges of the graph for a given time or all time points.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    **kwargs : Any\n        Additional keyword arguments to pass to the `_add_edge_attrs_per_time` method.\n    \"\"\"\n    self._init_edge_attrs(graph)\n\n    if t is None:\n        time_points = graph.time_points()\n    else:\n        time_points = [t]\n\n    for edge_ids, edge_attrs in multiprocessing_apply(\n        func=curry(self._edge_attrs_per_time, graph=graph, **kwargs),\n        sequence=time_points,\n        desc=\"Adding edge attributes\",\n    ):\n        graph.update_edge_attrs(edge_ids=edge_ids, attrs=edge_attrs)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>_add_edge_attrs_per_time</code> method.</p>"},{"location":"reference/tracksdata/functional/","title":"tracksdata.functional","text":""},{"location":"reference/tracksdata/functional/#tracksdata.functional","title":"tracksdata.functional","text":"<p>Functional utilities for graph operations.</p> <p>Functions:</p> <ul> <li> <code>to_napari_format</code>             \u2013              <p>Convert the subgraph of solution nodes to a napari-ready format.</p> </li> </ul>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format","title":"to_napari_format","text":"<pre><code>to_napari_format(graph: BaseGraph, shape: tuple[int, ...], solution_key: str = DEFAULT_ATTR_KEYS.SOLUTION, output_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID) -&gt; tuple[GraphArrayView, pl.DataFrame, dict[int, int]]\n</code></pre> <p>Convert the subgraph of solution nodes to a napari-ready format.</p> <p>This includes: - a labels layer with the solution nodes - a tracks layer with the solution tracks - a graph with the parent-child relationships for the solution tracks</p> <p>IMPORTANT: This function will reset the track ids if they already exist.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[GraphArrayView, DataFrame, dict[int, int]]</code>           \u2013            <ul> <li>array_view: The array view of the solution graph.</li> <li>tracks_data: The tracks data as a polars DataFrame.</li> <li>dict_graph: A dictionary of parent -&gt; child relationships.</li> </ul> </li> </ul> Source code in <code>src/tracksdata/functional/_napari.py</code> <pre><code>def to_napari_format(\n    graph: BaseGraph,\n    shape: tuple[int, ...],\n    solution_key: str = DEFAULT_ATTR_KEYS.SOLUTION,\n    output_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n) -&gt; tuple[\n    \"GraphArrayView\",\n    pl.DataFrame,\n    dict[int, int],\n]:\n    \"\"\"\n    Convert the subgraph of solution nodes to a napari-ready format.\n\n    This includes:\n    - a labels layer with the solution nodes\n    - a tracks layer with the solution tracks\n    - a graph with the parent-child relationships for the solution tracks\n\n    IMPORTANT: This function will reset the track ids if they already exist.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to convert.\n    shape : tuple[int, ...]\n        The shape of the labels layer.\n    solution_key : str, optional\n        The key of the solution attribute.\n    output_track_id_key : str, optional\n        The key of the output track id attribute.\n\n    Returns\n    -------\n    tuple[GraphArrayView, pl.DataFrame, dict[int, int]]\n        - array_view: The array view of the solution graph.\n        - tracks_data: The tracks data as a polars DataFrame.\n        - dict_graph: A dictionary of parent -&gt; child relationships.\n    \"\"\"\n    solution_graph = graph.subgraph(NodeAttr(solution_key) == True, EdgeAttr(solution_key) == True)\n\n    tracks_graph = solution_graph.assign_track_ids(output_track_id_key)\n    dict_graph = {child: parent for parent, child in tracks_graph.edge_list()}\n\n    spatial_cols = [\"z\", \"y\", \"x\"][-len(shape) + 1 :]\n\n    tracks_data = solution_graph.node_attrs(\n        attr_keys=[output_track_id_key, DEFAULT_ATTR_KEYS.T, *spatial_cols],\n    )\n\n    from tracksdata.array._graph_array import GraphArrayView\n\n    array_view = GraphArrayView(\n        solution_graph,\n        shape,\n        attr_key=output_track_id_key,\n    )\n\n    # sorting columns\n    tracks_data = tracks_data.select([output_track_id_key, DEFAULT_ATTR_KEYS.T, *spatial_cols])\n\n    return array_view, tracks_data, dict_graph\n</code></pre>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to convert.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the labels layer.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(solution_key)","title":"<code>solution_key</code>","text":"(<code>str</code>, default:                   <code>SOLUTION</code> )           \u2013            <p>The key of the solution attribute.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(output_track_id_key)","title":"<code>output_track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the output track id attribute.</p>"},{"location":"reference/tracksdata/graph/","title":"tracksdata.graph","text":""},{"location":"reference/tracksdata/graph/#tracksdata.graph","title":"tracksdata.graph","text":"<p>Graph backends for representing tracking data as directed graphs in memory or on disk.</p> <p>Classes:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>Base class for a graph backend.</p> </li> <li> <code>GraphView</code>           \u2013            <p>A filtered view of a graph that maintains bidirectional mapping to the root graph.</p> </li> <li> <code>RustWorkXGraph</code>           \u2013            <p>High-performance in-memory graph implementation using rustworkx.</p> </li> <li> <code>SQLGraph</code>           \u2013            <p>SQL-based graph implementation using SQLAlchemy ORM.</p> </li> </ul>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph","title":"BaseGraph","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for a graph backend.</p> <p>Methods:</p> <ul> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edge_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph at time t.</p> </li> <li> <code>add_node_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>edge_attrs</code>             \u2013              <p>Get the attributes of the edges as a polars DataFrame.</p> </li> <li> <code>edge_ids</code>             \u2013              <p>Get the IDs of all edges in the graph.</p> </li> <li> <code>filter_nodes_by_attrs</code>             \u2013              <p>Filter nodes by attributes.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_attrs</code>             \u2013              <p>Get the attributes of the nodes as a pandas DataFrame.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the IDs of all nodes in the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessors of a list of nodes.</p> </li> <li> <code>subgraph</code>             \u2013              <p>Create a subgraph from the graph from the given node IDs</p> </li> <li> <code>successors</code>             \u2013              <p>Get the sucessors of a list of nodes.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> <li> <code>update_edge_attrs</code>             \u2013              <p>Update the attributes of the edges.</p> </li> <li> <code>update_node_attrs</code>             \u2013              <p>Update the attributes of the nodes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the edges.</p> </li> <li> <code>node_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the nodes.</p> </li> <li> <code>num_edges</code>               (<code>int</code>)           \u2013            <p>The number of edges in the graph.</p> </li> <li> <code>num_nodes</code>               (<code>int</code>)           \u2013            <p>The number of nodes in the graph.</p> </li> </ul>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attr_keys","title":"edge_attr_keys  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>edge_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attr_keys","title":"node_attr_keys  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>node_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.num_edges","title":"num_edges  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.num_nodes","title":"num_nodes  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(attrs: dict[str, Any], reference_keys: list[str], mode: str) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys():\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge","title":"add_edge  <code>abstractmethod</code>","text":"<pre><code>add_edge(source_id: int, target_id: int, attrs: dict[str, Any], validate_keys: bool = True) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the added edge.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n    attrs : dict[str, Any]\n        Additional attributes for the edge.\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n\n    Returns\n    -------\n    int\n        The ID of the added edge.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Additional attributes for the edge.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge_attr_key","title":"add_edge_attr_key  <code>abstractmethod</code>","text":"<pre><code>add_edge_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing edges will have the default value for the new attribute key.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_edge_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing edges will have the default value for the new attribute key.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node","title":"add_node  <code>abstractmethod</code>","text":"<pre><code>add_node(attrs: dict[str, Any], validate_keys: bool = True) -&gt; int\n</code></pre> <p>Add a node to the graph at time t.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the added node.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph at time t.\n\n    Parameters\n    ----------\n    attrs : Any\n        The attributes of the node to be added, must have a \"t\" key.\n        The keys of the attributes will be used as the attributes of the node.\n        For example:\n        ```python\n        graph.add_node(dict(t=0, label=\"A\", intensity=100))\n        ```\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n\n    Returns\n    -------\n    int\n        The ID of the added node.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>Any</code>)           \u2013            <p>The attributes of the node to be added, must have a \"t\" key. The keys of the attributes will be used as the attributes of the node. For example: <pre><code>graph.add_node(dict(t=0, label=\"A\", intensity=100))\n</code></pre></p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node_attr_key","title":"add_node_attr_key  <code>abstractmethod</code>","text":"<pre><code>add_node_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing nodes will have the default value for the new attribute key.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_node_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing nodes will have the default value for the new attribute key.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_overlap--parameters","title":"Parameters","text":"<p>source_id : int     The ID of the source node. target_id : int     The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_overlap--returns","title":"Returns","text":"<p>int     The ID of the added overlap.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    raise NotImplementedError(f\"{self.__class__.__name__} backend does not support overlaps.\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: Literal[False]) -&gt; None\n</code></pre><pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: Literal[True]) -&gt; list[int]\n</code></pre> <pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None\n</code></pre> <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int] | None</code>           \u2013            <p>The IDs of the added edges.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_edges(\n    self,\n    edges: list[dict[str, Any]],\n    return_ids: bool = False,\n) -&gt; list[int] | None:\n    \"\"\"\n    Faster method to add multiple edges to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        The data of the edges to be added.\n        The keys of the data will be used as the attributes of the edges.\n        Must have \"source_id\" and \"target_id\" keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Returns\n    -------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    # this method benefits the SQLGraph backend\n    if return_ids:\n        edge_ids = []\n        for edge in edges:\n            edge_ids.append(\n                self.add_edge(\n                    edge.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE),\n                    edge.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET),\n                    edge,\n                    validate_keys=False,\n                )\n            )\n        return edge_ids\n\n    # avoiding many ifs and appends\n    for edge in edges:\n        self.add_edge(\n            edge.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE),\n            edge.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET),\n            edge,\n            validate_keys=False,\n        )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the edges to be added. The keys of the data will be used as the attributes of the edges. Must have \"source_id\" and \"target_id\" keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(nodes: list[dict[str, Any]]) -&gt; list[int]\n</code></pre> <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the added nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_nodes(\n    self,\n    nodes: list[dict[str, Any]],\n) -&gt; list[int]:\n    \"\"\"\n    Faster method to add multiple nodes to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        The data of the nodes to be added.\n        The keys of the data will be used as the attributes of the nodes.\n        Must have \"t\" key.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the added nodes.\n    \"\"\"\n    if len(nodes) == 0:\n        return []\n\n    # this method benefits the SQLGraph backend\n    return [self.add_node(node, validate_keys=False) for node in nodes]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the nodes to be added. The keys of the data will be used as the attributes of the nodes. Must have \"t\" key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.BaseGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    for source_id, target_id in overlaps:\n        self.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_ids = self.filter_nodes_by_attrs(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n        masks = self.node_attrs(node_ids=node_ids, attr_keys=[DEFAULT_ATTR_KEYS.MASK])[DEFAULT_ATTR_KEYS.MASK]\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs","title":"edge_attrs  <code>abstractmethod</code>","text":"<pre><code>edge_attrs(*, node_ids: list[int] | None = None, attr_keys: Sequence[str] | None = None, include_targets: bool = False, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the edges as a polars DataFrame.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef edge_attrs(\n    self,\n    *,\n    node_ids: list[int] | None = None,\n    attr_keys: Sequence[str] | None = None,\n    include_targets: bool = False,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the edges as a polars DataFrame.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the subgraph to get the edge attributesfor.\n        If None, all edges of the graph are used.\n    attr_keys : Sequence[str] | None\n        The attribute keys to get.\n        If None, all attributesare used.\n    include_targets : bool\n        Whether to include edges out-going from the given node_ids even\n        if the target node is not in the given node_ids.\n    unpack : bool\n        Whether to unpack array attributesinto multiple scalar attributes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the subgraph to get the edge attributesfor. If None, all edges of the graph are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs(include_targets)","title":"<code>include_targets</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include edges out-going from the given node_ids even if the target node is not in the given node_ids.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributesinto multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_ids","title":"edge_ids  <code>abstractmethod</code>","text":"<pre><code>edge_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all edges in the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef edge_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all edges in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter_nodes_by_attrs","title":"filter_nodes_by_attrs  <code>abstractmethod</code>","text":"<pre><code>filter_nodes_by_attrs(*attrs: AttrComparison) -&gt; list[int]\n</code></pre> <p>Filter nodes by attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the filtered nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef filter_nodes_by_attrs(\n    self,\n    *attrs: AttrComparison,\n) -&gt; list[int]:\n    \"\"\"\n    Filter nodes by attributes.\n\n    Parameters\n    ----------\n    attrs : AttrComparison\n        Attributes to filter by, for example:\n        ```python\n        graph.filter_nodes_by_attrs(Attr(\"t\") == 0, Attr(\"label\") == \"A\")\n        ```\n\n    Returns\n    -------\n    list[int]\n        The IDs of the filtered nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter_nodes_by_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>Attributes to filter by, for example: <pre><code>graph.filter_nodes_by_attrs(Attr(\"t\") == 0, Attr(\"label\") == \"A\")\n</code></pre></p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(positions: ArrayLike, track_ids: ArrayLike | None = None, track_id_graph: dict[int, int] | None = None, radius: ArrayLike = 1, image_shape: tuple[int, ...] | None = None, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. track_ids : np.ndarray | None     Track ids of the nodes if available. track_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. radius : ArrayLike     Integer or N-dimensional array of radii. image_shape : tuple[int, ...] | None     Shape of the image if available masks are cropped to fit the image. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    track_ids: ArrayLike | None = None,\n    track_id_graph: dict[int, int] | None = None,\n    radius: ArrayLike = 1,\n    image_shape: tuple[int, ...] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    track_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    track_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    radius : ArrayLike\n        Integer or N-dimensional array of radii.\n    image_shape : tuple[int, ...] | None\n        Shape of the image if available masks are cropped to fit the image.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import load_array\n\n    graph = cls(**kwargs)\n    load_array(\n        positions=positions,\n        graph=graph,\n        track_ids=track_ids,\n        track_id_graph=track_id_graph,\n        radius=radius,\n        image_shape=image_shape,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--see-also","title":"See Also","text":"<p>load_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [load_ctc][tracksdata.io._ctc.load_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n    \"\"\"\n    from tracksdata.io._ctc import load_ctc\n\n    graph = cls(**kwargs)\n    load_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A graph with the nodes and edges from the other graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            graph.add_node_attr_key(col, node_attrs[col].first())\n\n    new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_other(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to create a new graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_other(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.in_degree","title":"in_degree  <code>abstractmethod</code>","text":"<pre><code>in_degree(node_ids: int) -&gt; int\n</code></pre><pre><code>in_degree(node_ids: list[int] | None = None) -&gt; list[int]\n</code></pre> <pre><code>in_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match","title":"match","text":"<pre><code>match(other: BaseGraph, matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID, match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE, matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attrs","title":"node_attrs  <code>abstractmethod</code>","text":"<pre><code>node_attrs(*, node_ids: Sequence[int] | None = None, attr_keys: Sequence[str] | str | None = None, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the nodes as a pandas DataFrame.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A polars DataFrame with the attributes of the nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef node_attrs(\n    self,\n    *,\n    node_ids: Sequence[int] | None = None,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the nodes as a pandas DataFrame.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the attributes for.\n        If None, all nodes are used.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n    unpack : bool\n        Whether to unpack array attributes into multiple scalar attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        A polars DataFrame with the attributes of the nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the attributes for. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributes into multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_ids","title":"node_ids  <code>abstractmethod</code>","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all nodes in the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all nodes in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.out_degree","title":"out_degree  <code>abstractmethod</code>","text":"<pre><code>out_degree(node_ids: int) -&gt; int\n</code></pre><pre><code>out_degree(node_ids: list[int] | None = None) -&gt; list[int]\n</code></pre> <pre><code>out_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(node_ids: list[int] | None = None) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>. If <code>node_ids</code> is None, all nodes are used.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps between the nodes in <code>node_ids</code>.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    If `node_ids` is None, all nodes are used.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the overlaps for.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps between the nodes in `node_ids`.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the overlaps for. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.predecessors","title":"predecessors  <code>abstractmethod</code>","text":"<pre><code>predecessors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>The predecessors of the nodes indexed by node ID if a list of nodes is provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the predecessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        The predecessors of the nodes indexed by node ID if a list of nodes is provided.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.subgraph","title":"subgraph  <code>abstractmethod</code>","text":"<pre><code>subgraph(*attr_filters: AttrComparison, node_ids: Sequence[int] | None = None, node_attr_keys: Sequence[str] | str | None = None, edge_attr_keys: Sequence[str] | str | None = None) -&gt; GraphView\n</code></pre> <p>Create a subgraph from the graph from the given node IDs or attributes' filters.</p> <p>Node IDs or a single attribute filter can be used to create a subgraph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphView</code>           \u2013            <p>A view of the graph with the specified nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef subgraph(\n    self,\n    *attr_filters: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n    node_attr_keys: Sequence[str] | str | None = None,\n    edge_attr_keys: Sequence[str] | str | None = None,\n) -&gt; \"GraphView\":\n    \"\"\"\n    Create a subgraph from the graph from the given node IDs\n    or attributes' filters.\n\n    Node IDs or a single attribute filter can be used to create a subgraph.\n\n    Parameters\n    ----------\n    node_ids : Sequence[int]\n        The IDs of the nodes to include in the subgraph.\n    *attr_filters : AttrComparison\n        The attributes to filter the nodes by.\n    node_attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n    edge_attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    GraphView\n        A view of the graph with the specified nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.subgraph(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int]</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.subgraph(*attr_filters)","title":"<code>*attr_filters</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter the nodes by.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.subgraph(node_attr_keys)","title":"<code>node_attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.subgraph(edge_attr_keys)","title":"<code>edge_attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.successors","title":"successors  <code>abstractmethod</code>","text":"<pre><code>successors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the sucessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>The sucessors of the nodes indexed by node ID if a list of nodes is provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the sucessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the sucessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        The sucessors of the nodes indexed by node ID if a list of nodes is provided.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the sucessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.time_points","title":"time_points  <code>abstractmethod</code>","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_edge_attrs","title":"update_edge_attrs  <code>abstractmethod</code>","text":"<pre><code>update_edge_attrs(*, attrs: dict[str, Any], edge_ids: Sequence[int] | None = None) -&gt; None\n</code></pre> <p>Update the attributes of the edges.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef update_edge_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the edges.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        Attributes to be updated.\n    edge_ids : Sequence[int] | None\n        The IDs of the edges to update or None to update all edges.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_edge_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Attributes to be updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_edge_attrs(edge_ids)","title":"<code>edge_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the edges to update or None to update all edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_node_attrs","title":"update_node_attrs  <code>abstractmethod</code>","text":"<pre><code>update_node_attrs(*, attrs: dict[str, Any], node_ids: Sequence[int] | None = None) -&gt; None\n</code></pre> <p>Update the attributes of the nodes.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef update_node_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the nodes.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to update.\n    node_ids : Sequence[int] | None\n        The IDs of the nodes to update or None to update all nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_node_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to update.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_node_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to update or None to update all nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView","title":"GraphView","text":"<pre><code>GraphView(rx_graph: PyDiGraph, node_map_to_root: dict[int, int], root: BaseGraph, sync: bool = True)\n</code></pre> <p>               Bases: <code>RustWorkXGraph</code></p> <p>A filtered view of a graph that maintains bidirectional mapping to the root graph.</p> <p>GraphView provides a lightweight way to work with subsets of a larger graph while maintaining the ability to synchronize changes back to the original graph. It acts as a view layer that maps between local node/edge IDs and the root graph's IDs, enabling efficient subgraph operations with minimal data duplication.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>_node_map_to_root</code>               (<code>dict[int, int]</code>)           \u2013            <p>Mapping from view node IDs to root graph node IDs.</p> </li> <li> <code>_node_map_from_root</code>               (<code>dict[int, int]</code>)           \u2013            <p>Mapping from root graph node IDs to view node IDs.</p> </li> <li> <code>_edge_map_to_root</code>               (<code>dict[int, int]</code>)           \u2013            <p>Mapping from view edge IDs to root graph edge IDs.</p> </li> <li> <code>_edge_map_from_root</code>               (<code>dict[int, int]</code>)           \u2013            <p>Mapping from root graph edge IDs to view edge IDs.</p> </li> </ul> See Also <p>RustWorkXGraph:     The base graph implementation that this view extends.</p> <p>SQLGraph:     Database-backed graph implementation for larger datasets.</p> <p>Examples:</p> <p>Create a subgraph view filtered by time:</p> <pre><code>from tracksdata.attrs import NodeAttr\n\nview = graph.subgraph(NodeAttr(\"t\") == 5)\n</code></pre> <p>Access nodes in the view:</p> <pre><code>node_ids = view.node_ids()\nnode_attrs = view.node_attrs(node_ids=node_ids)\n</code></pre> <p>The view automatically maps between local and root IDs when needed.</p> <p>Methods:</p> <ul> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>assign_track_ids</code>             \u2013              <p>Compute and assign track ids to nodes.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>contract_nodes</code>             \u2013              <p>Contract the graph to only include the given <code>permanent_node_ids</code>.</p> </li> <li> <code>detach</code>             \u2013              <p>Detach the graph view from the root graph, returning a new graph with the same nodes and edges</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def __init__(\n    self,\n    rx_graph: rx.PyDiGraph,\n    node_map_to_root: dict[int, int],\n    root: BaseGraph,\n    sync: bool = True,\n) -&gt; None:\n    super().__init__(rx_graph=rx_graph)\n\n    # setting up the time_to_nodes mapping\n    for idx in rx_graph.node_indices():\n        t = self.rx_graph[idx][DEFAULT_ATTR_KEYS.T]\n        if t not in self._time_to_nodes:\n            self._time_to_nodes[t] = []\n        self._time_to_nodes[t].append(idx)\n\n    self._node_map_to_root = node_map_to_root.copy()\n    self._node_map_from_root = {v: k for k, v in node_map_to_root.items()}\n\n    self._edge_map_to_root: dict[int, int] = {\n        idx: data[DEFAULT_ATTR_KEYS.EDGE_ID] for idx, (_, _, data) in self.rx_graph.edge_index_map().items()\n    }\n    self._edge_map_from_root: dict[int, int] = {v: k for k, v in self._edge_map_to_root.items()}\n\n    self._root = root\n    self._is_root_rx_graph = isinstance(root, RustWorkXGraph)\n    self._sync = sync\n    self._out_of_sync = False\n\n    # making sure these are not used\n    # they should be accessed through the root graph\n    self._node_attr_keys = None\n    self._edge_attr_keys = None\n\n    # use parent graph overlaps\n    self._overlaps = None\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(rx_graph)","title":"<code>rx_graph</code>","text":"(<code>PyDiGraph</code>)           \u2013            <p>The rustworkx graph object representing the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(node_map_to_root)","title":"<code>node_map_to_root</code>","text":"(<code>dict[int, int]</code>)           \u2013            <p>Mapping from local node IDs to root graph node IDs.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(root)","title":"<code>root</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>Reference to the root graph that this view is derived from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(sync)","title":"<code>sync</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to automatically synchronize changes in the view. By default only the root graph is updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.num_edges","title":"num_edges  <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._replace_parent_graph_with_root","title":"_replace_parent_graph_with_root","text":"<pre><code>_replace_parent_graph_with_root() -&gt; None\n</code></pre> <p>Replace the parent graph with it's own parent graph (the root graph) This is internally called so every view of a graph maps to a single root, skipping intermediate views.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def _replace_parent_graph_with_root(self) -&gt; None:\n    \"\"\"\n    Replace the parent graph with it's own parent graph (the root graph)\n    This is internally called so every view of a graph maps to a single root, skipping intermediate views.\n    \"\"\"\n    parent = self._root\n\n    if not isinstance(parent, GraphView):\n        raise ValueError(\n            f\"Parent graph must be a GraphView to have its parent replaced with the root graph. Got {type(parent)}.\"\n        )\n\n    self._root = parent._root\n    self._node_map_to_root = {k: parent._node_map_to_root[v] for k, v in self._node_map_to_root.items()}\n    self._node_map_from_root = {v: k for k, v in self._node_map_to_root.items()}\n\n    self._edge_map_to_root = {k: parent._edge_map_to_root[v] for k, v in self._edge_map_to_root.items()}\n    self._edge_map_from_root = {v: k for k, v in self._edge_map_to_root.items()}\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(attrs: dict[str, Any], reference_keys: list[str], mode: str) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys():\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.add_overlap--parameters","title":"Parameters","text":"<p>source_id : int     The ID of the source node. target_id : int     The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.add_overlap--returns","title":"Returns","text":"<p>int     The ID of the added overlap.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    return self._root.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.assign_track_ids","title":"assign_track_ids","text":"<pre><code>assign_track_ids(output_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, reset: bool = True) -&gt; rx.PyDiGraph\n</code></pre> <p>Compute and assign track ids to nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed graph (parent -&gt; child) with track ids lineage relationships.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def assign_track_ids(\n    self,\n    output_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    reset: bool = True,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Compute and assign track ids to nodes.\n\n    Parameters\n    ----------\n    output_key : str\n        The key of the output track id attribute.\n    reset : bool\n        Whether to reset all track ids before assigning new ones.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed graph (parent -&gt; child) with track ids lineage relationships.\n    \"\"\"\n    try:\n        node_ids, track_ids, tracks_graph = _assign_track_ids(self.rx_graph)\n    except RuntimeError as e:\n        raise RuntimeError(\n            \"Are you sure this graph is a valid lineage graph?\\n\"\n            \"This function expects a solved graph.\\n\"\n            \"Often used from `graph.subgraph(edge_attr_filter={'solution': True})`\"\n        ) from e\n\n    node_ids = map_ids(self._node_map_to_root, node_ids)\n\n    if output_key not in self.node_attr_keys:\n        self.add_node_attr_key(output_key, -1)\n    elif reset:\n        self.update_node_attrs(attrs={output_key: -1})\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={output_key: track_ids},\n    )\n\n    return tracks_graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.assign_track_ids(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the output track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.assign_track_ids(reset)","title":"<code>reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset all track ids before assigning new ones.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.GraphView.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    self._root.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_ids = self.filter_nodes_by_attrs(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n        masks = self.node_attrs(node_ids=node_ids, attr_keys=[DEFAULT_ATTR_KEYS.MASK])[DEFAULT_ATTR_KEYS.MASK]\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.contract_nodes","title":"contract_nodes","text":"<pre><code>contract_nodes(permanent_node_ids: Sequence[int]) -&gt; GraphView\n</code></pre> <p>Contract the graph to only include the given <code>permanent_node_ids</code>. Predecessor and sucessors of removed nodes are connected during contraction.</p> <p>Example:</p> <pre><code>graph TD\n    A((t=0)) --&gt; B((t=1))\n    A --&gt; C((t=1))\n    B --&gt; D((t=2))\n    C --&gt; E((t=2))\n    C --&gt; F((t=2))</code></pre> <p>After contraction only keeping nodes in <code>t=0</code> and <code>t=2</code>: <pre><code>graph TD\n    A((t=0)) --&gt; B((t=2))\n    A --&gt; C((t=2))\n    A --&gt; D((t=2))</code></pre></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphView</code>           \u2013            <p>A view of the contracted graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def contract_nodes(\n    self,\n    permanent_node_ids: Sequence[int],\n) -&gt; \"GraphView\":\n    \"\"\"\n    Contract the graph to only include the given `permanent_node_ids`.\n    Predecessor and sucessors of removed nodes are connected during contraction.\n\n    Example:\n\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=1))\n        A --&gt; C((t=1))\n        B --&gt; D((t=2))\n        C --&gt; E((t=2))\n        C --&gt; F((t=2))\n    ```\n\n    After contraction only keeping nodes in `t=0` and `t=2`:\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=2))\n        A --&gt; C((t=2))\n        A --&gt; D((t=2))\n    ```\n\n    Parameters\n    ----------\n    permanent_node_ids : Sequence[int]\n        The node ids to keep in the contracted graph.\n\n    Returns\n    -------\n    GraphView\n        A view of the contracted graph.\n    \"\"\"\n    subgraph = super().contract_nodes(\n        permanent_node_ids=map_ids(self._node_map_from_root, permanent_node_ids),\n    )\n    subgraph._replace_parent_graph_with_root()\n\n    return subgraph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.contract_nodes(permanent_node_ids)","title":"<code>permanent_node_ids</code>","text":"(<code>Sequence[int]</code>)           \u2013            <p>The node ids to keep in the contracted graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.detach","title":"detach","text":"<pre><code>detach() -&gt; RustWorkXGraph\n</code></pre> <p>Detach the graph view from the root graph, returning a new graph with the same nodes and edges without the view's mapping and indenpendent ids.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def detach(self) -&gt; RustWorkXGraph:\n    \"\"\"\n    Detach the graph view from the root graph, returning a new graph with the same nodes and edges\n    without the view's mapping and indenpendent ids.\n    \"\"\"\n    return RustWorkXGraph.from_other(self)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(positions: ArrayLike, track_ids: ArrayLike | None = None, track_id_graph: dict[int, int] | None = None, radius: ArrayLike = 1, image_shape: tuple[int, ...] | None = None, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. track_ids : np.ndarray | None     Track ids of the nodes if available. track_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. radius : ArrayLike     Integer or N-dimensional array of radii. image_shape : tuple[int, ...] | None     Shape of the image if available masks are cropped to fit the image. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    track_ids: ArrayLike | None = None,\n    track_id_graph: dict[int, int] | None = None,\n    radius: ArrayLike = 1,\n    image_shape: tuple[int, ...] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    track_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    track_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    radius : ArrayLike\n        Integer or N-dimensional array of radii.\n    image_shape : tuple[int, ...] | None\n        Shape of the image if available masks are cropped to fit the image.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import load_array\n\n    graph = cls(**kwargs)\n    load_array(\n        positions=positions,\n        graph=graph,\n        track_ids=track_ids,\n        track_id_graph=track_id_graph,\n        radius=radius,\n        image_shape=image_shape,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--see-also","title":"See Also","text":"<p>load_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [load_ctc][tracksdata.io._ctc.load_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n    \"\"\"\n    from tracksdata.io._ctc import load_ctc\n\n    graph = cls(**kwargs)\n    load_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A graph with the nodes and edges from the other graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            graph.add_node_attr_key(col, node_attrs[col].first())\n\n    new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_other(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to create a new graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_other(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return len(self.overlaps()) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.in_degree","title":"in_degree","text":"<pre><code>in_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.in_degree(self._node_map_from_root[node_ids])\n    return [rx_graph.in_degree(self._node_map_from_root[node_id]) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match","title":"match","text":"<pre><code>match(other: BaseGraph, matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID, match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE, matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.out_degree","title":"out_degree","text":"<pre><code>out_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.out_degree(self._node_map_from_root[node_ids])\n    return [rx_graph.out_degree(self._node_map_from_root[node_id]) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.overlaps","title":"overlaps","text":"<pre><code>overlaps(node_ids: list[int] | None = None) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>. If <code>node_ids</code> is None, all nodes are used.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps between the nodes in <code>node_ids</code>.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    If `node_ids` is None, all nodes are used.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the overlaps for.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps between the nodes in `node_ids`.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    return self._root.overlaps(node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the overlaps for. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.time_points","title":"time_points","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n    return list(self._time_to_nodes.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph","title":"RustWorkXGraph","text":"<pre><code>RustWorkXGraph(rx_graph: PyDiGraph | None = None)\n</code></pre> <p>               Bases: <code>BaseGraph</code></p> <p>High-performance in-memory graph implementation using rustworkx.</p> <p>RustWorkXGraph provides a fast, memory-efficient graph backend built on rustworkx (a Rust-based graph library). It stores nodes and edges in memory with their attributes, making it suitable for moderate-sized graphs that fit in RAM. This implementation offers excellent performance for graph algorithms and is the recommended choice for most tracking applications.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--parameters","title":"Parameters","text":"<p>rx_graph : rx.PyDiGraph | None, optional     An existing rustworkx directed graph to wrap. If None, creates a new     empty graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--attributes","title":"Attributes","text":"<p>rx_graph : rx.PyDiGraph     The underlying rustworkx directed graph object. _time_to_nodes : dict[int, list[int]]     Mapping from time points to lists of node IDs at that time. _node_attr_keys : list[str]     List of available node attribute keys. _edge_attr_keys : list[str]     List of available edge attribute keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--see-also","title":"See Also","text":"<p>SQLGraph:     Database-backed graph implementation for larger datasets.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--examples","title":"Examples","text":"<p>Create an empty graph:</p> <pre><code>from tracksdata.graph import RustWorkXGraph\n\ngraph = RustWorkXGraph()\n</code></pre> <p>Add nodes and edges:</p> <pre><code>node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\nedge_id = graph.add_edge(source_id, target_id, {\"weight\": 0.8})\n</code></pre> <p>Filter nodes by attributes:</p> <pre><code>from tracksdata.attrs import NodeAttr\n\nnode_ids = graph.filter_nodes_by_attrs(NodeAttr(\"t\") == 0)\n</code></pre> <p>Create subgraphs:</p> <pre><code>subgraph = graph.subgraph(NodeAttr(\"t\") == 0)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edge_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph at time t.</p> </li> <li> <code>add_node_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>assign_track_ids</code>             \u2013              <p>Compute and assign track ids to nodes.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>contract_nodes</code>             \u2013              <p>Contract the graph to only include the given <code>permanent_node_ids</code>.</p> </li> <li> <code>edge_attrs</code>             \u2013              <p>Get the attributes of the edges as a polars DataFrame.</p> </li> <li> <code>edge_ids</code>             \u2013              <p>Get the IDs of all edges in the graph.</p> </li> <li> <code>filter_nodes_by_attrs</code>             \u2013              <p>Filter nodes by attributes.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_attrs</code>             \u2013              <p>Get the attributes of the nodes as a polars DataFrame.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the IDs of all nodes in the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessors of a list of nodes.</p> </li> <li> <code>subgraph</code>             \u2013              <p>Create a subgraph from the graph from the given node IDs</p> </li> <li> <code>successors</code>             \u2013              <p>Get the sucessors of a list of nodes.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> <li> <code>update_edge_attrs</code>             \u2013              <p>Update the attributes of the edges.</p> </li> <li> <code>update_node_attrs</code>             \u2013              <p>Update the attributes of the nodes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the edges.</p> </li> <li> <code>node_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the nodes.</p> </li> <li> <code>num_edges</code>               (<code>int</code>)           \u2013            <p>The number of edges in the graph.</p> </li> <li> <code>num_nodes</code>               (<code>int</code>)           \u2013            <p>The number of nodes in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def __init__(self, rx_graph: rx.PyDiGraph | None = None) -&gt; None:\n    super().__init__()\n\n    if rx_graph is None:\n        self._graph = rx.PyDiGraph()\n    else:\n        self._graph = rx_graph\n\n    self._time_to_nodes: dict[int, list[int]] = {}\n    self._node_attr_keys: list[str] = [DEFAULT_ATTR_KEYS.T]\n    self._edge_attr_keys: list[str] = []\n    self._overlaps: list[list[int, 2]] = []\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attr_keys","title":"edge_attr_keys  <code>property</code>","text":"<pre><code>edge_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_attr_keys","title":"node_attr_keys  <code>property</code>","text":"<pre><code>node_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.num_edges","title":"num_edges  <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._get_neighbors","title":"_get_neighbors","text":"<pre><code>_get_neighbors(neighbors_func: Callable[[PyDiGraph, int], NodeIndices], node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessors or sucessors of a list of nodes. See more information below.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _get_neighbors(\n    self,\n    neighbors_func: Callable[[rx.PyDiGraph, int], rx.NodeIndices],\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessors or sucessors of a list of nodes.\n    See more information below.\n    \"\"\"\n    single_node = False\n    if isinstance(node_ids, int):\n        node_ids = [node_ids]\n        single_node = True\n\n    if isinstance(attr_keys, str):\n        attr_keys = [attr_keys]\n\n    rx_graph = self.rx_graph\n    valid_schema = None\n\n    neighbors = {}\n    for node_id in node_ids:\n        neighbors_indices = neighbors_func(rx_graph, node_id)\n        neighbors_data: list[dict[str, Any]] = [rx_graph[i] for i in neighbors_indices]\n\n        if attr_keys is not None:\n            neighbors_data = [\n                {k: edge_data[k] for k in attr_keys if k != DEFAULT_ATTR_KEYS.NODE_ID}\n                for edge_data in neighbors_data\n            ]\n\n        if len(neighbors_data) &gt; 0:\n            df = pl.DataFrame(neighbors_data)\n            if attr_keys is None or DEFAULT_ATTR_KEYS.NODE_ID in attr_keys:\n                df = df.with_columns(\n                    pl.Series(DEFAULT_ATTR_KEYS.NODE_ID, np.asarray(neighbors_indices, dtype=int)),\n                )\n            neighbors[node_id] = df\n            valid_schema = neighbors[node_id].schema\n\n    if single_node:\n        try:\n            # could not find sucessors for this node\n            return neighbors[node_ids[0]]\n        except KeyError:\n            return pl.DataFrame()\n\n    for node_id in node_ids:\n        if node_id not in neighbors:\n            if valid_schema is None:\n                neighbors[node_id] = pl.DataFrame()\n            else:\n                neighbors[node_id] = pl.DataFrame(schema=valid_schema)\n\n    return neighbors\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(attrs: dict[str, Any], reference_keys: list[str], mode: str) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys():\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(source_id: int, target_id: int, attrs: dict[str, Any], validate_keys: bool = True) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n    attrs : dict[str, Any]\n        The attributes of the edge to be added.\n        The keys of the attributes will be used as the attributes of the edge.\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n    \"\"\"\n    if validate_keys:\n        self._validate_attributes(attrs, self.edge_attr_keys, \"edge\")\n    edge_id = self.rx_graph.add_edge(source_id, target_id, attrs)\n    attrs[DEFAULT_ATTR_KEYS.EDGE_ID] = edge_id\n    return edge_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the edge to be added. The keys of the attributes will be used as the attributes of the edge.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge_attr_key","title":"add_edge_attr_key","text":"<pre><code>add_edge_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing edges will have the default value for the new attribute key.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_edge_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing edges will have the default value for the new attribute key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the new attribute.\n    default_value : Any\n        The default value for existing edges for the new attribute key.\n    \"\"\"\n    if key in self.edge_attr_keys:\n        raise ValueError(f\"Attribute key {key} already exists\")\n\n    self._edge_attr_keys.append(key)\n    for _, _, edge_attr in self.rx_graph.weighted_edge_list():\n        edge_attr[key] = default_value\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge_attr_key(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the new attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge_attr_key(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>)           \u2013            <p>The default value for existing edges for the new attribute key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node","title":"add_node","text":"<pre><code>add_node(attrs: dict[str, Any], validate_keys: bool = True) -&gt; int\n</code></pre> <p>Add a node to the graph at time t.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph at time t.\n\n    Parameters\n    ----------\n    attrs : Any\n        The attributes of the node to be added, must have a \"t\" key.\n        The keys of the attributes will be used as the attributes of the node.\n        For example:\n        ```python\n        graph.add_node(dict(t=0, label=\"A\", intensity=100))\n        ```\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n    \"\"\"\n    # avoiding copying attributes on purpose, it could be a problem in the future\n    if validate_keys:\n        self._validate_attributes(attrs, self.node_attr_keys, \"node\")\n\n        if \"t\" not in attrs:\n            raise ValueError(f\"Node attributes must have a 't' key. Got {attrs.keys()}\")\n\n    node_id = self.rx_graph.add_node(attrs)\n    self._time_to_nodes.setdefault(attrs[\"t\"], []).append(node_id)\n    return node_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>Any</code>)           \u2013            <p>The attributes of the node to be added, must have a \"t\" key. The keys of the attributes will be used as the attributes of the node. For example: <pre><code>graph.add_node(dict(t=0, label=\"A\", intensity=100))\n</code></pre></p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node_attr_key","title":"add_node_attr_key","text":"<pre><code>add_node_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing nodes will have the default value for the new attribute key.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_node_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing nodes will have the default value for the new attribute key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the new attribute.\n    default_value : Any\n        The default value for existing nodes for the new attribute key.\n    \"\"\"\n    if key in self.node_attr_keys:\n        raise ValueError(f\"Attribute key {key} already exists\")\n\n    self._node_attr_keys.append(key)\n    rx_graph = self.rx_graph\n    for node_id in rx_graph.node_indices():\n        rx_graph[node_id][key] = default_value\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node_attr_key(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the new attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node_attr_key(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>)           \u2013            <p>The default value for existing nodes for the new attribute key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the added overlap.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    self._overlaps.append([source_id, target_id])\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_overlap(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_overlap(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.assign_track_ids","title":"assign_track_ids","text":"<pre><code>assign_track_ids(output_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, reset: bool = True) -&gt; rx.PyDiGraph\n</code></pre> <p>Compute and assign track ids to nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed graph (parent -&gt; child) with track ids lineage relationships.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def assign_track_ids(\n    self,\n    output_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    reset: bool = True,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Compute and assign track ids to nodes.\n\n    Parameters\n    ----------\n    output_key : str\n        The key of the output track id attribute.\n    reset : bool\n        Whether to reset the track ids of the graph. If True, the track ids will be reset to -1.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed graph (parent -&gt; child) with track ids lineage relationships.\n    \"\"\"\n    try:\n        node_ids, track_ids, tracks_graph = _assign_track_ids(self.rx_graph)\n    except RuntimeError as e:\n        raise RuntimeError(\n            \"Are you sure this graph is a valid lineage graph?\\n\"\n            \"This function expects a solved graph.\\n\"\n            \"Often used from `graph.subgraph(edge_attr_filter={'solution': True})`\"\n        ) from e\n\n    if output_key not in self.node_attr_keys:\n        self.add_node_attr_key(output_key, -1)\n    elif reset:\n        self.update_node_attrs(node_ids=self.node_ids(), attrs={output_key: -1})\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={output_key: track_ids},\n    )\n\n    return tracks_graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.assign_track_ids(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>The key of the output track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.assign_track_ids(reset)","title":"<code>reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset the track ids of the graph. If True, the track ids will be reset to -1.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None\n</code></pre> <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int] | None</code>           \u2013            <p>The IDs of the added edges.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def bulk_add_edges(self, edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None:\n    \"\"\"\n    Faster method to add multiple edges to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        The data of the edges to be added.\n        The keys of the data will be used as the attributes of the edges.\n        Must have \"source_id\" and \"target_id\" keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Returns\n    -------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    # saving for historical reasons, iterating over edges is faster than using rx.add_edges_from\n    # edges_data = [(d.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE), d.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET), d) for d in edges]\n    # indices = self.rx_graph.add_edges_from(edges_data)\n    # for i, d in zip(indices, edges, strict=True):\n    #     d[DEFAULT_ATTR_KEYS.EDGE_ID] = i\n    # return indices\n    return super().bulk_add_edges(edges, return_ids=return_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the edges to be added. The keys of the data will be used as the attributes of the edges. Must have \"source_id\" and \"target_id\" keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(nodes: list[dict[str, Any]]) -&gt; list[int]\n</code></pre> <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the added nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def bulk_add_nodes(self, nodes: list[dict[str, Any]]) -&gt; list[int]:\n    \"\"\"\n    Faster method to add multiple nodes to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        The data of the nodes to be added.\n        The keys of the data will be used as the attributes of the nodes.\n        Must have \"t\" key.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the added nodes.\n    \"\"\"\n    indices = list(self.rx_graph.add_nodes_from(nodes))\n    for node, index in zip(nodes, indices, strict=True):\n        self._time_to_nodes.setdefault(node[\"t\"], []).append(index)\n    return indices\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the nodes to be added. The keys of the data will be used as the attributes of the nodes. Must have \"t\" key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.BaseGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    for source_id, target_id in overlaps:\n        self.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_ids = self.filter_nodes_by_attrs(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n        masks = self.node_attrs(node_ids=node_ids, attr_keys=[DEFAULT_ATTR_KEYS.MASK])[DEFAULT_ATTR_KEYS.MASK]\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.contract_nodes","title":"contract_nodes","text":"<pre><code>contract_nodes(permanent_node_ids: Sequence[int]) -&gt; GraphView\n</code></pre> <p>Contract the graph to only include the given <code>permanent_node_ids</code>. Predecessor and sucessors of removed nodes are connected during contraction.</p> <p>Example:</p> <pre><code>graph TD\n    A((t=0)) --&gt; B((t=1))\n    A --&gt; C((t=1))\n    B --&gt; D((t=2))\n    C --&gt; E((t=2))\n    C --&gt; F((t=2))</code></pre> <p>After contraction only keeping nodes in <code>t=0</code> and <code>t=2</code>: <pre><code>graph TD\n    A((t=0)) --&gt; B((t=2))\n    A --&gt; C((t=2))\n    A --&gt; D((t=2))</code></pre></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphView</code>           \u2013            <p>A view of the contracted graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def contract_nodes(\n    self,\n    permanent_node_ids: Sequence[int],\n) -&gt; \"GraphView\":\n    \"\"\"\n    Contract the graph to only include the given `permanent_node_ids`.\n    Predecessor and sucessors of removed nodes are connected during contraction.\n\n    Example:\n\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=1))\n        A --&gt; C((t=1))\n        B --&gt; D((t=2))\n        C --&gt; E((t=2))\n        C --&gt; F((t=2))\n    ```\n\n    After contraction only keeping nodes in `t=0` and `t=2`:\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=2))\n        A --&gt; C((t=2))\n        A --&gt; D((t=2))\n    ```\n\n    Parameters\n    ----------\n    permanent_node_ids : Sequence[int]\n        The node ids to keep in the contracted graph.\n\n    Returns\n    -------\n    GraphView\n        A view of the contracted graph.\n    \"\"\"\n    from tracksdata.graph._graph_view import GraphView\n\n    all_node_ids = np.asarray(self.node_ids())\n    selected_nodes_mask = np.isin(all_node_ids, permanent_node_ids)\n    missing_node_ids = all_node_ids[~selected_nodes_mask]\n\n    # must block multigraphs to avoid edge duplication\n    rx_graph = rx.PyDiGraph(multigraph=False)\n    new_indices = rx_graph.add_nodes_from(self.rx_graph.nodes())\n    rx_graph.add_edges_from(self.rx_graph.weighted_edge_list())\n\n    for node_id in missing_node_ids:\n        rx_graph.remove_node_retain_edges(\n            node_id,\n            use_outgoing=True,\n            condition=lambda *args: True,\n        )\n\n    node_map_to_root = dict(\n        zip(\n            np.asarray(new_indices)[selected_nodes_mask].tolist(),\n            permanent_node_ids,\n            strict=True,\n        )\n    )\n\n    # I'm a bit concerned with the internal booking of indices of rustworkx\n    # so I'm adding this sanity check\n    assert len(node_map_to_root) == rx_graph.num_nodes()\n\n    graph_view = GraphView(rx_graph, node_map_to_root=node_map_to_root, root=self)\n\n    return graph_view\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.contract_nodes(permanent_node_ids)","title":"<code>permanent_node_ids</code>","text":"(<code>Sequence[int]</code>)           \u2013            <p>The node ids to keep in the contracted graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs","title":"edge_attrs","text":"<pre><code>edge_attrs(*, node_ids: list[int] | None = None, attr_keys: Sequence[str] | str | None = None, include_targets: bool = False, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the edges as a polars DataFrame.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_attrs(\n    self,\n    *,\n    node_ids: list[int] | None = None,\n    attr_keys: Sequence[str] | str | None = None,\n    include_targets: bool = False,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the edges as a polars DataFrame.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the subgraph to get the edge attributesfor.\n        If None, all edges of the graph are used.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n    include_targets : bool\n        Whether to include edges out-going from the given node_ids even\n        if the target node is not in the given node_ids.\n    unpack : bool\n        Whether to unpack array attributesinto multiple scalar attributes.\n    \"\"\"\n    if attr_keys is None:\n        attr_keys = self.edge_attr_keys\n\n    attr_keys = [DEFAULT_ATTR_KEYS.EDGE_ID, *attr_keys]\n    attr_keys = list(dict.fromkeys(attr_keys))\n\n    if node_ids is None:\n        rx_graph = self.rx_graph\n        node_map = None\n    else:\n        if include_targets:\n            selected_nodes = set(node_ids)\n            for node_id in node_ids:\n                neighbors = self.rx_graph.neighbors(node_id)\n                selected_nodes.update(neighbors)\n            node_ids = list(selected_nodes)\n\n        rx_graph, node_map = self.rx_graph.subgraph_with_nodemap(node_ids)\n\n    edge_map = rx_graph.edge_index_map()\n    if len(edge_map) == 0:\n        return pl.DataFrame(\n            {\n                key: []\n                for key in [\n                    *attr_keys,\n                    DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n                    DEFAULT_ATTR_KEYS.EDGE_TARGET,\n                ]\n            }\n        )\n\n    source, target, data = zip(*edge_map.values(), strict=False)\n\n    if node_map is not None:\n        source = [node_map[s] for s in source]\n        target = [node_map[t] for t in target]\n\n    columns = {key: [] for key in attr_keys}\n\n    for row in data:\n        for key in attr_keys:\n            columns[key].append(row[key])\n\n    columns[DEFAULT_ATTR_KEYS.EDGE_SOURCE] = source\n    columns[DEFAULT_ATTR_KEYS.EDGE_TARGET] = target\n\n    columns = {k: np.asarray(v) for k, v in columns.items()}\n\n    df = pl.DataFrame(columns)\n    if unpack:\n        df = unpack_array_attrs(df)\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the subgraph to get the edge attributesfor. If None, all edges of the graph are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs(include_targets)","title":"<code>include_targets</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include edges out-going from the given node_ids even if the target node is not in the given node_ids.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributesinto multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_ids","title":"edge_ids","text":"<pre><code>edge_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all edges in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all edges in the graph.\n    \"\"\"\n    return [int(i) for i in self.rx_graph.edge_indices()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.filter_nodes_by_attrs","title":"filter_nodes_by_attrs","text":"<pre><code>filter_nodes_by_attrs(*attrs: AttrComparison) -&gt; list[int]\n</code></pre> <p>Filter nodes by attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the filtered nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def filter_nodes_by_attrs(\n    self,\n    *attrs: AttrComparison,\n) -&gt; list[int]:\n    \"\"\"\n    Filter nodes by attributes.\n\n    Parameters\n    ----------\n    *attrs : AttrComparison\n        The attributes to filter by, for example:\n        ```python\n        graph.filter_nodes_by_attrs(Attr(\"t\") == 0, Attr(\"label\") == \"A\")\n        ```\n\n    Returns\n    -------\n    list[int]\n        The IDs of the filtered nodes.\n    \"\"\"\n    rx_graph = self.rx_graph\n    node_map = None\n    # entire graph\n    attrs, time = _pop_time_eq(attrs)\n\n    if time is not None:\n        selected_nodes = self._time_to_nodes.get(time, [])\n        if len(attrs) == 0:\n            return selected_nodes\n\n        # subgraph of selected nodes\n        rx_graph, node_map = rx_graph.subgraph_with_nodemap(selected_nodes)\n\n    _filter_func = _create_filter_func(attrs)\n\n    if node_map is None:\n        return list(rx_graph.filter_nodes(_filter_func))\n    else:\n        return [node_map[n] for n in rx_graph.filter_nodes(_filter_func)]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.filter_nodes_by_attrs(*attrs)","title":"<code>*attrs</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter by, for example: <pre><code>graph.filter_nodes_by_attrs(Attr(\"t\") == 0, Attr(\"label\") == \"A\")\n</code></pre></p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(positions: ArrayLike, track_ids: ArrayLike | None = None, track_id_graph: dict[int, int] | None = None, radius: ArrayLike = 1, image_shape: tuple[int, ...] | None = None, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. track_ids : np.ndarray | None     Track ids of the nodes if available. track_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. radius : ArrayLike     Integer or N-dimensional array of radii. image_shape : tuple[int, ...] | None     Shape of the image if available masks are cropped to fit the image. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    track_ids: ArrayLike | None = None,\n    track_id_graph: dict[int, int] | None = None,\n    radius: ArrayLike = 1,\n    image_shape: tuple[int, ...] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    track_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    track_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    radius : ArrayLike\n        Integer or N-dimensional array of radii.\n    image_shape : tuple[int, ...] | None\n        Shape of the image if available masks are cropped to fit the image.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import load_array\n\n    graph = cls(**kwargs)\n    load_array(\n        positions=positions,\n        graph=graph,\n        track_ids=track_ids,\n        track_id_graph=track_id_graph,\n        radius=radius,\n        image_shape=image_shape,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--see-also","title":"See Also","text":"<p>load_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [load_ctc][tracksdata.io._ctc.load_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n    \"\"\"\n    from tracksdata.io._ctc import load_ctc\n\n    graph = cls(**kwargs)\n    load_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A graph with the nodes and edges from the other graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            graph.add_node_attr_key(col, node_attrs[col].first())\n\n    new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_other(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to create a new graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_other(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return len(self.overlaps()) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.in_degree","title":"in_degree","text":"<pre><code>in_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.in_degree(node_ids)\n    return [rx_graph.in_degree(node_id) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match","title":"match","text":"<pre><code>match(other: BaseGraph, matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID, match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE, matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_attrs","title":"node_attrs","text":"<pre><code>node_attrs(*, node_ids: Sequence[int] | None = None, attr_keys: Sequence[str] | str | None = None, unpack: bool = False) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the nodes as a polars DataFrame.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A polars DataFrame with the attributes of the nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def node_attrs(\n    self,\n    *,\n    node_ids: Sequence[int] | None = None,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the nodes as a polars DataFrame.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the attributesfor.\n        If None, all nodes are used.\n    attr_keys : Sequence[str] | None\n        The attribute keys to get.\n        If None, all the attributes of the first node are used.\n    unpack : bool\n        Whether to unpack array attributesinto multiple scalar attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        A polars DataFrame with the attributes of the nodes.\n    \"\"\"\n    rx_graph = self.rx_graph\n    # If no node_ids provided, use all nodes\n    if node_ids is None:\n        node_ids = list(rx_graph.node_indices())\n\n    if attr_keys is None:\n        attr_keys = [DEFAULT_ATTR_KEYS.NODE_ID, *self.node_attr_keys]\n\n    if isinstance(attr_keys, str):\n        attr_keys = [attr_keys]\n\n    if len(node_ids) == 0:\n        return pl.DataFrame({key: [] for key in attr_keys})\n\n    # making them unique\n    attr_keys = list(dict.fromkeys(attr_keys))\n\n    # Create columns directly instead of building intermediate dictionaries\n    columns = {key: [] for key in attr_keys}\n\n    if DEFAULT_ATTR_KEYS.NODE_ID in attr_keys:\n        columns[DEFAULT_ATTR_KEYS.NODE_ID] = np.asarray(node_ids, dtype=int)\n        attr_keys.remove(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    # Build columns in a vectorized way\n    for node_id in node_ids:\n        node_data = rx_graph[node_id]\n        for key in attr_keys:\n            columns[key].append(node_data[key])\n\n    for key in attr_keys:\n        columns[key] = np.asarray(columns[key])\n\n    # Create DataFrame and set node_id as index in one shot\n    df = pl.DataFrame(columns)\n\n    if unpack:\n        df = unpack_array_attrs(df)\n\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the attributesfor. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all the attributes of the first node are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributesinto multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_ids","title":"node_ids","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all nodes in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all nodes in the graph.\n    \"\"\"\n    return [int(i) for i in self.rx_graph.node_indices()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.out_degree","title":"out_degree","text":"<pre><code>out_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.out_degree(node_ids)\n    return [rx_graph.out_degree(node_id) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(node_ids: list[int] | None = None) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>. If <code>node_ids</code> is None, all nodes are used.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps between the nodes in <code>node_ids</code>.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    If `node_ids` is None, all nodes are used.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the overlaps for.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps between the nodes in `node_ids`.\n    \"\"\"\n    if len(self._overlaps) == 0:\n        return []\n\n    if node_ids is None:\n        return self._overlaps\n\n    node_ids = np.asarray(node_ids, dtype=int)\n    overlaps_arr = np.asarray(self._overlaps, dtype=int)\n\n    is_in_source = np.isin(overlaps_arr[:, 0], node_ids)\n    is_in_target = np.isin(overlaps_arr[:, 1], node_ids)\n    return overlaps_arr[is_in_source &amp; is_in_target].tolist()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the overlaps for. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.predecessors","title":"predecessors","text":"<pre><code>predecessors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>The predecessors of the nodes indexed by node ID if a list of nodes is provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the predecessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        The predecessors of the nodes indexed by node ID if a list of nodes is provided.\n    \"\"\"\n    return self._get_neighbors(\n        rx.PyDiGraph.predecessor_indices,\n        node_ids,\n        attr_keys,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.subgraph","title":"subgraph","text":"<pre><code>subgraph(*attr_filters: AttrComparison, node_ids: Sequence[int] | None = None, node_attr_keys: Sequence[str] | str | None = None, edge_attr_keys: Sequence[str] | str | None = None) -&gt; GraphView\n</code></pre> <p>Create a subgraph from the graph from the given node IDs or attributes' filters.</p> <p>Node IDs or a single attribute filter can be used to create a subgraph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>RustWorkXGraph</code>           \u2013            <p>A new graph with the specified nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def subgraph(\n    self,\n    *attr_filters: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n    node_attr_keys: Sequence[str] | str | None = None,\n    edge_attr_keys: Sequence[str] | str | None = None,\n) -&gt; \"GraphView\":\n    \"\"\"\n    Create a subgraph from the graph from the given node IDs\n    or attributes' filters.\n\n    Node IDs or a single attribute filter can be used to create a subgraph.\n\n    Parameters\n    ----------\n    *attr_filters : AttrComparison\n        The attributes to filter the nodes and edges by.\n    node_ids : Sequence[int] | None\n        The IDs of the nodes to include in the subgraph.\n    node_attr_keys : Sequence[str] | str | None\n        The attribute keys to include in the subgraph.\n    edge_attr_keys : Sequence[str] | str | None\n        The attribute keys to include in the subgraph.\n\n    Returns\n    -------\n    RustWorkXGraph\n        A new graph with the specified nodes.\n    \"\"\"\n    from tracksdata.graph._graph_view import GraphView\n\n    node_attr_comps, edge_attr_comps = split_attr_comps(attr_filters)\n    self._validate_subgraph_args(node_ids, node_attr_comps, edge_attr_comps)\n\n    if node_attr_comps:\n        filtered_node_ids = self.filter_nodes_by_attrs(*node_attr_comps)\n        if node_ids is not None:\n            node_ids = np.intersect1d(node_ids, filtered_node_ids).tolist()\n        else:\n            node_ids = filtered_node_ids\n\n    if node_ids is None and edge_attr_comps:\n        edges_df = self.edge_attrs(node_ids=node_ids, attr_keys=attr_comps_to_strs(edge_attr_comps))\n        mask = polars_reduce_attr_comps(edges_df, edge_attr_comps, operator.and_)\n        node_ids = np.unique(\n            edges_df.filter(mask)\n            .select(\n                DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n                DEFAULT_ATTR_KEYS.EDGE_TARGET,\n            )\n            .to_numpy()\n        )\n\n    rx_graph, node_map = self.rx_graph.subgraph_with_nodemap(node_ids)\n\n    if edge_attr_comps:\n        LOG.info(\"Removing edges without attributes %s\", edge_attr_comps)\n        _filter_func = _create_filter_func(edge_attr_comps)\n        for source, target, edge_attr in rx_graph.weighted_edge_list():\n            if not _filter_func(edge_attr):\n                rx_graph.remove_edge(source, target)\n\n    graph_view = GraphView(\n        rx_graph=rx_graph,\n        node_map_to_root=dict(node_map.items()),\n        root=self,\n    )\n\n    return graph_view\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.subgraph(*attr_filters)","title":"<code>*attr_filters</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter the nodes and edges by.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.subgraph(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.subgraph(node_attr_keys)","title":"<code>node_attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.subgraph(edge_attr_keys)","title":"<code>edge_attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.successors","title":"successors","text":"<pre><code>successors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the sucessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>The sucessors of the nodes indexed by node ID if a list of nodes is provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the sucessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the sucessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        The sucessors of the nodes indexed by node ID if a list of nodes is provided.\n    \"\"\"\n    return self._get_neighbors(\n        rx.PyDiGraph.successor_indices,\n        node_ids,\n        attr_keys,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the sucessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.time_points","title":"time_points","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n    return list(self._time_to_nodes.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_edge_attrs","title":"update_edge_attrs","text":"<pre><code>update_edge_attrs(*, attrs: dict[str, Any], edge_ids: Sequence[int] | None = None) -&gt; None\n</code></pre> <p>Update the attributes of the edges.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def update_edge_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the edges.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        Attributes to be updated.\n    edge_ids : Sequence[int] | None\n        The IDs of the edges to update or None to update all edges.\n    \"\"\"\n    if edge_ids is None:\n        edge_ids = self.edge_ids()\n\n    size = len(edge_ids)\n    for key, value in attrs.items():\n        if key not in self.edge_attr_keys:\n            raise ValueError(f\"Edge attribute key '{key}' not found in graph. Expected '{self.edge_attr_keys}'\")\n\n        if np.isscalar(value):\n            attrs[key] = [value] * size\n\n        elif len(attrs[key]) != size:\n            raise ValueError(f\"Attribute '{key}' has wrong size. Expected {size}, got {len(attrs[key])}\")\n\n    edge_map = self._graph.edge_index_map()\n\n    for i, edge_id in enumerate(edge_ids):\n        edge_attr = edge_map[edge_id][2]  # 0=source, 1=target, 2=attributes\n        for key, value in attrs.items():\n            edge_attr[key] = value[i]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_edge_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Attributes to be updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_edge_attrs(edge_ids)","title":"<code>edge_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the edges to update or None to update all edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_node_attrs","title":"update_node_attrs","text":"<pre><code>update_node_attrs(*, attrs: dict[str, Any], node_ids: Sequence[int] | None = None) -&gt; None\n</code></pre> <p>Update the attributes of the nodes.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def update_node_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the nodes.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to update.\n    node_ids : Sequence[int] | None\n        The IDs of the nodes to update or None to update all nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n\n    for key, value in attrs.items():\n        if key not in self.node_attr_keys:\n            raise ValueError(f\"Node attribute key '{key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n        if not np.isscalar(value) and len(attrs[key]) != len(node_ids):\n            raise ValueError(f\"Attribute '{key}' has wrong size. Expected {len(node_ids)}, got {len(attrs[key])}\")\n\n    for key, value in attrs.items():\n        if np.isscalar(value):\n            value = [value] * len(node_ids)\n\n        for node_id, v in zip(node_ids, value, strict=False):\n            self._graph[node_id][key] = v\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_node_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to update.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_node_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to update or None to update all nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph","title":"SQLGraph","text":"<pre><code>SQLGraph(drivername: str, database: str, username: str | None = None, password: str | None = None, host: str | None = None, port: int | None = None, engine_kwargs: dict[str, Any] | None = None, overwrite: bool = False)\n</code></pre> <p>               Bases: <code>BaseGraph</code></p> <p>SQL-based graph implementation using SQLAlchemy ORM.</p> <p>Provides persistent storage and efficient querying of large graphs with support for dynamic schema modification and various database backends. Node IDs are automatically generated based on time to ensure uniqueness across time points.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--parameters","title":"Parameters","text":"<p>drivername : str     The database driver name (e.g., 'sqlite', 'postgresql', 'mysql'). database : str     The database name or path. For SQLite, this is the file path. username : str, optional     Database username. Not required for SQLite. password : str, optional     Database password. Not required for SQLite. host : str, optional     Database host. Not required for SQLite. port : int, optional     Database port. Not required for SQLite. overwrite : bool, default False     If True, drop and recreate all tables. Use with caution as this     will delete all existing data.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--attributes","title":"Attributes","text":"<p>node_id_time_multiplier : int     Multiplier used to generate node IDs based on time (default: 1,000,000,000). Base : type[DeclarativeBase]     SQLAlchemy declarative base class for this graph instance. Node : type[DeclarativeBase]     SQLAlchemy model class for nodes. Edge : type[DeclarativeBase]     SQLAlchemy model class for edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--see-also","title":"See Also","text":"<p>RustWorkXGraph:     In memory Rustworkx-based graph implementation.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--examples","title":"Examples","text":"<p>Create an in-memory SQLite graph:</p> <pre><code>graph = SQLGraph(\"sqlite\", \":memory:\")\n</code></pre> <p>Create a persistent SQLite graph:</p> <pre><code>graph = SQLGraph(\"sqlite\", \"my_graph.db\")\n</code></pre> <p>Create a PostgreSQL graph:</p> <pre><code>graph = SQLGraph(\"postgresql\", \"tracking_db\", username=\"user\", password=\"pass\", host=\"localhost\", port=5432)\n</code></pre> <p>Add nodes and edges:</p> <pre><code>node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\nedge_id = graph.add_edge(node_id, target_id, {\"weight\": 0.8})\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph at time t.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Add multiple edges to the graph efficiently.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Add multiple nodes to the graph efficiently.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>filter_nodes_by_attrs</code>             \u2013              <p>Filter nodes by their attribute values.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the IDs of all nodes in the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessor nodes of given nodes.</p> </li> <li> <code>successors</code>             \u2013              <p>Get the successor nodes of given nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def __init__(\n    self,\n    drivername: str,\n    database: str,\n    username: str | None = None,\n    password: str | None = None,\n    host: str | None = None,\n    port: int | None = None,\n    engine_kwargs: dict[str, Any] | None = None,\n    overwrite: bool = False,\n):\n    self._url = sa.engine.URL.create(\n        drivername,\n        username=username,\n        password=password,\n        host=host,\n        port=port,\n        database=database,\n    )\n    self._engine_kwargs = engine_kwargs if engine_kwargs is not None else {}\n    self._engine = sa.create_engine(self._url, **self._engine_kwargs)\n\n    # Create unique classes for this instance\n    self._define_schema(overwrite=overwrite)\n    self._boolean_columns: dict[str, list[str]] = {self.Node.__tablename__: [], self.Edge.__tablename__: []}\n\n    if overwrite:\n        self.Base.metadata.drop_all(self._engine)\n\n    self.Base.metadata.create_all(self._engine)\n\n    self._max_id_per_time = {}\n    self._update_max_id_per_time()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._cast_boolean_columns","title":"_cast_boolean_columns","text":"<pre><code>_cast_boolean_columns(table_class: type[DeclarativeBase], df: DataFrame) -&gt; pl.DataFrame\n</code></pre> <p>This is required because polars bypasses the boolean type and converts it to integer.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _cast_boolean_columns(self, table_class: type[DeclarativeBase], df: pl.DataFrame) -&gt; pl.DataFrame:\n    \"\"\"\n    This is required because polars bypasses the boolean type and converts it to integer.\n    \"\"\"\n    for col in self._boolean_columns[table_class.__tablename__]:\n        if col in df.columns:\n            df = df.with_columns(pl.col(col).cast(pl.Boolean))\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._define_schema","title":"_define_schema","text":"<pre><code>_define_schema(overwrite: bool) -&gt; None\n</code></pre> <p>Define the database schema classes for this SQLGraph instance.</p> <p>Creates unique SQLAlchemy model classes for this graph instance to avoid conflicts between multiple SQLGraph instances.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _define_schema(self, overwrite: bool) -&gt; None:\n    \"\"\"\n    Define the database schema classes for this SQLGraph instance.\n\n    Creates unique SQLAlchemy model classes for this graph instance to\n    avoid conflicts between multiple SQLGraph instances.\n    \"\"\"\n    metadata = sa.MetaData()\n    metadata.reflect(bind=self._engine)\n\n    class Base(DeclarativeBase):\n        pass\n\n    if len(metadata.tables) &gt; 0 and not overwrite:\n        for table_name, table in metadata.tables.items():\n            cls = type(\n                table_name,\n                (Base,),\n                {\n                    \"__table__\": table,\n                    \"__tablename__\": table_name,\n                },\n            )\n            setattr(self, table_name, cls)\n        self.Base = Base\n        return\n\n    class Node(Base):\n        __tablename__ = \"Node\"\n\n        # Use node_id as sole primary key for simpler updates\n        node_id = sa.Column(sa.BigInteger, primary_key=True, unique=True)\n\n        # Add t as a regular column\n        # NOTE might want to use as index for fast time-based queries\n        t = sa.Column(sa.Integer, nullable=False)\n\n    node_tb_name = Node.__tablename__\n\n    class Edge(Base):\n        __tablename__ = \"Edge\"\n        edge_id = sa.Column(sa.Integer, primary_key=True, unique=True, autoincrement=True)\n        source_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"))\n        target_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"))\n\n    class Overlap(Base):\n        __tablename__ = \"Overlap\"\n        overlap_id = sa.Column(sa.Integer, primary_key=True, unique=True, autoincrement=True)\n        source_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"))\n        target_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"))\n\n    # Assign to instance variables\n    self.Base = Base\n    self.Node = Node\n    self.Edge = Edge\n    self.Overlap = Overlap\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors","title":"_get_neighbors","text":"<pre><code>_get_neighbors(node_key: str, neighbor_key: str, node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessors or successors of nodes via database joins.</p> <p>Helper method used by sucessors() and predecessors() to efficiently query neighbor relationships through SQL joins.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>If multiple node_ids are provided, returns a dictionary mapping each node_id to a DataFrame of its neighbors. If a single node_id is provided, returns the DataFrame directly.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _get_neighbors(\n    self,\n    node_key: str,\n    neighbor_key: str,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessors or successors of nodes via database joins.\n\n    Helper method used by sucessors() and predecessors() to efficiently\n    query neighbor relationships through SQL joins.\n\n    Parameters\n    ----------\n    node_key : str\n        The edge attribute key for the query node (e.g., \"source_id\").\n    neighbor_key : str\n        The edge attribute key for the neighbor node (e.g., \"target_id\").\n    node_ids : list[int] | int\n        The IDs of the nodes to get neighbors for.\n    attr_keys : Sequence[str] | str | None, optional\n        The attribute keys to retrieve for neighbor nodes. If None,\n        all attributes are retrieved.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        If multiple node_ids are provided, returns a dictionary mapping\n        each node_id to a DataFrame of its neighbors. If a single node_id\n        is provided, returns the DataFrame directly.\n    \"\"\"\n    single_node = False\n    if isinstance(node_ids, int):\n        node_ids = [node_ids]\n        single_node = True\n\n    if isinstance(attr_keys, str):\n        attr_keys = [attr_keys]\n\n    with Session(self._engine) as session:\n        if attr_keys is None:\n            # all columns\n            node_columns = [self.Node]\n        else:\n            node_columns = [getattr(self.Node, key) for key in attr_keys]\n\n        query = session.query(getattr(self.Edge, node_key), *node_columns)\n        query = query.join(self.Edge, getattr(self.Edge, neighbor_key) == self.Node.node_id)\n        query = query.filter(getattr(self.Edge, node_key).in_(node_ids))\n\n        node_df = pl.read_database(\n            query.statement,\n            connection=session.connection(),\n        )\n        node_df = self._cast_boolean_columns(self.Node, node_df)\n\n    if single_node:\n        return node_df\n\n    neighbors_dict = {node_id: group for (node_id,), group in node_df.group_by(node_key)}\n    for node_id in node_ids:\n        if node_id not in neighbors_dict:\n            neighbors_dict[node_id] = pl.DataFrame(schema=node_df.schema)\n\n    return neighbors_dict\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(node_key)","title":"<code>node_key</code>","text":"(<code>str</code>)           \u2013            <p>The edge attribute key for the query node (e.g., \"source_id\").</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(neighbor_key)","title":"<code>neighbor_key</code>","text":"(<code>str</code>)           \u2013            <p>The edge attribute key for the neighbor node (e.g., \"target_id\").</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get neighbors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve for neighbor nodes. If None, all attributes are retrieved.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._update_max_id_per_time","title":"_update_max_id_per_time","text":"<pre><code>_update_max_id_per_time() -&gt; None\n</code></pre> <p>Update the maximum node ID for each time point.</p> <p>Scans the database to find the current maximum node ID for each time point and updates the internal cache to ensure newly created nodes have unique IDs.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _update_max_id_per_time(self) -&gt; None:\n    \"\"\"\n    Update the maximum node ID for each time point.\n\n    Scans the database to find the current maximum node ID for each time\n    point and updates the internal cache to ensure newly created nodes\n    have unique IDs.\n    \"\"\"\n    with Session(self._engine) as session:\n        for t in session.query(self.Node.t).distinct():\n            self._max_id_per_time[t] = int(session.query(sa.func.max(self.Node.node_id)).scalar())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(attrs: dict[str, Any], reference_keys: list[str], mode: str) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys():\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(source_id: int, target_id: int, attrs: dict[str, Any], validate_keys: bool = True) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the newly added edge.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If validate_keys is True and the attributes contain invalid keys.</p> </li> </ul> <p>Examples:</p> <pre><code>edge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.8})\nedge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.9, \"distance\": 5.2, \"confidence\": 0.95})\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n    attrs : dict[str, Any]\n        Additional attributes for the edge (e.g., weight, distance).\n    validate_keys : bool, default True\n        Whether to check if the attribute keys are valid against the\n        current schema. If False, validation is skipped for performance.\n\n    Returns\n    -------\n    int\n        The ID of the newly added edge.\n\n    Raises\n    ------\n    ValueError\n        If validate_keys is True and the attributes contain invalid keys.\n\n    Examples\n    --------\n    ```python\n    edge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.8})\n    edge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.9, \"distance\": 5.2, \"confidence\": 0.95})\n    ```\n    \"\"\"\n    if validate_keys:\n        self._validate_attributes(attrs, self.edge_attr_keys, \"edge\")\n\n    if hasattr(source_id, \"item\"):\n        source_id = source_id.item()\n\n    if hasattr(target_id, \"item\"):\n        target_id = target_id.item()\n\n    edge = self.Edge(\n        source_id=source_id,\n        target_id=target_id,\n        **attrs,\n    )\n\n    with Session(self._engine) as session:\n        session.add(edge)\n        session.commit()\n        edge_id = edge.edge_id\n\n    return edge_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Additional attributes for the edge (e.g., weight, distance).</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attribute keys are valid against the current schema. If False, validation is skipped for performance.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node","title":"add_node","text":"<pre><code>add_node(attrs: dict[str, Any], validate_keys: bool = True) -&gt; int\n</code></pre> <p>Add a node to the graph at time t.</p> <p>Node IDs are automatically generated based on the time point and the node_id_time_multiplier to ensure uniqueness across time points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the newly added node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If validate_keys is True and the attributes contain invalid keys, or if the \"t\" key is missing.</p> </li> </ul> <p>Examples:</p> <pre><code>node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\nnode_id = graph.add_node({\"t\": 1, \"x\": 15.2, \"y\": 25.8, \"intensity\": 150.0})\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph at time t.\n\n    Node IDs are automatically generated based on the time point and\n    the node_id_time_multiplier to ensure uniqueness across time points.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes of the node to be added. Must contain a \"t\" key\n        specifying the time point. Additional keys will be stored as\n        node attributes.\n    validate_keys : bool, default True\n        Whether to check if the attribute keys are valid against the\n        current schema. If False, validation is skipped for performance.\n\n    Returns\n    -------\n    int\n        The ID of the newly added node.\n\n    Raises\n    ------\n    ValueError\n        If validate_keys is True and the attributes contain invalid keys,\n        or if the \"t\" key is missing.\n\n    Examples\n    --------\n    ```python\n    node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\n    node_id = graph.add_node({\"t\": 1, \"x\": 15.2, \"y\": 25.8, \"intensity\": 150.0})\n    ```\n    \"\"\"\n    if validate_keys:\n        self._validate_attributes(attrs, self.node_attr_keys, \"node\")\n\n        if \"t\" not in attrs:\n            raise ValueError(f\"Node attributes must have a 't' key. Got {attrs.keys()}\")\n\n    time = attrs[\"t\"]\n    default_node_id = (time * self.node_id_time_multiplier) - 1\n    node_id = self._max_id_per_time.get(time, default_node_id) + 1\n\n    node = self.Node(\n        node_id=node_id,\n        **attrs,\n    )\n\n    with Session(self._engine) as session:\n        session.add(node)\n        session.commit()\n\n    self._max_id_per_time[time] = node_id\n\n    return node_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the node to be added. Must contain a \"t\" key specifying the time point. Additional keys will be stored as node attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attribute keys are valid against the current schema. If False, validation is skipped for performance.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_overlap--parameters","title":"Parameters","text":"<p>source_id : int     The ID of the source node. target_id : int     The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_overlap--returns","title":"Returns","text":"<p>int     The ID of the added overlap.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    overlap = self.Overlap(\n        source_id=source_id,\n        target_id=target_id,\n    )\n    with Session(self._engine) as session:\n        session.add(overlap)\n        session.commit()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None\n</code></pre> <p>Add multiple edges to the graph efficiently.</p> <p>Provides better performance than calling add_edge multiple times by using SQLAlchemy's bulk insert functionality.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> Return <p>list[int] | None     The IDs of the added edges.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def bulk_add_edges(\n    self,\n    edges: list[dict[str, Any]],\n    return_ids: bool = False,\n) -&gt; list[int] | None:\n    \"\"\"\n    Add multiple edges to the graph efficiently.\n\n    Provides better performance than calling add_edge multiple times by\n    using SQLAlchemy's bulk insert functionality.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        List of edge attribute dictionaries. Each dictionary must contain\n        \"source_id\" and \"target_id\" keys, plus any additional feature keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Return\n    ------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    if len(edges) == 0:\n        if return_ids:\n            return []\n        return None\n\n    for edge in edges:\n        _data_numpy_to_native(edge)\n\n    with Session(self._engine) as session:\n        if return_ids:\n            result = session.execute(sa.insert(self.Edge).returning(self.Edge.edge_id), edges)\n            session.commit()\n            return list(result.scalars().all())\n        else:\n            session.execute(sa.insert(self.Edge), edges)\n            session.commit()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>List of edge attribute dictionaries. Each dictionary must contain \"source_id\" and \"target_id\" keys, plus any additional feature keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(nodes: list[dict[str, Any]]) -&gt; None\n</code></pre> <p>Add multiple nodes to the graph efficiently.</p> <p>Provides better performance than calling add_node multiple times by using SQLAlchemy's bulk insert functionality and reducing database transactions. Automatically assigns node IDs and handles time-based ID generation.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>nodes = [\n    {\"t\": 0, \"x\": 10, \"y\": 20, \"label\": \"A\"},\n    {\"t\": 0, \"x\": 15, \"y\": 25, \"label\": \"B\"},\n]\ngraph.bulk_add_nodes(nodes)\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the added nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def bulk_add_nodes(\n    self,\n    nodes: list[dict[str, Any]],\n) -&gt; None:\n    \"\"\"\n    Add multiple nodes to the graph efficiently.\n\n    Provides better performance than calling add_node multiple times by\n    using SQLAlchemy's bulk insert functionality and reducing database\n    transactions. Automatically assigns node IDs and handles time-based\n    ID generation.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        List of node attribute dictionaries. Each dictionary must contain\n        a \"t\" key and any additional attribute keys.\n\n    Examples\n    --------\n    ```python\n    nodes = [\n        {\"t\": 0, \"x\": 10, \"y\": 20, \"label\": \"A\"},\n        {\"t\": 0, \"x\": 15, \"y\": 25, \"label\": \"B\"},\n    ]\n    graph.bulk_add_nodes(nodes)\n    ```\n\n    Returns\n    -------\n    list[int]\n        The IDs of the added nodes.\n    \"\"\"\n    if len(nodes) == 0:\n        return []\n\n    node_ids = []\n    for node in nodes:\n        time = node[\"t\"]\n        default_node_id = (time * self.node_id_time_multiplier) - 1\n        node_id = self._max_id_per_time.get(time, default_node_id) + 1\n        node[DEFAULT_ATTR_KEYS.NODE_ID] = node_id\n        node_ids.append(node_id)\n        self._max_id_per_time[time] = node_id\n\n    with Session(self._engine) as session:\n        session.execute(sa.insert(self.Node), nodes)\n        session.commit()\n\n    return node_ids\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>List of node attribute dictionaries. Each dictionary must contain a \"t\" key and any additional attribute keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.SQLGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    if hasattr(overlaps, \"tolist\"):\n        overlaps = overlaps.tolist()\n\n    overlaps = [{\"source_id\": source_id, \"target_id\": target_id} for source_id, target_id in overlaps]\n    with Session(self._engine) as session:\n        session.execute(sa.insert(self.Overlap), overlaps)\n        session.commit()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_ids = self.filter_nodes_by_attrs(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n        masks = self.node_attrs(node_ids=node_ids, attr_keys=[DEFAULT_ATTR_KEYS.MASK])[DEFAULT_ATTR_KEYS.MASK]\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.filter_nodes_by_attrs","title":"filter_nodes_by_attrs","text":"<pre><code>filter_nodes_by_attrs(*attrs: AttrComparison) -&gt; list[int]\n</code></pre> <p>Filter nodes by their attribute values.</p> <p>Performs an SQL query with WHERE clauses for each specified attribute, providing efficient filtering for large graphs.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of node IDs that match the filter criteria.</p> </li> </ul> <p>Examples:</p> <pre><code>node_ids = graph.filter_nodes_by_attribute({\"t\": 0})\nnode_ids = graph.filter_nodes_by_attribute({\"t\": 1, \"label\": \"A\"})\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def filter_nodes_by_attrs(\n    self,\n    *attrs: AttrComparison,\n) -&gt; list[int]:\n    \"\"\"\n    Filter nodes by their attribute values.\n\n    Performs an SQL query with WHERE clauses for each specified attribute,\n    providing efficient filtering for large graphs.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        Dictionary of attribute-value pairs to filter by. Only nodes\n        that match all specified attributes will be returned.\n\n    Returns\n    -------\n    list[int]\n        List of node IDs that match the filter criteria.\n\n    Examples\n    --------\n    ```python\n    node_ids = graph.filter_nodes_by_attribute({\"t\": 0})\n    node_ids = graph.filter_nodes_by_attribute({\"t\": 1, \"label\": \"A\"})\n    ```\n    \"\"\"\n    with Session(self._engine) as session:\n        query = session.query(self.Node.node_id)\n        query = _filter_query(query, self.Node, attrs)\n        return [i for (i,) in query.all()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.filter_nodes_by_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>, default:                   <code>()</code> )           \u2013            <p>Dictionary of attribute-value pairs to filter by. Only nodes that match all specified attributes will be returned.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(positions: ArrayLike, track_ids: ArrayLike | None = None, track_id_graph: dict[int, int] | None = None, radius: ArrayLike = 1, image_shape: tuple[int, ...] | None = None, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. track_ids : np.ndarray | None     Track ids of the nodes if available. track_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. radius : ArrayLike     Integer or N-dimensional array of radii. image_shape : tuple[int, ...] | None     Shape of the image if available masks are cropped to fit the image. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    track_ids: ArrayLike | None = None,\n    track_id_graph: dict[int, int] | None = None,\n    radius: ArrayLike = 1,\n    image_shape: tuple[int, ...] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    track_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    track_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    radius : ArrayLike\n        Integer or N-dimensional array of radii.\n    image_shape : tuple[int, ...] | None\n        Shape of the image if available masks are cropped to fit the image.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import load_array\n\n    graph = cls(**kwargs)\n    load_array(\n        positions=positions,\n        graph=graph,\n        track_ids=track_ids,\n        track_id_graph=track_id_graph,\n        radius=radius,\n        image_shape=image_shape,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--see-also","title":"See Also","text":"<p>load_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [load_ctc][tracksdata.io._ctc.load_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n    \"\"\"\n    from tracksdata.io._ctc import load_ctc\n\n    graph = cls(**kwargs)\n    load_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A graph with the nodes and edges from the other graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            graph.add_node_attr_key(col, node_attrs[col].first())\n\n    new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_other(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to create a new graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_other(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n    \"\"\"\n    with Session(self._engine) as session:\n        return session.query(self.Overlap).count() &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.in_degree","title":"in_degree","text":"<pre><code>in_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n    return self._get_degree(node_ids, DEFAULT_ATTR_KEYS.EDGE_TARGET)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match","title":"match","text":"<pre><code>match(other: BaseGraph, matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID, match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE, matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.node_ids","title":"node_ids","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all nodes in the graph.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all node IDs in the graph.</p> </li> </ul> <p>Examples:</p> <pre><code>all_nodes = graph.node_ids()\nprint(f\"Graph contains {len(all_nodes)} nodes\")\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all nodes in the graph.\n\n    Returns\n    -------\n    list[int]\n        List of all node IDs in the graph.\n\n    Examples\n    --------\n    ```python\n    all_nodes = graph.node_ids()\n    print(f\"Graph contains {len(all_nodes)} nodes\")\n    ```\n    \"\"\"\n    with Session(self._engine) as session:\n        return [i for (i,) in session.query(self.Node.node_id).all()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.out_degree","title":"out_degree","text":"<pre><code>out_degree(node_ids: list[int] | int | None = None) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n    return self._get_degree(node_ids, DEFAULT_ATTR_KEYS.EDGE_SOURCE)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(node_ids: list[int] | None = None) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    \"\"\"\n    if hasattr(node_ids, \"tolist\"):\n        node_ids = node_ids.tolist()\n\n    with Session(self._engine) as session:\n        query = session.query(self.Overlap.source_id, self.Overlap.target_id)\n\n        if node_ids is not None:\n            query = query.filter(\n                self.Overlap.source_id.in_(node_ids),\n                self.Overlap.target_id.in_(node_ids),\n            )\n\n        return [[source_id, target_id] for source_id, target_id in query.all()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.predecessors","title":"predecessors","text":"<pre><code>predecessors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the predecessor nodes of given nodes.</p> <p>Predecessors are nodes that are sources of edges targeting the given nodes (incoming edges). Uses efficient SQL joins to retrieve predecessor information with their attributes in a single query.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>If a list of node_ids is provided, returns a dictionary mapping each node_id to a DataFrame of its predecessors. If a single node_id is provided, returns the DataFrame directly.</p> </li> </ul> <p>Examples:</p> <pre><code>predecessors_df = graph.predecessors(node_id)\npredecessors_dict = graph.predecessors([node1, node2, node3])\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the predecessor nodes of given nodes.\n\n    Predecessors are nodes that are sources of edges targeting the\n    given nodes (incoming edges). Uses efficient SQL joins to retrieve\n    predecessor information with their attributes in a single query.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get predecessors for.\n    attr_keys : Sequence[str] | str | None, optional\n        The attribute keys to retrieve for predecessor nodes. If None,\n        all attributes are retrieved.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        If a list of node_ids is provided, returns a dictionary mapping\n        each node_id to a DataFrame of its predecessors. If a single node_id\n        is provided, returns the DataFrame directly.\n\n    Examples\n    --------\n    ```python\n    predecessors_df = graph.predecessors(node_id)\n    predecessors_dict = graph.predecessors([node1, node2, node3])\n    ```\n    \"\"\"\n    return self._get_neighbors(\n        node_key=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        neighbor_key=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n        node_ids=node_ids,\n        attr_keys=attr_keys,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve for predecessor nodes. If None, all attributes are retrieved.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.successors","title":"successors","text":"<pre><code>successors(node_ids: list[int] | int, attr_keys: Sequence[str] | str | None = None) -&gt; dict[int, pl.DataFrame] | pl.DataFrame\n</code></pre> <p>Get the successor nodes of given nodes.</p> <p>Successors are nodes that are targets of edges originating from the given nodes (outgoing edges). Uses efficient SQL joins to retrieve successor information with their attributes in a single query.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame</code>           \u2013            <p>If a list of node_ids is provided, returns a dictionary mapping each node_id to a DataFrame of its successors. If a single node_id is provided, returns the DataFrame directly.</p> </li> </ul> <p>Examples:</p> <pre><code>successors_df = graph.sucessors(node_id)\nsuccessors_dict = graph.sucessors([node1, node2, node3])\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame:\n    \"\"\"\n    Get the successor nodes of given nodes.\n\n    Successors are nodes that are targets of edges originating from the\n    given nodes (outgoing edges). Uses efficient SQL joins to retrieve\n    successor information with their attributes in a single query.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get successors for.\n    attr_keys : Sequence[str] | str | None, optional\n        The attribute keys to retrieve for successor nodes. If None,\n        all attributes are retrieved.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame\n        If a list of node_ids is provided, returns a dictionary mapping\n        each node_id to a DataFrame of its successors. If a single node_id\n        is provided, returns the DataFrame directly.\n\n    Examples\n    --------\n    ```python\n    successors_df = graph.sucessors(node_id)\n    successors_dict = graph.sucessors([node1, node2, node3])\n    ```\n    \"\"\"\n    return self._get_neighbors(\n        node_key=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n        neighbor_key=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        node_ids=node_ids,\n        attr_keys=attr_keys,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get successors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve for successor nodes. If None, all attributes are retrieved.</p>"},{"location":"reference/tracksdata/io/","title":"tracksdata.io","text":""},{"location":"reference/tracksdata/io/#tracksdata.io","title":"tracksdata.io","text":"<p>Input/output utilities for loading and saving tracking data in various formats.</p> <p>Functions:</p> <ul> <li> <code>compressed_tracks_table</code>             \u2013              <p>Compress the tracks of a graph into a (n, 4)-tabular format.</p> </li> <li> <code>load_ctc</code>             \u2013              <p>Load a CTC ground truth file into a graph.</p> </li> </ul>"},{"location":"reference/tracksdata/io/#tracksdata.io.compressed_tracks_table","title":"compressed_tracks_table","text":"<pre><code>compressed_tracks_table(graph: BaseGraph) -&gt; np.ndarray\n</code></pre> <p>Compress the tracks of a graph into a (n, 4)-tabular format.</p> <p>Where - n is the number of tracks - 4 is the number of columns:     - track_id: the track ID     - start: the start frame     - end: the end frame     - parent_track_id: the parent track ID</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tracks</code> (              <code>ndarray</code> )          \u2013            <p>The compressed tracks.</p> </li> </ul> Source code in <code>src/tracksdata/io/_ctc.py</code> <pre><code>def compressed_tracks_table(graph: BaseGraph) -&gt; np.ndarray:\n    \"\"\"\n    Compress the tracks of a graph into a (n, 4)-tabular format.\n\n    Where\n    - n is the number of tracks\n    - 4 is the number of columns:\n        - track_id: the track ID\n        - start: the start frame\n        - end: the end frame\n        - parent_track_id: the parent track ID\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to compress the tracks from.\n\n    Returns\n    -------\n    tracks : np.ndarray\n        The compressed tracks.\n    \"\"\"\n    nodes_df = graph.node_attrs(\n        attr_keys=[\n            DEFAULT_ATTR_KEYS.NODE_ID,\n            DEFAULT_ATTR_KEYS.T,\n            DEFAULT_ATTR_KEYS.TRACK_ID,\n        ]\n    )\n\n    tracks_data = []\n    node_ids = []\n\n    for (track_id,), group in nodes_df.group_by(DEFAULT_ATTR_KEYS.TRACK_ID):\n        start = group[DEFAULT_ATTR_KEYS.T].min()\n        end = group[DEFAULT_ATTR_KEYS.T].max()\n        tracks_data.append([track_id, start, end, 0])\n        node_ids.append(group.filter(pl.col(DEFAULT_ATTR_KEYS.T) == start)[DEFAULT_ATTR_KEYS.NODE_ID].item())\n\n    parents = graph.predecessors(\n        node_ids,\n        attr_keys=[DEFAULT_ATTR_KEYS.TRACK_ID],\n    )\n    for track_id, node_id in zip(tracks_data, node_ids, strict=True):\n        df = parents[node_id]\n        if len(df) &gt; 0:\n            track_id[3] = df[DEFAULT_ATTR_KEYS.TRACK_ID].item()\n\n    out_array = np.asarray(tracks_data, dtype=int)\n    out_array = out_array[np.argsort(out_array[:, 0])]\n\n    return out_array\n</code></pre>"},{"location":"reference/tracksdata/io/#tracksdata.io.compressed_tracks_table(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to compress the tracks from.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.load_ctc","title":"load_ctc","text":"<pre><code>load_ctc(data_dir: str | Path, graph: BaseGraph, region_props_kwargs: dict[str, Any] | None = None) -&gt; None\n</code></pre> <p>Load a CTC ground truth file into a graph. The resulting graph will have region properties attributesfrom a CTC ground truth file.</p> <p>Graph backend method API (e.g. <code>graph.from_ctc</code>) is preferred over this function.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.load_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC ground truth directory. graph : BaseGraph     The graph to load the CTC ground truth into. region_props_kwargs : dict[str, Any]     Keyword arguments to pass to RegionPropsNodes.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.load_ctc--examples","title":"Examples","text":"<pre><code>from tracksdata.io import load_ctc\nfrom tracksdata.graph import RustWorkXGraph\n\ngraph = RustWorkXGraph()\nload_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\", graph)\n</code></pre>"},{"location":"reference/tracksdata/io/#tracksdata.io.load_ctc--see-also","title":"See Also","text":"<p>BaseGraph.from_ctc:     Create a graph from a CTC data directory.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p> Source code in <code>src/tracksdata/io/_ctc.py</code> <pre><code>def load_ctc(\n    data_dir: str | Path,\n    graph: BaseGraph,\n    region_props_kwargs: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Load a CTC ground truth file into a graph.\n    The resulting graph will have region properties attributesfrom a CTC ground truth file.\n\n    Graph backend method API (e.g. `graph.from_ctc`) is preferred over this function.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC ground truth directory.\n    graph : BaseGraph\n        The graph to load the CTC ground truth into.\n    region_props_kwargs : dict[str, Any]\n        Keyword arguments to pass to RegionPropsNodes.\n\n    Examples\n    --------\n    ```python\n    from tracksdata.io import load_ctc\n    from tracksdata.graph import RustWorkXGraph\n\n    graph = RustWorkXGraph()\n    load_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\", graph)\n    ```\n\n    See Also\n    --------\n    [BaseGraph.from_ctc][tracksdata.graph._base_graph.BaseGraph.from_ctc]:\n        Create a graph from a CTC data directory.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    \"\"\"\n    data_dir = Path(data_dir)\n    if not data_dir.exists():\n        raise FileNotFoundError(f\"Data directory {data_dir} does not exist.\")\n\n    if region_props_kwargs is None:\n        region_props_kwargs = {}\n\n    if \"extra_properties\" not in region_props_kwargs:\n        region_props_kwargs[\"extra_properties\"] = [\"label\"]\n\n    elif \"label\" not in region_props_kwargs[\"extra_properties\"]:\n        region_props_kwargs[\"extra_properties\"].append(\"label\")\n\n    tracks_file_found = False\n    track_id_graph = {}\n\n    for tracks_file in [\"man_track.txt\", \"res_track.txt\"]:\n        tracks_file_path = data_dir / tracks_file\n        if tracks_file_path.exists():\n            tracks_file_found = True\n            track_id_graph = _load_tracks_file(tracks_file_path)\n            break\n\n    if not tracks_file_found:\n        LOG.warning(\n            f\"Tracks file {data_dir}/man_track.txt and {data_dir}/res_track.txt does not exist.\\n\"\n            \"Graph won't have edges.\"\n        )\n\n    labels = dask_imread(str(data_dir / \"*.tif\"), imread=tiff_imread)\n\n    region_props_nodes = RegionPropsNodes(**region_props_kwargs)\n    region_props_nodes.add_nodes(graph, labels=labels)\n\n    nodes_df = graph.node_attrs(\n        attr_keys=[\n            DEFAULT_ATTR_KEYS.NODE_ID,\n            DEFAULT_ATTR_KEYS.T,\n            \"label\",\n        ]\n    )\n\n    _add_edges_from_track_ids(\n        graph,\n        nodes_df,\n        track_id_graph,\n        \"label\",\n    )\n\n    # is duplicating an attribute that bad?\n    graph.add_node_attr_key(DEFAULT_ATTR_KEYS.TRACK_ID, -1)\n    graph.update_node_attrs(\n        node_ids=nodes_df[DEFAULT_ATTR_KEYS.NODE_ID].to_list(),\n        attrs={\n            DEFAULT_ATTR_KEYS.TRACK_ID: nodes_df[\"label\"].to_list(),\n        },\n    )\n</code></pre>"},{"location":"reference/tracksdata/metrics/","title":"tracksdata.metrics","text":""},{"location":"reference/tracksdata/metrics/#tracksdata.metrics","title":"tracksdata.metrics","text":"<p>Evaluation metrics for tracking performance, including the CTC benchmark metrics.</p> <p>If you use this module, please cite the respective papers of each metric, as described in here.</p> <p>Functions:</p> <ul> <li> <code>evaluate_ctc_metrics</code>             \u2013              <p>Evaluate CTC metrics using <code>py-ctcmetrics</code> developed by Timo Kaiser.</p> </li> </ul>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics","title":"evaluate_ctc_metrics","text":"<pre><code>evaluate_ctc_metrics(input_graph: RustWorkXGraph, reference_graph: RustWorkXGraph, input_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, reference_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID, input_reset: bool = True, reference_reset: bool = False, metrics: list[str] | None = None) -&gt; dict[str, float]\n</code></pre> <p>Evaluate CTC metrics using <code>py-ctcmetrics</code> developed by Timo Kaiser.</p> <p>If you use this function, please cite the respective papers of each metric, as described in here.</p> <p>IMPORTANT: The <code>SEG</code> metric is computed from the TRA masks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, float]</code>           \u2013            <p>Dictionary with the results of the evaluated metrics.</p> </li> </ul> Source code in <code>src/tracksdata/metrics/_ctc_metrics.py</code> <pre><code>def evaluate_ctc_metrics(\n    input_graph: \"RustWorkXGraph\",\n    reference_graph: \"RustWorkXGraph\",\n    input_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    reference_track_id_key: str = DEFAULT_ATTR_KEYS.TRACK_ID,\n    input_reset: bool = True,\n    reference_reset: bool = False,\n    metrics: list[str] | None = None,\n) -&gt; dict[str, float]:\n    \"\"\"\n    Evaluate CTC metrics using `py-ctcmetrics` developed by [Timo Kaiser](https://github.com/TimoK93).\n\n    If you use this function, please cite the respective papers of each metric, as described in\n    [here](https://github.com/CellTrackingChallenge/py-ctcmetrics?tab=readme-ov-file#acknowledgement-and-citations).\n\n    IMPORTANT: The `SEG` metric is computed from the TRA masks.\n\n    Parameters\n    ----------\n    input_graph : RustWorkXGraph\n        Input graph.\n    reference_graph : RustWorkXGraph\n        Reference graph.\n    input_track_id_key : str, optional\n        Key to obtain the track id from the input graph.\n        If key does not exist, it will be created.\n    reference_track_id_key : str, optional\n        Key to obtain the track id from the reference graph.\n        If key does not exist, it will be created.\n    input_reset : bool, optional\n        Whether to reset the track ids of the input graph. If True, the track ids will be reset to -1.\n    reference_reset : bool, optional\n        Whether to reset the track ids of the reference graph. If True, the track ids will be reset to -1.\n    metrics : list[str] | None, optional\n        List of metrics to evaluate. If None, all metrics are evaluated.\n        Available metrics:\n        \"CHOTA\", \"BC\", \"CT\", \"CCA\", \"TF\", \"TRA\", \"DET\", \"MOTA\", \"HOTA\",\n        \"IDF1\", \"MTML\", \"FAF\", \"LNK\", \"OP_CTB\", \"OP_CSB\", \"BIO\", \"OP_CLB\"\n\n    Returns\n    -------\n    dict[str, float]\n        Dictionary with the results of the evaluated metrics.\n    \"\"\"\n    try:\n        from ctc_metrics.metrics import ALL_METRICS\n        from ctc_metrics.scripts.evaluate import calculate_metrics\n    except ImportError as e:\n        raise ImportError(\n            \"`py-ctcmetrics` is required to evaluate CTC metrics.\\nPlease install it with `pip install py-ctcmetrics`.\"\n        ) from e\n\n    if input_track_id_key not in input_graph.node_attr_keys:\n        input_graph.assign_track_ids(input_track_id_key, reset=input_reset)\n\n    if reference_track_id_key not in reference_graph.node_attr_keys:\n        reference_graph.assign_track_ids(reference_track_id_key, reset=reference_reset)\n\n    input_tracks, reference_tracks, matching_data = compute_ctc_metrics_data(\n        input_graph, reference_graph, input_track_id_key, reference_track_id_key\n    )\n\n    if metrics is None:\n        metrics: list[str] = ALL_METRICS.copy()\n\n    if \"SEG\" in metrics:\n        LOG.warning(\"IMPORTANT! 'SEG' metric results are based on TRA masks, not the SEG masks.\")\n\n    results = calculate_metrics(\n        comp_tracks=input_tracks,\n        ref_tracks=reference_tracks,\n        traj=matching_data,\n        segm=matching_data,\n        metrics=metrics,\n        is_valid=True,\n    )\n\n    results = {k: v.item() if hasattr(v, \"item\") else v for k, v in results.items()}\n\n    return results\n</code></pre>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(input_graph)","title":"<code>input_graph</code>","text":"(<code>RustWorkXGraph</code>)           \u2013            <p>Input graph.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(reference_graph)","title":"<code>reference_graph</code>","text":"(<code>RustWorkXGraph</code>)           \u2013            <p>Reference graph.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(input_track_id_key)","title":"<code>input_track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>Key to obtain the track id from the input graph. If key does not exist, it will be created.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(reference_track_id_key)","title":"<code>reference_track_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACK_ID</code> )           \u2013            <p>Key to obtain the track id from the reference graph. If key does not exist, it will be created.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(input_reset)","title":"<code>input_reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset the track ids of the input graph. If True, the track ids will be reset to -1.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(reference_reset)","title":"<code>reference_reset</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to reset the track ids of the reference graph. If True, the track ids will be reset to -1.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(metrics)","title":"<code>metrics</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of metrics to evaluate. If None, all metrics are evaluated. Available metrics: \"CHOTA\", \"BC\", \"CT\", \"CCA\", \"TF\", \"TRA\", \"DET\", \"MOTA\", \"HOTA\", \"IDF1\", \"MTML\", \"FAF\", \"LNK\", \"OP_CTB\", \"OP_CSB\", \"BIO\", \"OP_CLB\"</p>"},{"location":"reference/tracksdata/nodes/","title":"tracksdata.nodes","text":""},{"location":"reference/tracksdata/nodes/#tracksdata.nodes","title":"tracksdata.nodes","text":"<p>Node operators for creating nodes and their respective attributes (e.g. masks) in a graph.</p> <p>Classes:</p> <ul> <li> <code>GenericFuncNodeAttrs</code>           \u2013            <p>Operator to apply a function to a node and insert the result as a new attribute.</p> </li> <li> <code>Mask</code>           \u2013            <p>Object used to store an individual segmentation mask of a single instance (object)</p> </li> <li> <code>RandomNodes</code>           \u2013            <p>Generate random node coordinates for testing and simulation purposes.</p> </li> <li> <code>RegionPropsNodes</code>           \u2013            <p>Operator that adds nodes to a graph using scikit-image's regionprops.</p> </li> </ul>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs","title":"GenericFuncNodeAttrs","text":"<pre><code>GenericFuncNodeAttrs(func: Callable[[T], R] | Callable[[list[T]], list[R]], output_key: str, default_value: Any = None, attr_keys: Sequence[str] = (), batch_size: int = 0)\n</code></pre> <p>               Bases: <code>BaseNodeAttrsOperator</code></p> <p>Operator to apply a function to a node and insert the result as a new attribute.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>video = ...\ngraph = ...\n\n\ndef intensity_median_times_t(image: NDArray, mask: Mask, t: int) -&gt; float:\n    cropped_frame = mask.crop(image)\n    valid_pixels = cropped_frame[mask.mask]\n    return np.median(valid_pixels) * t\n\n\ncrop_attrs = GenericFuncNodeAttrs(\n    func=intensity_median,\n    output_key=\"intensity_median\",\n    attr_keys=[\"mask\", \"t\"],\n)\n\ncrop_attrs.add_node_attrs(graph, frames=video)\n</code></pre> <p>With batching:</p> <pre><code>video = ...\ngraph = ...\n\n\ndef intensity_median_times_t(image: NDArray, masks: list[Mask], t: list[int]) -&gt; list[float]:\n    results = []\n    for i in range(len(masks)):\n        cropped_frame = masks[i].crop(image)\n        valid_pixels = cropped_frame[masks[i].mask]\n        value = np.median(valid_pixels) * t[i]\n        results.append(value)\n    return results\n\n\ncrop_attrs = GenericFuncNodeAttrs(\n    func=intensity_median,\n    output_key=\"intensity_median\",\n    attr_keys=[\"mask\", \"t\"],\n)\n\ncrop_attrs.add_node_attrs(graph, frames=video)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_node_attrs</code>             \u2013              <p>Add attributes to nodes of a graph.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[[T], R] | Callable[[list[T]], list[R]],\n    output_key: str,\n    default_value: Any = None,\n    attr_keys: Sequence[str] = (),\n    batch_size: int = 0,\n) -&gt; None:\n    super().__init__(output_key)\n    self.func = func\n    self.attr_keys = attr_keys\n    self.default_value = default_value\n    self.batch_size = batch_size\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(func)","title":"<code>func</code>","text":"(<code>Callable[[T], R] | Callable[[list[T]], list[R]]</code>)           \u2013            <p>Function to apply to the node. If <code>frames</code> is provided when calling <code>add_node_attrs</code>, the function must accept a single argument for the frame. Otherwise, the function must accept two arguments for the mask and the additional arguments.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>)           \u2013            <p>Key of the new attribute to add.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            <p>Additional attributes to pass to the <code>func</code> as keyword arguments.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Default value to use for the new attribute. TODO: this should be replaced by a more advanced typing that takes default values.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Batch size to use for the function. If 0, the function will be called for each node separately. If &gt; 0, the function will be called for each batch of nodes and return a list of results. The batch size is the number of nodes that will be passed to the function at once. Batch only contains nodes from the same time point.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._init_node_attrs","title":"_init_node_attrs","text":"<pre><code>_init_node_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the node attributes for the graph.</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def _init_node_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the node attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.node_attr_keys:\n        graph.add_node_attr_key(self.output_key, default_value=self.default_value)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time","title":"_node_attrs_per_time","text":"<pre><code>_node_attrs_per_time(t: int, *, graph: BaseGraph, frames: NDArray | None = None) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add attributes to nodes of a graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def _node_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n    frames: NDArray | None = None,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add attributes to nodes of a graph.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add attributes for.\n    graph : BaseGraph\n        The graph to add attributes to.\n    frames : NDArray | None\n        The frames to index by time point to pass to the `func` function.\n        Such that, when provided, `frames[t]` will be passed to the `func` function.\n    \"\"\"\n    # Get node IDs for the specified time point\n    node_ids = graph.filter_nodes_by_attrs(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n\n    if len(node_ids) == 0:\n        LOG.warning(f\"No nodes at time point {t}\")\n        return []\n\n    # Get attributes for these nodes\n    node_attrs = graph.node_attrs(node_ids=node_ids, attr_keys=self.attr_keys)\n\n    args = []\n    if frames is not None:\n        args.append(np.asarray(frames[t]))\n\n    results = []\n    if self.batch_size &gt; 0:\n        size = len(node_attrs)\n        for i in range(0, size, self.batch_size):\n            batch_node_attrs = node_attrs.slice(i, min(i + self.batch_size, size))\n            batch_results = self.func(*args, **batch_node_attrs.to_dict())\n            results.extend(batch_results)\n\n    else:\n        for data_dict in node_attrs.rows(named=True):\n            result = self.func(*args, **data_dict)\n            results.append(result)\n\n    return node_ids, {self.output_key: results}\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add attributes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time(frames)","title":"<code>frames</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>The frames to index by time point to pass to the <code>func</code> function. Such that, when provided, <code>frames[t]</code> will be passed to the <code>func</code> function.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs","title":"add_node_attrs","text":"<pre><code>add_node_attrs(graph: BaseGraph, *, t: int | None = None, frames: NDArray | None = None) -&gt; None\n</code></pre> <p>Add attributes to nodes of a graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def add_node_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    frames: NDArray | None = None,\n) -&gt; None:\n    \"\"\"\n    Add attributes to nodes of a graph.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    frames : NDArray | None\n        The frames to index by time point to pass to the `func` function.\n        Such that `frames[t]` will be passed to the `func` function.\n    \"\"\"\n    super().add_node_attrs(graph, t=t, frames=frames)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs(frames)","title":"<code>frames</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>The frames to index by time point to pass to the <code>func</code> function. Such that <code>frames[t]</code> will be passed to the <code>func</code> function.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask","title":"Mask","text":"<pre><code>Mask(mask: NDArray[bool_], bbox: ArrayLike)\n</code></pre> <p>Object used to store an individual segmentation mask of a single instance (object)</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask--parameters","title":"Parameters","text":"<p>mask : NDArray[np.bool_]     A binary indicating the pixels that are part of the object (e.g. cell, nucleus, etc.). bbox : np.ndarray     The bounding box of the region of interest with shape (2 * ndim,).     The first ndim elements are the start indices and the last ndim elements are the end indices.     Equivalent to slicing a numpy array with <code>[start:end]</code>. Examples</p> <pre><code>mask = Mask(mask=np.array([[True, False], [False, True]]), bbox=np.array([0, 0, 2, 2]))\n</code></pre> <p>Methods:</p> <ul> <li> <code>crop</code>             \u2013              <p>Crop the mask from an image.</p> </li> <li> <code>from_coordinates</code>             \u2013              <p>Create a mask from a center and a radius.</p> </li> <li> <code>intersection</code>             \u2013              <p>Compute the intersection between two masks considering their bounding boxes location.</p> </li> <li> <code>iou</code>             \u2013              <p>Compute the Intersection over Union (IoU) between two masks</p> </li> <li> <code>mask_indices</code>             \u2013              <p>Get the indices of the pixels that are part of the object.</p> </li> <li> <code>paint_buffer</code>             \u2013              <p>Paint object into a buffer.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>size</code>               (<code>int</code>)           \u2013            <p>Get the number of pixels that are part of the object.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def __init__(\n    self,\n    mask: NDArray[np.bool_],\n    bbox: ArrayLike,\n):\n    self._mask = mask\n    self.bbox = bbox\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.size","title":"size  <code>cached</code> <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>Get the number of pixels that are part of the object.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.crop","title":"crop","text":"<pre><code>crop(image: NDArray, shape: tuple[int, ...] | None = None) -&gt; NDArray\n</code></pre> <p>Crop the mask from an image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NDArray</code>           \u2013            <p>The cropped image.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def crop(\n    self,\n    image: NDArray,\n    shape: tuple[int, ...] | None = None,\n) -&gt; NDArray:\n    \"\"\"\n    Crop the mask from an image.\n\n    Parameters\n    ----------\n    image : NDArray\n        The image to crop from.\n    shape : tuple[int, ...] | None\n        The shape of the cropped image. If None, the `bbox` will be used.\n\n    Returns\n    -------\n    NDArray\n        The cropped image.\n    \"\"\"\n    if shape is None:\n        ndim = self._mask.ndim\n        slicing = tuple(slice(self._bbox[i], self._bbox[i + ndim]) for i in range(ndim))\n\n    else:\n        center = (self._bbox[: self._mask.ndim] + self._bbox[self._mask.ndim :]) // 2\n        half_shape = np.asarray(shape) // 2\n        start = np.maximum(center - half_shape, 0)\n        end = np.minimum(center + half_shape, image.shape)\n        slicing = tuple(slice(s, e) for s, e in zip(start, end, strict=True))\n\n    return image[slicing]\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.crop(image)","title":"<code>image</code>","text":"(<code>NDArray</code>)           \u2013            <p>The image to crop from.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.crop(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the cropped image. If None, the <code>bbox</code> will be used.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates","title":"from_coordinates  <code>classmethod</code>","text":"<pre><code>from_coordinates(center: NDArray, radius: int, image_shape: tuple[int, ...] | None = None) -&gt; Mask\n</code></pre> <p>Create a mask from a center and a radius. Regions outside the image are cropped.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Mask</code>           \u2013            <p>The mask.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>@classmethod\ndef from_coordinates(\n    cls,\n    center: NDArray,\n    radius: int,\n    image_shape: tuple[int, ...] | None = None,\n) -&gt; \"Mask\":\n    \"\"\"\n    Create a mask from a center and a radius.\n    Regions outside the image are cropped.\n\n    Parameters\n    ----------\n    center : NDArray\n        The center of the mask.\n    radius : int\n        The radius of the mask.\n    image_shape : tuple[int, ...] | None\n        The shape of the image.\n        When provided crops regions outside the image.\n\n    Returns\n    -------\n    Mask\n        The mask.\n    \"\"\"\n    mask = _spherical_mask(radius, len(center))\n    center = np.round(center)\n\n    start = center - np.asarray(mask.shape) // 2\n    end = start + mask.shape\n\n    if image_shape is None:\n        bbox = np.concatenate([start, end])\n    else:\n        processed_start = np.maximum(start, 0)\n        processed_end = np.minimum(end, image_shape)\n\n        start_overhang = processed_start - start\n        end_overhang = end - processed_end\n\n        mask = mask[\n            tuple(slice(s, -e if e &gt; 0 else None) for s, e in zip(start_overhang, end_overhang, strict=True))\n        ]\n\n        bbox = np.concatenate([processed_start, processed_end])\n\n    return cls(mask, bbox)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates(center)","title":"<code>center</code>","text":"(<code>NDArray</code>)           \u2013            <p>The center of the mask.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates(radius)","title":"<code>radius</code>","text":"(<code>int</code>)           \u2013            <p>The radius of the mask.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates(image_shape)","title":"<code>image_shape</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the image. When provided crops regions outside the image.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.intersection","title":"intersection","text":"<pre><code>intersection(other: Mask) -&gt; float\n</code></pre> <p>Compute the intersection between two masks considering their bounding boxes location.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The intersection between the two masks.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def intersection(self, other: \"Mask\") -&gt; float:\n    \"\"\"\n    Compute the intersection between two masks considering their bounding boxes location.\n\n    Parameters\n    ----------\n    other : Mask\n        The other mask to compute the intersection with.\n\n    Returns\n    -------\n    float\n        The intersection between the two masks.\n    \"\"\"\n    return fast_intersection_with_bbox(self._bbox, other._bbox, self._mask, other._mask)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.intersection(other)","title":"<code>other</code>","text":"(<code>Mask</code>)           \u2013            <p>The other mask to compute the intersection with.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.iou","title":"iou","text":"<pre><code>iou(other: Mask) -&gt; float\n</code></pre> <p>Compute the Intersection over Union (IoU) between two masks considering their bounding boxes location.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The IoU between the two masks.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def iou(self, other: \"Mask\") -&gt; float:\n    \"\"\"\n    Compute the Intersection over Union (IoU) between two masks\n    considering their bounding boxes location.\n\n    Parameters\n    ----------\n    other : Mask\n        The other mask to compute the IoU with.\n\n    Returns\n    -------\n    float\n        The IoU between the two masks.\n    \"\"\"\n    return fast_iou_with_bbox(self._bbox, other._bbox, self._mask, other._mask)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.iou(other)","title":"<code>other</code>","text":"(<code>Mask</code>)           \u2013            <p>The other mask to compute the IoU with.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.mask_indices","title":"mask_indices","text":"<pre><code>mask_indices(offset: NDArray[integer] | int = 0) -&gt; tuple[NDArray[np.integer], ...]\n</code></pre> <p>Get the indices of the pixels that are part of the object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[NDArray[integer], ...]</code>           \u2013            <p>The indices of the pixels that are part of the object.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def mask_indices(\n    self,\n    offset: NDArray[np.integer] | int = 0,\n) -&gt; tuple[NDArray[np.integer], ...]:\n    \"\"\"\n    Get the indices of the pixels that are part of the object.\n\n    Parameters\n    ----------\n    offset : NDArray[np.integer] | int, optional\n        The offset to add to the indices, should be used with bounding box information.\n\n    Returns\n    -------\n    tuple[NDArray[np.integer], ...]\n        The indices of the pixels that are part of the object.\n    \"\"\"\n    if isinstance(offset, int):\n        offset = np.full(self._mask.ndim, offset)\n\n    indices = list(np.nonzero(self._mask))\n\n    for i, index in enumerate(indices):\n        indices[i] = index + self._bbox[i] + offset[i]\n\n    return tuple(indices)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.mask_indices(offset)","title":"<code>offset</code>","text":"(<code>NDArray[integer] | int</code>, default:                   <code>0</code> )           \u2013            <p>The offset to add to the indices, should be used with bounding box information.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer","title":"paint_buffer","text":"<pre><code>paint_buffer(buffer: ndarray, value: int | float, offset: NDArray[integer] | int = 0) -&gt; None\n</code></pre> <p>Paint object into a buffer.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def paint_buffer(\n    self,\n    buffer: np.ndarray,\n    value: int | float,\n    offset: NDArray[np.integer] | int = 0,\n) -&gt; None:\n    \"\"\"\n    Paint object into a buffer.\n\n    Parameters\n    ----------\n    buffer : np.ndarray\n        The buffer to paint inplace.\n    value : int | float\n        The value to paint the object.\n    offset : NDArray[np.integer] | int, optional\n        The offset to add to the indices, should be used with bounding box information.\n    \"\"\"\n    # TODO: make it zarr and tensorstore compatible\n    indices = self.mask_indices(offset)\n    buffer[indices] = value\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer(buffer)","title":"<code>buffer</code>","text":"(<code>ndarray</code>)           \u2013            <p>The buffer to paint inplace.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer(value)","title":"<code>value</code>","text":"(<code>int | float</code>)           \u2013            <p>The value to paint the object.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer(offset)","title":"<code>offset</code>","text":"(<code>NDArray[integer] | int</code>, default:                   <code>0</code> )           \u2013            <p>The offset to add to the indices, should be used with bounding box information.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes","title":"RandomNodes","text":"<pre><code>RandomNodes(n_time_points: int, n_nodes_per_tp: tuple[int, int], n_dim: Literal[2, 3] = 3, random_state: int = 0)\n</code></pre> <p>               Bases: <code>BaseNodesOperator</code></p> <p>Generate random node coordinates for testing and simulation purposes.</p> <p>RandomNodes creates nodes with randomly distributed coordinates within the unit hypercube [0,1]^n. This is useful for testing tracking algorithms, generating synthetic datasets, or creating baseline comparisons. The number of nodes per time point can vary randomly within a specified range.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>n_time_points</code>               (<code>int</code>)           \u2013            <p>Number of time points to generate.</p> </li> <li> <code>n_nodes</code>               (<code>tuple[int, int]</code>)           \u2013            <p>Range of nodes per time point.</p> </li> <li> <code>spatial_cols</code>               (<code>list[str]</code>)           \u2013            <p>Names of spatial coordinate columns.</p> </li> <li> <code>rng</code>               (<code>Generator</code>)           \u2013            <p>Random number generator instance.</p> </li> </ul> See Also <p>RegionPropsNodes:     Extract nodes from segmented images using region properties.</p> <p>Mask:     Node operator for mask-based objects.</p> <p>Examples:</p> <p>Generate 2D random nodes:</p> <pre><code>from tracksdata.nodes import RandomNodes\n\nnode_op = RandomNodes(n_time_points=10, n_nodes_per_tp=(5, 15), n_dim=2, random_state=42)\n</code></pre> <p>Add nodes to a graph:</p> <pre><code>node_op.add_nodes(graph)\n</code></pre> <p>Generate nodes for a specific time point:</p> <pre><code>node_op.add_nodes(graph, t=5)\n</code></pre> <p>Use 3D coordinates with consistent node count:</p> <pre><code>node_op = RandomNodes(\n    n_time_points=20,\n    n_nodes_per_tp=(10, 10),  # exactly 10 nodes per time point\n    n_dim=3,\n)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_nodes</code>             \u2013              <p>Override the base add_nodes method to handle n_time_points parameter.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_random.py</code> <pre><code>def __init__(\n    self,\n    n_time_points: int,\n    n_nodes_per_tp: tuple[int, int],\n    n_dim: Literal[2, 3] = 3,\n    random_state: int = 0,\n):\n    super().__init__()\n    if isinstance(n_nodes_per_tp, int):\n        raise ValueError(\"`n_nodes_per_tp` must be a tuple of two integers\")\n\n    self.n_time_points = n_time_points\n    self.n_nodes = n_nodes_per_tp\n\n    if n_dim == 2:\n        self.spatial_cols = [\"x\", \"y\"]\n    elif n_dim == 3:\n        self.spatial_cols = [\"x\", \"y\", \"z\"]\n    else:\n        raise ValueError(f\"Invalid number of dimensions: {n_dim}\")\n\n    self.rng = np.random.default_rng(random_state)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(n_time_points)","title":"<code>n_time_points</code>","text":"(<code>int</code>)           \u2013            <p>The number of time points to generate nodes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(n_nodes_per_tp)","title":"<code>n_nodes_per_tp</code>","text":"(<code>tuple[int, int]</code>)           \u2013            <p>The minimum and maximum number of nodes to generate per time point. The actual number is randomly chosen within this range for each time point.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(n_dim)","title":"<code>n_dim</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The spatial dimensionality of the coordinates:</p> <ul> <li>2: generates (x, y) coordinates</li> <li>3: generates (x, y, z) coordinates</li> </ul>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(random_state)","title":"<code>random_state</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Random seed for reproducible results.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes._nodes_per_time","title":"_nodes_per_time","text":"<pre><code>_nodes_per_time(t: int, **kwargs: Any) -&gt; list[dict[str, Any]]\n</code></pre> <p>Add nodes for a specific time point.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>The nodes to add to the graph.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_random.py</code> <pre><code>def _nodes_per_time(\n    self,\n    t: int,\n    **kwargs: Any,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Add nodes for a specific time point.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add nodes for.\n    **kwargs : Any\n        Additional keyword arguments to pass to add_node.\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        The nodes to add to the graph.\n    \"\"\"\n    n_nodes_at_t = self.rng.integers(\n        self.n_nodes[0],\n        self.n_nodes[1],\n    )\n\n    coords = self.rng.uniform(\n        low=0,\n        high=1,\n        size=(n_nodes_at_t, len(self.spatial_cols)),\n    ).tolist()\n\n    return [{\"t\": t, **dict(zip(self.spatial_cols, c, strict=True)), **kwargs} for c in coords]\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes._nodes_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add nodes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes._nodes_per_time(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to add_node.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(graph: BaseGraph, *, t: int | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Override the base add_nodes method to handle n_time_points parameter.</p> <p>When t=None, iterates over range(n_time_points) instead of graph.time_points(). When t is specified, uses the base implementation.</p> Source code in <code>src/tracksdata/nodes/_random.py</code> <pre><code>def add_nodes(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Override the base add_nodes method to handle n_time_points parameter.\n\n    When t=None, iterates over range(n_time_points) instead of graph.time_points().\n    When t is specified, uses the base implementation.\n    \"\"\"\n    # Register each spatial column individually\n    for col in self.spatial_cols:\n        if col not in graph.node_attr_keys:\n            graph.add_node_attr_key(col, -999999.0)\n\n    if t is None:\n        time_points = range(self.n_time_points)\n    else:\n        time_points = [t]\n\n    _add_nodes_per_time = curry(self._nodes_per_time, **kwargs)\n    for node_attrs in multiprocessing_apply(\n        _add_nodes_per_time,\n        time_points,\n        desc=\"Adding nodes\",\n    ):\n        graph.bulk_add_nodes(node_attrs)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes","title":"RegionPropsNodes","text":"<pre><code>RegionPropsNodes(extra_properties: list[str | Callable[[RegionProperties], Any]] | None = None, spacing: tuple[float, float] | None = None)\n</code></pre> <p>               Bases: <code>BaseNodesOperator</code></p> <p>Operator that adds nodes to a graph using scikit-image's regionprops.</p> <p>Extracts region properties from labeled images to create graph nodes using scikit-image's regionprops function to compute geometric and intensity-based features. Automatically adds centroid coordinates and mask information, with additional properties computed based on the extra_properties parameter.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes--parameters","title":"Parameters","text":"<p>extra_properties : list[str | Callable[[RegionProperties], Any]] | None, optional     Additional properties to compute for each region. Can be:     - String names of built-in regionprops properties (e.g., 'area', 'perimeter')     - Callable functions that take a RegionProperties object and return a value     If None, only centroid coordinates and masks are extracted. spacing : tuple[float, float] | None, optional     Physical spacing between pixels. If provided, affects distance-based     measurements. Should be (row_spacing, col_spacing) for 2D or     (depth_spacing, row_spacing, col_spacing) for 3D.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes--attributes","title":"Attributes","text":"<p>_extra_properties : list     List of additional properties to compute. _spacing : tuple[float, float] | None     Physical spacing between pixels.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes--examples","title":"Examples","text":"<p>Create a basic RegionPropsNodes operator:</p> <pre><code>from tracksdata.nodes import RegionPropsNodes\n\nnode_op = RegionPropsNodes()\n</code></pre> <p>Add common geometric properties:</p> <pre><code>node_op = RegionPropsNodes(extra_properties=[\"area\", \"perimeter\", \"eccentricity\"])\n</code></pre> <p>Add custom properties using functions:</p> <pre><code>def custom_property(region):\n    return region.area / region.perimeter\n\n\nnode_op = RegionPropsNodes(extra_properties=[\"area\", custom_property])\n</code></pre> <p>Use with physical spacing:</p> <pre><code>node_op = RegionPropsNodes(\n    spacing=(0.5, 0.1, 0.1),  # z, y, x spacing\n    extra_properties=[\"area\", \"volume\"],\n)\n</code></pre> <p>Add nodes from a time series:</p> <pre><code>labels_series = np.random.randint(0, 10, (10, 100, 100))\nnode_op.add_nodes(graph, labels=labels_series)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_nodes</code>             \u2013              <p>Add nodes to a graph using region properties from labeled images.</p> </li> <li> <code>attrs_keys</code>             \u2013              <p>Get the keys of the node attributes that will be extracted.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def __init__(\n    self,\n    extra_properties: list[str | Callable[[RegionProperties], Any]] | None = None,\n    spacing: tuple[float, float] | None = None,\n):\n    super().__init__()\n    self._extra_properties = extra_properties or []\n    self._spacing = spacing\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._axis_names","title":"_axis_names","text":"<pre><code>_axis_names(labels: NDArray[integer]) -&gt; list[str]\n</code></pre> <p>Get the names of the axes of the labels.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The names of the axes of the labels.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def _axis_names(self, labels: NDArray[np.integer]) -&gt; list[str]:\n    \"\"\"\n    Get the names of the axes of the labels.\n\n    Parameters\n    ----------\n    labels : NDArray[np.integer]\n        The (t + nD) labels to get the axis names for.\n\n    Returns\n    -------\n    list[str]\n        The names of the axes of the labels.\n    \"\"\"\n    if labels.ndim == 3:\n        return [\"y\", \"x\"]\n    elif labels.ndim == 4:\n        return [\"z\", \"y\", \"x\"]\n    else:\n        raise ValueError(f\"`labels` must be 't + 2D' or 't + 3D', got '{labels.ndim}' dimensions.\")\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._axis_names(labels)","title":"<code>labels</code>","text":"(<code>NDArray[integer]</code>)           \u2013            <p>The (t + nD) labels to get the axis names for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._init_node_attrs","title":"_init_node_attrs","text":"<pre><code>_init_node_attrs(graph: BaseGraph, axis_names: list[str]) -&gt; None\n</code></pre> <p>Initialize the node attributes for the graph.</p> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def _init_node_attrs(self, graph: BaseGraph, axis_names: list[str]) -&gt; None:\n    \"\"\"\n    Initialize the node attributes for the graph.\n    \"\"\"\n    if DEFAULT_ATTR_KEYS.MASK not in graph.node_attr_keys:\n        graph.add_node_attr_key(DEFAULT_ATTR_KEYS.MASK, None)\n\n    # initialize the attribute keys\n    for attr_key in axis_names + self.attrs_keys():\n        if attr_key not in graph.node_attr_keys:\n            graph.add_node_attr_key(attr_key, -1.0)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time","title":"_nodes_per_time","text":"<pre><code>_nodes_per_time(t: int, *, labels: NDArray[integer], intensity_image: NDArray | None = None) -&gt; list[dict[str, Any]]\n</code></pre> <p>Add nodes for a specific time point using region properties.</p> <p>Processes a single time point, computing region properties for each labeled region and creating corresponding graph nodes. Determines spatial dimensions from label shape, ensures required attribute keys exist, computes region properties, extracts coordinates and extra properties, creates mask objects, and bulk adds all nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>The nodes to add to the graph.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If labels is not 2D or 3D.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def _nodes_per_time(\n    self,\n    t: int,\n    *,\n    labels: NDArray[np.integer],\n    intensity_image: NDArray | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Add nodes for a specific time point using region properties.\n\n    Processes a single time point, computing region properties for each labeled\n    region and creating corresponding graph nodes. Determines spatial dimensions\n    from label shape, ensures required attribute keys exist, computes region\n    properties, extracts coordinates and extra properties, creates mask objects,\n    and bulk adds all nodes.\n\n    Parameters\n    ----------\n    t : int\n        The time point to assign to the created nodes.\n    labels : NDArray[np.integer]\n        2D or 3D labeled image for a single time point.\n    intensity_image : NDArray | None, optional\n        Corresponding intensity image for computing intensity-based properties.\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        The nodes to add to the graph.\n\n    Raises\n    ------\n    ValueError\n        If labels is not 2D or 3D.\n    \"\"\"\n    axis_names = self._axis_names(labels)\n\n    labels = np.asarray(labels[t])\n\n    if intensity_image is not None:\n        intensity_image = np.asarray(intensity_image[t])\n\n    nodes_data = []\n\n    for obj in regionprops(\n        labels,\n        intensity_image=intensity_image,\n        spacing=self._spacing,\n        cache=True,\n    ):\n        attrs = dict(zip(axis_names, obj.centroid, strict=False))\n\n        for prop in self._extra_properties:\n            if callable(prop):\n                attrs[prop.__name__] = prop(obj)\n            else:\n                attrs[prop] = getattr(obj, prop)\n\n        attrs[DEFAULT_ATTR_KEYS.MASK] = Mask(obj.image, obj.bbox)\n        attrs[DEFAULT_ATTR_KEYS.T] = t\n\n        nodes_data.append(attrs)\n        obj._cache.clear()  # clearing to reduce memory footprint\n\n    if len(nodes_data) == 0:\n        LOG.warning(\"No valid nodes found for time point %d\", t)\n\n    return nodes_data\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to assign to the created nodes.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time(labels)","title":"<code>labels</code>","text":"(<code>NDArray[integer]</code>)           \u2013            <p>2D or 3D labeled image for a single time point.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time(intensity_image)","title":"<code>intensity_image</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>Corresponding intensity image for computing intensity-based properties.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(graph: BaseGraph, *, labels: NDArray[integer], t: int | None = None, intensity_image: NDArray | None = None) -&gt; None\n</code></pre> <p>Add nodes to a graph using region properties from labeled images.</p> <p>Extracts region properties from labeled images and creates corresponding nodes in the graph. Can handle both single time point and time series data. When t is None, the first axis of labels represents time and processes each time point sequentially. Automatically initializes required attribute keys in the graph schema before adding nodes.</p> <p>Parameters:</p> <p>Examples:</p> <p>Add nodes from a single 2D labeled image:</p> <pre><code>labels = skimage.measure.label(binary_image)\nnode_op.add_nodes(graph, labels=labels, t=0)\n</code></pre> <p>Add nodes from a time series:</p> <pre><code>labels_series = np.stack(\n    [\n        skimage.measure.label(binary_image_t0),\n        skimage.measure.label(binary_image_t1),\n    ]\n)\nnode_op.add_nodes(graph, labels=labels_series)\n</code></pre> <p>Add nodes with intensity information:</p> <pre><code>node_op.add_nodes(graph, labels=labels, t=0, intensity_image=fluorescence_image)\n</code></pre> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>@override\ndef add_nodes(\n    self,\n    graph: BaseGraph,\n    *,\n    labels: NDArray[np.integer],\n    t: int | None = None,\n    intensity_image: NDArray | None = None,\n) -&gt; None:\n    \"\"\"\n    Add nodes to a graph using region properties from labeled images.\n\n    Extracts region properties from labeled images and creates corresponding\n    nodes in the graph. Can handle both single time point and time series data.\n    When t is None, the first axis of labels represents time and processes each\n    time point sequentially. Automatically initializes required attribute keys\n    in the graph schema before adding nodes.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add nodes to.\n    labels : NDArray[np.integer]\n        Labeled image(s) where each unique positive integer represents\n        a different region/object. Can be:\n        - 3D array (time, height, width) for 2D time series\n        - 4D array (time, depth, height, width) for 3D time series\n        When `t` is provided, it should be padded to include the time dimension.\n    t : int | None, optional\n        Time point for the nodes. If None, labels are treated as a time\n        series where the first axis represents time.\n    intensity_image : NDArray | None, optional\n        Intensity image(s) corresponding to the labels. Used for computing\n        intensity-based properties. Must have the same shape as labels\n        (excluding the label values).\n\n    Examples\n    --------\n    Add nodes from a single 2D labeled image:\n\n    ```python\n    labels = skimage.measure.label(binary_image)\n    node_op.add_nodes(graph, labels=labels, t=0)\n    ```\n\n    Add nodes from a time series:\n\n    ```python\n    labels_series = np.stack(\n        [\n            skimage.measure.label(binary_image_t0),\n            skimage.measure.label(binary_image_t1),\n        ]\n    )\n    node_op.add_nodes(graph, labels=labels_series)\n    ```\n\n    Add nodes with intensity information:\n\n    ```python\n    node_op.add_nodes(graph, labels=labels, t=0, intensity_image=fluorescence_image)\n    ```\n    \"\"\"\n    axis_names = self._axis_names(labels)\n    self._init_node_attrs(graph, axis_names)\n\n    if t is None:\n        time_points = range(labels.shape[0])\n    else:\n        time_points = [t]\n\n    node_ids = []\n    for nodes_data in multiprocessing_apply(\n        func=curry(self._nodes_per_time, labels=labels, intensity_image=intensity_image),\n        sequence=time_points,\n        desc=\"Adding region properties nodes\",\n    ):\n        node_ids.extend(graph.bulk_add_nodes(nodes_data))\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add nodes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(labels)","title":"<code>labels</code>","text":"(<code>NDArray[integer]</code>)           \u2013            <p>Labeled image(s) where each unique positive integer represents a different region/object. Can be: - 3D array (time, height, width) for 2D time series - 4D array (time, depth, height, width) for 3D time series When <code>t</code> is provided, it should be padded to include the time dimension.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Time point for the nodes. If None, labels are treated as a time series where the first axis represents time.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(intensity_image)","title":"<code>intensity_image</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>Intensity image(s) corresponding to the labels. Used for computing intensity-based properties. Must have the same shape as labels (excluding the label values).</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.attrs_keys","title":"attrs_keys","text":"<pre><code>attrs_keys() -&gt; list[str]\n</code></pre> <p>Get the keys of the node attributes that will be extracted.</p> <p>Returns only the keys for extra_properties. The centroid coordinates (x, y, z) and mask are always included but not listed here.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of attribute key names that will be added to nodes.</p> </li> </ul> <p>Examples:</p> <pre><code>node_op = RegionPropsNodes(extra_properties=[\"area\", \"perimeter\"])\nkeys = node_op.attrs_keys()\nprint(keys)  # ['area', 'perimeter']\n</code></pre> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def attrs_keys(self) -&gt; list[str]:\n    \"\"\"\n    Get the keys of the node attributes that will be extracted.\n\n    Returns only the keys for extra_properties. The centroid coordinates\n    (x, y, z) and mask are always included but not listed here.\n\n    Returns\n    -------\n    list[str]\n        List of attribute key names that will be added to nodes.\n\n    Examples\n    --------\n    ```python\n    node_op = RegionPropsNodes(extra_properties=[\"area\", \"perimeter\"])\n    keys = node_op.attrs_keys()\n    print(keys)  # ['area', 'perimeter']\n    ```\n    \"\"\"\n    return [prop.__name__ if callable(prop) else prop for prop in self._extra_properties]\n</code></pre>"},{"location":"reference/tracksdata/options/","title":"tracksdata.options","text":""},{"location":"reference/tracksdata/options/#tracksdata.options","title":"tracksdata.options","text":"<p>Global options system for TracksData.</p> <p>Classes:</p> <ul> <li> <code>Options</code>           \u2013            <p>Global options for TracksData.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_options</code>             \u2013              <p>Get the current global options.</p> </li> <li> <code>options_context</code>             \u2013              <p>Context manager for temporarily modifying options.</p> </li> <li> <code>set_options</code>             \u2013              <p>Set the global options pushing a new Options object to the stack.</p> </li> </ul>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options","title":"Options  <code>dataclass</code>","text":"<pre><code>Options(show_progress: bool = True, n_workers: int = 1)\n</code></pre> <p>Global options for TracksData.</p> <p>This class provides a centralized way to control various behaviors across the library, such as progress display and multiprocessing.</p>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options--parameters","title":"Parameters","text":"<p>show_progress : bool, default True     Whether to display progress bars during operations. n_workers : int     Number of worker processes to use for multiprocessing operations.     - 0 or 1: use default behavior (sequential)     - &gt; 1: use exactly this many worker processes     NOTE: Overhead of multiprocessing is significant, experiment with 1 before increasing.</p> <p>Methods:</p> <ul> <li> <code>__enter__</code>             \u2013              <p>Enter the context manager.</p> </li> <li> <code>__exit__</code>             \u2013              <p>Exit the context manager.</p> </li> <li> <code>copy</code>             \u2013              <p>Return a copy of the options.</p> </li> <li> <code>update</code>             \u2013              <p>Update the options with the given keyword arguments.</p> </li> </ul>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Options\n</code></pre> <p>Enter the context manager.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def __enter__(self) -&gt; \"Options\":\n    \"\"\"Enter the context manager.\"\"\"\n    # Push current options to stack\n    _options_stack.append(self)\n    return self\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None\n</code></pre> <p>Exit the context manager.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"Exit the context manager.\"\"\"\n    # Pop this options from stack\n    if _options_stack:\n        _options_stack.pop()\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.copy","title":"copy","text":"<pre><code>copy() -&gt; Options\n</code></pre> <p>Return a copy of the options.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def copy(self) -&gt; \"Options\":\n    \"\"\"Return a copy of the options.\"\"\"\n    return Options(**self.__dict__)\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.update","title":"update","text":"<pre><code>update(**kwargs: Any) -&gt; None\n</code></pre> <p>Update the options with the given keyword arguments.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def update(self, **kwargs: Any) -&gt; None:\n    \"\"\"Update the options with the given keyword arguments.\"\"\"\n    valid_keys = set(self.__dict__.keys())\n    for key, value in kwargs.items():\n        if key not in valid_keys:\n            raise ValueError(f\"Invalid option: {key}. Expected one of {valid_keys}\")\n        setattr(self, key, value)\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.get_options","title":"get_options","text":"<pre><code>get_options() -&gt; Options\n</code></pre> <p>Get the current global options.</p> <p>Returns:</p> <ul> <li> <code>Options</code>           \u2013            <p>The current global options instance.</p> </li> </ul> Source code in <code>src/tracksdata/options.py</code> <pre><code>def get_options() -&gt; Options:\n    \"\"\"\n    Get the current global options.\n\n    Returns\n    -------\n    Options\n        The current global options instance.\n    \"\"\"\n    # Return the top of the stack, or default if stack is empty\n    return _options_stack[-1] if _options_stack else _default_options\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.options_context","title":"options_context","text":"<pre><code>options_context(**kwargs: Any) -&gt; Generator[Options, None, None]\n</code></pre> <p>Context manager for temporarily modifying options.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Options</code>           \u2013            <p>The options object with the temporary settings.</p> </li> </ul> <p>Examples:</p> <pre><code>from tracksdata.options import options_context\n\nwith options_context(show_progress=False):\n    # Operations here will not show progress\n    pass\n</code></pre> See Also <p>Options:     The global options class.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>@contextmanager\ndef options_context(**kwargs: Any) -&gt; Generator[Options, None, None]:\n    \"\"\"\n    Context manager for temporarily modifying options.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Options parameters to temporarily set.\n\n    Yields\n    ------\n    Options\n        The options object with the temporary settings.\n\n    Examples\n    --------\n    ```python\n    from tracksdata.options import options_context\n\n    with options_context(show_progress=False):\n        # Operations here will not show progress\n        pass\n    ```\n\n    See Also\n    --------\n    [Options][tracksdata.options.Options]:\n        The global options class.\n\n    \"\"\"\n    temp_options = Options(**kwargs)\n    with temp_options:\n        yield temp_options\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.options_context(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Options parameters to temporarily set.</p>"},{"location":"reference/tracksdata/options/#tracksdata.options.set_options","title":"set_options","text":"<pre><code>set_options(options: Options | None = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Set the global options pushing a new Options object to the stack.</p> <p>Parameters:</p> <p>Examples:</p> <p>Set options using an Options object:</p> <pre><code>&gt;&gt;&gt; from tracksdata.options import Options, set_options\n&gt;&gt;&gt; set_options(Options(show_progress=False))\n</code></pre> <p>Set options using keyword arguments:</p> <pre><code>&gt;&gt;&gt; set_options(show_progress=False)\n</code></pre> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both options and kwargs are provided, or if neither are provided.</p> </li> </ul> Source code in <code>src/tracksdata/options.py</code> <pre><code>def set_options(options: Options | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Set the global options pushing a new Options object to the stack.\n\n    Parameters\n    ----------\n    options : Options | None, optional\n        The options object to set as global. If None, kwargs will be used to create a new Options object.\n    **kwargs : Any\n        Individual option parameters to set. Only used if options is None.\n\n    Examples\n    --------\n    Set options using an Options object:\n\n    &gt;&gt;&gt; from tracksdata.options import Options, set_options\n    &gt;&gt;&gt; set_options(Options(show_progress=False))\n\n    Set options using keyword arguments:\n\n    &gt;&gt;&gt; set_options(show_progress=False)\n\n    Raises\n    ------\n    ValueError\n        If both options and kwargs are provided, or if neither are provided.\n    \"\"\"\n    if options is not None and kwargs:\n        raise ValueError(\"Cannot provide both 'options' and keyword arguments\")\n\n    if options is None and not kwargs:\n        raise ValueError(\"Must provide either 'options' or keyword arguments\")\n\n    if options is None:\n        options = get_options().copy()\n        options.update(**kwargs)\n\n    _options_stack.append(options)\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.set_options(options)","title":"<code>options</code>","text":"(<code>Options | None</code>, default:                   <code>None</code> )           \u2013            <p>The options object to set as global. If None, kwargs will be used to create a new Options object.</p>"},{"location":"reference/tracksdata/options/#tracksdata.options.set_options(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Individual option parameters to set. Only used if options is None.</p>"},{"location":"reference/tracksdata/solvers/","title":"tracksdata.solvers","text":""},{"location":"reference/tracksdata/solvers/#tracksdata.solvers","title":"tracksdata.solvers","text":"<p>Solvers for finding a valid tracking solution from a candidate graph.</p> <p>Classes:</p> <ul> <li> <code>ILPSolver</code>           \u2013            <p>Optimal tracking solver using Integer Linear Programming (ILP).</p> </li> <li> <code>NearestNeighborsSolver</code>           \u2013            <p>Solver for tracking problems using nearest neighbor edge selection.</p> </li> </ul>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver","title":"ILPSolver","text":"<pre><code>ILPSolver(*, edge_weight: str | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST, node_weight: str | ExprInput = 0.0, appearance_weight: str | ExprInput = 0.0, disappearance_weight: str | ExprInput = 0.0, division_weight: str | ExprInput = 0.0, output_key: str = DEFAULT_ATTR_KEYS.SOLUTION, num_threads: int = 1, reset: bool = True, return_solution: bool = True, gap: float = 0.0)\n</code></pre> <p>               Bases: <code>BaseSolver</code></p> <p>Optimal tracking solver using Integer Linear Programming (ILP).</p> <p>ILPSolver formulates the multi-object tracking problem as an Integer Linear Programming optimization problem. It finds globally optimal solutions by minimizing a cost function while satisfying flow conservation constraints. The solver supports appearance, disappearance, and division events, making it suitable for complex biological tracking scenarios.</p> <p>The optimization problem includes:</p> <ul> <li>Node selection variables (whether a detection is part of a track)</li> <li>Edge selection variables (connections between detections)</li> <li>Appearance variables (track starts)</li> <li>Disappearance variables (track ends)</li> <li>Division variables (cell divisions or track splits)</li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_weight_expr</code>               (<code>EdgeAttr</code>)           \u2013            <p>Compiled edge weight expression.</p> </li> <li> <code>node_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled node weight expression.</p> </li> <li> <code>appearance_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled appearance weight expression.</p> </li> <li> <code>disappearance_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled disappearance weight expression.</p> </li> <li> <code>division_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled division weight expression.</p> </li> </ul> See Also <p>NearestNeighborsSolver:     Greedy nearest neighbors tracking solver.</p> <p>NodeAttr:     For creating node attribute expressions.</p> <p>EdgeAttr:     For creating edge attribute expressions.</p> <p>Examples:</p> <p>Basic tracking with distance-based costs:</p> <pre><code>from tracksdata.solvers import ILPSolver\n\nsolver = ILPSolver(edge_weight=\"distance\")\nsolution = solver.solve(graph)\n</code></pre> <p>Tracking with appearance and disappearance costs:</p> <pre><code>solver = ILPSolver(edge_weight=\"distance\", appearance_weight=10.0, disappearance_weight=10.0)\nsolution = solver.solve(graph)\n</code></pre> <p>Using attribute expressions for complex costs:</p> <pre><code>from tracksdata.attrs import EdgeAttr\n\nsolver = ILPSolver(edge_weight=EdgeAttr(\"distance\") + 0.1 * EdgeAttr(\"angle_change\"), division_weight=5.0)\nsolution = solver.solve(graph)\n</code></pre> Notes <p>The solver uses the ilpy library which provides interfaces to commercial solvers (Gurobi) and open-source solvers (SCIP). For best performance, install Gurobi if available, otherwise SCIP will be used as fallback.</p> <p>The ILP formulation ensures:</p> <ul> <li>Flow conservation: incoming flow equals outgoing flow for each node</li> <li>Track consistency: each detection belongs to at most one track</li> <li>Optimal solution: globally minimizes the total cost function</li> </ul> Source code in <code>src/tracksdata/solvers/_ilp_solver.py</code> <pre><code>def __init__(\n    self,\n    *,\n    edge_weight: str | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    node_weight: str | ExprInput = 0.0,\n    appearance_weight: str | ExprInput = 0.0,\n    disappearance_weight: str | ExprInput = 0.0,\n    division_weight: str | ExprInput = 0.0,\n    output_key: str = DEFAULT_ATTR_KEYS.SOLUTION,\n    num_threads: int = 1,\n    reset: bool = True,\n    return_solution: bool = True,\n    gap: float = 0.0,\n):\n    super().__init__(output_key=output_key, reset=reset, return_solution=return_solution)\n    self.edge_weight_expr = EdgeAttr(edge_weight)\n    self.node_weight_expr = NodeAttr(node_weight)\n    self.appearance_weight_expr = NodeAttr(appearance_weight)\n    self.disappearance_weight_expr = NodeAttr(disappearance_weight)\n    self.division_weight_expr = NodeAttr(division_weight)\n    self.num_threads = num_threads\n    self.gap = gap\n    self.reset_model()\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(edge_weight)","title":"<code>edge_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>DEFAULT_ATTR_KEYS.EDGE_WEIGHT</code> )           \u2013            <p>Edge attribute or expression to use as edge costs in the optimization. Lower values indicate preferred connections.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(node_weight)","title":"<code>node_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Node attribute or expression to use as node costs.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(appearance_weight)","title":"<code>appearance_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Cost for track appearances (new tracks starting).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(disappearance_weight)","title":"<code>disappearance_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Cost for track disappearances (tracks ending).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(division_weight)","title":"<code>division_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Cost for track divisions (one track splitting into two).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>DEFAULT_ATTR_KEYS.SOLUTION</code> )           \u2013            <p>Attribute key to store the solution (True/False for selected items).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(num_threads)","title":"<code>num_threads</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of threads to use for solving.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(reset)","title":"<code>reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset previous solutions before solving.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(return_solution)","title":"<code>return_solution</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return a subgraph containing only the solution.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(gap)","title":"<code>gap</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Optimality gap tolerance (0.0 for exact solutions).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr","title":"_evaluate_inf_expr","text":"<pre><code>_evaluate_inf_expr(inf_expr: list[Attr], df: DataFrame, node_key: str) -&gt; list[int]\n</code></pre> <p>Evaluate a list of infinity expressions and return the node ids that satisfy the expressions.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The node ids that satisfy the expressions.</p> </li> </ul> Source code in <code>src/tracksdata/solvers/_ilp_solver.py</code> <pre><code>def _evaluate_inf_expr(\n    self,\n    inf_expr: list[Attr],\n    df: pl.DataFrame,\n    node_key: str,\n) -&gt; list[int]:\n    \"\"\"\n    Evaluate a list of infinity expressions and return the node ids that satisfy the expressions.\n\n    Parameters\n    ----------\n    inf_expr : list[AttrExpr]\n        The list of infinity expressions to evaluate.\n    df : pl.DataFrame\n        The dataframe to evaluate the expressions on.\n    node_key : str\n        The key of the node column to filter on.\n\n    Returns\n    -------\n    list[int]\n        The node ids that satisfy the expressions.\n    \"\"\"\n    if len(inf_expr) == 0:\n        return []\n    mask = False\n    for expr in inf_expr:\n        mask = mask | expr.evaluate(df)\n    return df.select(node_key).filter(mask).to_series().to_list()\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr(inf_expr)","title":"<code>inf_expr</code>","text":"(<code>list[AttrExpr]</code>)           \u2013            <p>The list of infinity expressions to evaluate.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The dataframe to evaluate the expressions on.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr(node_key)","title":"<code>node_key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the node column to filter on.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver","title":"NearestNeighborsSolver","text":"<pre><code>NearestNeighborsSolver(max_children: int = 2, edge_weight: str | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST, output_key: str = DEFAULT_ATTR_KEYS.SOLUTION, reset: bool = True, return_solution: bool = True)\n</code></pre> <p>               Bases: <code>BaseSolver</code></p> <p>Solver for tracking problems using nearest neighbor edge selection.</p> <p>Implements a greedy nearest neighbor approach to solve tracking problems by selecting the best edges while enforcing constraints on parent-child relationships. Works by sorting all edges by weight, greedily selecting edges starting from the best weights, and enforcing constraints (each node can have at most one parent and max_children children). Runs in O(n log n) time due to sorting, where n is the number of edges.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver--parameters","title":"Parameters","text":"<p>max_children : int, default 2     Maximum number of children (successors) each node can have.     This constrains cell division events in biological tracking. edge_weight : str | AttrExpr, default DEFAULT_ATTR_KEYS.EDGE_WEIGHT     Edge attribute key or expression to use as edge weights for sorting.     Lower weights are preferred (treated as better matches).     Can be a string key or AttrExpr for complex expressions. output_key : str, default DEFAULT_ATTR_KEYS.SOLUTION     Attribute key to store the solution boolean values in nodes and edges.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver--attributes","title":"Attributes","text":"<p>max_children : int     Maximum number of children per node. solution_key : str     Key used to store solution results. edge_weight_expr : AttrExpr     Expression used to compute edge weights. output_key : str     The key to store the solution in the graph. reset : bool     Whether to reset the solution values in the whole graph before solving.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver--examples","title":"Examples","text":"<p>Basic usage with default settings:</p> <pre><code>from tracksdata.solvers import NearestNeighborsSolver\n\nsolver = NearestNeighborsSolver()\nsolver.solve(graph)\n</code></pre> <p>Customize maximum children for cell division tracking:</p> <pre><code>solver = NearestNeighborsSolver(max_children=3)\nsolver.solve(graph)\n</code></pre> <p>Use custom edge weight expression:</p> <pre><code>from tracksdata.attrs import EdgeAttr\n\nsolver = NearestNeighborsSolver(\n    edge_weight=-EdgeAttr(\"iou\"),  # Higher IoU is better\n    max_children=2,\n)\n</code></pre> <p>Combine multiple edge attributes:</p> <pre><code>weight_expr = EdgeAttr(\"distance\") + 0.5 * EdgeAttr(\"color_diff\")\nsolver = NearestNeighborsSolver(edge_weight=weight_expr)\n</code></pre> <p>Methods:</p> <ul> <li> <code>solve</code>             \u2013              <p>Solve the tracking problem using nearest neighbor edge selection.</p> </li> </ul> Source code in <code>src/tracksdata/solvers/_nearest_neighbors_solver.py</code> <pre><code>def __init__(\n    self,\n    max_children: int = 2,\n    edge_weight: str | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    output_key: str = DEFAULT_ATTR_KEYS.SOLUTION,\n    reset: bool = True,\n    return_solution: bool = True,\n):\n    super().__init__(\n        output_key=output_key,\n        reset=reset,\n        return_solution=return_solution,\n    )\n    self.max_children = max_children\n    self.edge_weight_expr = Attr(edge_weight)\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver.solve","title":"solve","text":"<pre><code>solve(graph: BaseGraph) -&gt; GraphView | None\n</code></pre> <p>Solve the tracking problem using nearest neighbor edge selection.</p> <p>Applies the nearest neighbor algorithm to find the optimal set of edges that form valid tracking paths while respecting parent-child relationship constraints. Automatically extends the graph schema to include the solution key if it doesn't already exist.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>solver = NearestNeighborsSolver(max_children=2)\nsolver.solve(graph)\n</code></pre> <p>Access solution edges:</p> <pre><code>solution_edges = graph.edge_attrs().filter(pl.col(\"solution\") == True)\n</code></pre> <p>Returns:</p> <ul> <li> <code>GraphView | None</code>           \u2013            <p>The graph view of the solution if <code>return_solution</code> is True, otherwise None.</p> </li> </ul> Source code in <code>src/tracksdata/solvers/_nearest_neighbors_solver.py</code> <pre><code>def solve(\n    self,\n    graph: BaseGraph,\n) -&gt; GraphView | None:\n    \"\"\"\n    Solve the tracking problem using nearest neighbor edge selection.\n\n    Applies the nearest neighbor algorithm to find the optimal set of edges\n    that form valid tracking paths while respecting parent-child relationship\n    constraints. Automatically extends the graph schema to include the solution\n    key if it doesn't already exist.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph containing nodes and edges to solve. The graph will be\n        modified in-place to add solution attributes to nodes and edges.\n\n    Examples\n    --------\n    ```python\n    solver = NearestNeighborsSolver(max_children=2)\n    solver.solve(graph)\n    ```\n\n    Access solution edges:\n\n    ```python\n    solution_edges = graph.edge_attrs().filter(pl.col(\"solution\") == True)\n    ```\n\n    Returns\n    -------\n    GraphView | None\n        The graph view of the solution if `return_solution` is True, otherwise None.\n    \"\"\"\n    # get edges and sort them by weight\n    edges_df = graph.edge_attrs(attr_keys=self.edge_weight_expr.columns)\n\n    if len(edges_df) == 0:\n        raise ValueError(\"No edges found in the graph, there is nothing to solve.\")\n\n    weights = self.edge_weight_expr.evaluate(edges_df).to_numpy()\n    sorted_indices = np.argsort(weights)\n\n    sorted_source = edges_df[DEFAULT_ATTR_KEYS.EDGE_SOURCE].to_numpy()[sorted_indices].astype(np.int64)\n    sorted_target = edges_df[DEFAULT_ATTR_KEYS.EDGE_TARGET].to_numpy()[sorted_indices].astype(np.int64)\n    sorted_solution = np.zeros(len(sorted_source), dtype=bool)\n\n    if graph.has_overlaps():\n        overlapping_sets = _build_constraint_dict(\n            np.asarray(graph.overlaps(), dtype=np.int64),\n        )\n        _constrained_nearest_neighbors(\n            sorted_source,\n            sorted_target,\n            sorted_solution,\n            self.max_children,\n            overlapping_sets,\n        )\n    else:\n        _constrained_nearest_neighbors(\n            sorted_source,\n            sorted_target,\n            sorted_solution,\n            self.max_children,\n        )\n    del sorted_source, sorted_target\n\n    inverted_indices = np.empty_like(sorted_indices)\n    inverted_indices[sorted_indices] = np.arange(len(sorted_indices))\n    solution = sorted_solution[inverted_indices]\n    del sorted_solution, inverted_indices, sorted_indices\n\n    solution_edges_df = edges_df.filter(solution)\n\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, False)\n    elif self.reset:\n        graph.update_edge_attrs(attrs={self.output_key: False})\n\n    graph.update_edge_attrs(\n        edge_ids=solution_edges_df[DEFAULT_ATTR_KEYS.EDGE_ID].to_numpy(),\n        attrs={self.output_key: True},\n    )\n\n    node_ids = np.unique(\n        np.concatenate(\n            [\n                solution_edges_df[DEFAULT_ATTR_KEYS.EDGE_SOURCE].to_numpy(),\n                solution_edges_df[DEFAULT_ATTR_KEYS.EDGE_TARGET].to_numpy(),\n            ]\n        )\n    )\n\n    if self.output_key not in graph.node_attr_keys:\n        graph.add_node_attr_key(self.output_key, False)\n\n    graph.update_node_attrs(\n        node_ids=node_ids,\n        attrs={self.output_key: True},\n    )\n\n    if self.return_solution:\n        return graph.subgraph(\n            NodeAttr(self.output_key) == True,\n            EdgeAttr(self.output_key) == True,\n        )\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver.solve(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph containing nodes and edges to solve. The graph will be modified in-place to add solution attributes to nodes and edges.</p>"},{"location":"reference/tracksdata/utils/","title":"tracksdata.utils","text":""},{"location":"reference/tracksdata/utils/#tracksdata.utils","title":"tracksdata.utils","text":"<p>Utility functions for data processing, type conversions, and progress tracking.</p>"}]}